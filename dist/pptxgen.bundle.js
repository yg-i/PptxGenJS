"use strict";
var PptxGenJS = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : /* @__PURE__ */ Symbol.for("Symbol." + name);
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __await = function(promise, isYieldStar) {
    this[0] = promise;
    this[1] = isYieldStar;
  };
  var __yieldStar = (value) => {
    var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
    if (obj == null) {
      obj = value[__knownSymbol("iterator")]();
      method = (k) => it[k] = (x) => obj[k](x);
    } else {
      obj = obj.call(value);
      method = (k) => it[k] = (v) => {
        if (isAwait) {
          isAwait = false;
          if (k === "throw") throw v;
          return v;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await(new Promise((resolve) => {
            var x = obj[k](v);
            if (!(x instanceof Object)) __typeError("Object expected");
            resolve(x);
          }), 1)
        };
      };
    }
    return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
      throw x;
    }, "return" in obj && method("return"), it;
  };

  // node_modules/.pnpm/process-nextick-args@2.0.1/node_modules/process-nextick-args/index.js
  var require_process_nextick_args = __commonJS({
    "node_modules/.pnpm/process-nextick-args@2.0.1/node_modules/process-nextick-args/index.js"(exports, module) {
      "use strict";
      if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
        module.exports = { nextTick };
      } else {
        module.exports = process;
      }
      function nextTick(fn, arg1, arg2, arg3) {
        if (typeof fn !== "function") {
          throw new TypeError('"callback" argument must be a function');
        }
        var len = arguments.length;
        var args, i;
        switch (len) {
          case 0:
          case 1:
            return process.nextTick(fn);
          case 2:
            return process.nextTick(function afterTickOne() {
              fn.call(null, arg1);
            });
          case 3:
            return process.nextTick(function afterTickTwo() {
              fn.call(null, arg1, arg2);
            });
          case 4:
            return process.nextTick(function afterTickThree() {
              fn.call(null, arg1, arg2, arg3);
            });
          default:
            args = new Array(len - 1);
            i = 0;
            while (i < args.length) {
              args[i++] = arguments[i];
            }
            return process.nextTick(function afterTick() {
              fn.apply(null, args);
            });
        }
      }
    }
  });

  // node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js
  var require_isarray = __commonJS({
    "node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js"(exports, module) {
      "use strict";
      var toString = {}.toString;
      module.exports = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
    }
  });

  // node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/stream.js
  var require_stream = __commonJS({
    "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module) {
      "use strict";
      module.exports = __require("stream");
    }
  });

  // node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js"(exports, module) {
      "use strict";
      var buffer = __require("buffer");
      var Buffer2 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/.pnpm/core-util-is@1.0.3/node_modules/core-util-is/lib/util.js
  var require_util = __commonJS({
    "node_modules/.pnpm/core-util-is@1.0.3/node_modules/core-util-is/lib/util.js"(exports) {
      "use strict";
      function isArray(arg) {
        if (Array.isArray) {
          return Array.isArray(arg);
        }
        return objectToString(arg) === "[object Array]";
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      function isError(e) {
        return objectToString(e) === "[object Error]" || e instanceof Error;
      }
      exports.isError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = __require("buffer").Buffer.isBuffer;
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
    }
  });

  // node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module) {
      "use strict";
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
  var require_inherits = __commonJS({
    "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js"(exports, module) {
      "use strict";
      try {
        util = __require("util");
        if (typeof util.inherits !== "function") throw "";
        module.exports = util.inherits;
      } catch (e) {
        module.exports = require_inherits_browser();
      }
      var util;
    }
  });

  // node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/BufferList.js
  var require_BufferList = __commonJS({
    "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var Buffer2 = require_safe_buffer().Buffer;
      var util = __require("util");
      function copyBuffer(src, target, offset) {
        src.copy(target, offset);
      }
      module.exports = (function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        BufferList.prototype.push = function push(v) {
          var entry = { data: v, next: null };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        };
        BufferList.prototype.unshift = function unshift(v) {
          var entry = { data: v, next: this.head };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        };
        BufferList.prototype.shift = function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        };
        BufferList.prototype.clear = function clear() {
          this.head = this.tail = null;
          this.length = 0;
        };
        BufferList.prototype.join = function join(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        };
        BufferList.prototype.concat = function concat(n) {
          if (this.length === 0) return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        };
        return BufferList;
      })();
      if (util && util.inspect && util.inspect.custom) {
        module.exports.prototype[util.inspect.custom] = function() {
          var obj = util.inspect({ length: this.length });
          return this.constructor.name + " " + obj;
        };
      }
    }
  });

  // node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy = __commonJS({
    "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      var pna = require_process_nextick_args();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              pna.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              pna.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              pna.nextTick(emitErrorNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              pna.nextTick(emitErrorNT, _this, err2);
            }
          } else if (cb) {
            cb(err2);
          }
        });
        return this;
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy
      };
    }
  });

  // node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js
  var require_node = __commonJS({
    "node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js"(exports, module) {
      "use strict";
      module.exports = __require("util").deprecate;
    }
  });

  // node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable = __commonJS({
    "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      var pna = require_process_nextick_args();
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
      var Duplex;
      Writable.WritableState = WritableState;
      var util = Object.create(require_util());
      util.inherits = require_inherits();
      var internalUtil = {
        deprecate: require_node()
      };
      var Stream = require_stream();
      var Buffer2 = require_safe_buffer().Buffer;
      var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer2.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy();
      util.inherits(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        var isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
        var hwm = options.highWaterMark;
        var writableHwm = options.writableHighWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        if (hwm || hwm === 0) this.highWaterMark = hwm;
        else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
        else this.highWaterMark = defaultHwm;
        this.highWaterMark = Math.floor(this.highWaterMark);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex();
        if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
          return new Writable(options);
        }
        this._writableState = new WritableState(options, this);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function") this._write = options.write;
          if (typeof options.writev === "function") this._writev = options.writev;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
          if (typeof options.final === "function") this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      };
      function writeAfterEnd(stream, cb) {
        var er = new Error("write after end");
        stream.emit("error", er);
        pna.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var valid = true;
        var er = false;
        if (chunk === null) {
          er = new TypeError("May not write null values to stream");
        } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        if (er) {
          stream.emit("error", er);
          pna.nextTick(cb, er);
          valid = false;
        }
        return valid;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer2.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf) encoding = "buffer";
        else if (!encoding) encoding = state.defaultEncoding;
        if (typeof cb !== "function") cb = nop;
        if (state.ended) writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string") encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret) state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (writev) stream._writev(chunk, state.onwrite);
        else stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          pna.nextTick(cb, er);
          pna.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          stream.emit("error", er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          stream.emit("error", er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        onwriteStateUpdate(state);
        if (er) onwriteError(stream, state, sync, er, cb);
        else {
          var finished = needFinish(state);
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            asyncWrite(afterWrite, stream, state, finished, cb);
          } else {
            afterWrite(stream, state, finished, cb);
          }
        }
      }
      function afterWrite(stream, state, finished, cb) {
        if (!finished) onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null) state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error("_write() is not implemented"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending) endWritable(this, state, cb);
      };
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            stream.emit("error", err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function") {
            state.pendingcb++;
            state.finalCalled = true;
            pna.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished) pna.nextTick(cb);
          else stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        get: function() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        this.end();
        cb(err);
      };
    }
  });

  // node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex = __commonJS({
    "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      var pna = require_process_nextick_args();
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var util = Object.create(require_util());
      util.inherits = require_inherits();
      var Readable = require_stream_readable();
      var Writable = require_stream_writable();
      util.inherits(Duplex, Readable);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false) this.readable = false;
        if (options && options.writable === false) this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
        this.once("end", onend);
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function() {
          return this._writableState.highWaterMark;
        }
      });
      function onend() {
        if (this.allowHalfOpen || this._writableState.ended) return;
        pna.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        get: function() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
      Duplex.prototype._destroy = function(err, cb) {
        this.push(null);
        this.end();
        pna.nextTick(cb, err);
      };
    }
  });

  // node_modules/.pnpm/string_decoder@1.1.1/node_modules/string_decoder/lib/string_decoder.js
  var require_string_decoder = __commonJS({
    "node_modules/.pnpm/string_decoder@1.1.1/node_modules/string_decoder/lib/string_decoder.js"(exports) {
      "use strict";
      var Buffer2 = require_safe_buffer().Buffer;
      var isEncoding = Buffer2.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc) return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried) return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer2.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0) return "";
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0) return "";
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127) return 0;
        else if (byte >> 5 === 6) return 2;
        else if (byte >> 4 === 14) return 3;
        else if (byte >> 3 === 30) return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i) {
        var j = buf.length - 1;
        if (j < i) return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2) nb = 0;
            else self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (r !== void 0) return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed) return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + "\uFFFD";
        return r;
      }
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString("utf16le", i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0) return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }
  });

  // node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable = __commonJS({
    "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      var pna = require_process_nextick_args();
      module.exports = Readable;
      var isArray = require_isarray();
      var Duplex;
      Readable.ReadableState = ReadableState;
      var EE = __require("events").EventEmitter;
      var EElistenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream();
      var Buffer2 = require_safe_buffer().Buffer;
      var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer2.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var util = Object.create(require_util());
      util.inherits = require_inherits();
      var debugUtil = __require("util");
      var debug = void 0;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function() {
        };
      }
      var BufferList = require_BufferList();
      var destroyImpl = require_destroy();
      var StringDecoder;
      util.inherits(Readable, Stream);
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
        else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
        else emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        var isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
        var hwm = options.highWaterMark;
        var readableHwm = options.readableHighWaterMark;
        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
        if (hwm || hwm === 0) this.highWaterMark = hwm;
        else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
        else this.highWaterMark = defaultHwm;
        this.highWaterMark = Math.floor(this.highWaterMark);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        Duplex = Duplex || require_stream_duplex();
        if (!(this instanceof Readable)) return new Readable(options);
        this._readableState = new ReadableState(options, this);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function") this._read = options.read;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable.prototype, "destroyed", {
        get: function() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable.prototype.destroy = destroyImpl.destroy;
      Readable.prototype._undestroy = destroyImpl.undestroy;
      Readable.prototype._destroy = function(err, cb) {
        this.push(null);
        cb(err);
      };
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck) er = chunkInvalid(state, chunk);
          if (er) {
            stream.emit("error", er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
              else addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              stream.emit("error", new Error("stream.push() after EOF"));
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                else maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
          }
        }
        return needMoreData(state);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);
          else state.buffer.push(chunk);
          if (state.needReadable) emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new TypeError("Invalid non-string/buffer chunk");
        }
        return er;
      }
      function needMoreData(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
      }
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      var MAX_HWM = 8388608;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended) return 0;
        if (state.objectMode) return 1;
        if (n !== n) {
          if (state.flowing && state.length) return state.buffer.head.data.length;
          else return state.length;
        }
        if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length) return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0) state.emittedReadable = false;
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended) endReadable(this);
          else emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0) endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0) state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading) n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0) ret = fromList(n, state);
        else ret = null;
        if (ret === null) {
          state.needReadable = true;
          n = 0;
        } else {
          state.length -= n;
        }
        if (state.length === 0) {
          if (!state.ended) state.needReadable = true;
          if (nOrig !== n && state.ended) endReadable(this);
        }
        if (ret !== null) this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        if (state.ended) return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        emitReadable(stream);
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          if (state.sync) pna.nextTick(emitReadable_, stream);
          else emitReadable_(stream);
        }
      }
      function emitReadable_(stream) {
        debug("emit readable");
        stream.emit("readable");
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          pna.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        var len = state.length;
        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
          else len = state.length;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n) {
        this.emit("error", new Error("_read() is not implemented"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted) pna.nextTick(endFn);
        else src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
        }
        var increasedAwaitDrain = false;
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (false === ret && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain) state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = { hasUnpiped: false };
        if (state.pipesCount === 0) return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes) return this;
          if (!dest) dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest) dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, { hasUnpiped: false });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1) return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1) state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        if (ev === "data") {
          if (this._readableState.flowing !== false) this.resume();
        } else if (ev === "readable") {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              pna.nextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          pna.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        if (!state.reading) {
          debug("resume read 0");
          stream.read(0);
        }
        state.resumeScheduled = false;
        state.awaitDrain = 0;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading) stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (false !== this._readableState.flowing) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
        }
      }
      Readable.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder) chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0)) return;
          else if (!state.objectMode && (!chunk || !chunk.length)) return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = /* @__PURE__ */ (function(method) {
              return function() {
                return stream[method].apply(stream, arguments);
              };
            })(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      });
      Readable._fromList = fromList;
      function fromList(n, state) {
        if (state.length === 0) return null;
        var ret;
        if (state.objectMode) ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder) ret = state.buffer.join("");
          else if (state.buffer.length === 1) ret = state.buffer.head.data;
          else ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = fromListPartial(n, state.buffer, state.decoder);
        }
        return ret;
      }
      function fromListPartial(n, list, hasStrings) {
        var ret;
        if (n < list.head.data.length) {
          ret = list.head.data.slice(0, n);
          list.head.data = list.head.data.slice(n);
        } else if (n === list.head.data.length) {
          ret = list.shift();
        } else {
          ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
        }
        return ret;
      }
      function copyFromBufferString(n, list) {
        var p = list.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) list.head = p.next;
              else list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      function copyFromBuffer(n, list) {
        var ret = Buffer2.allocUnsafe(n);
        var p = list.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) list.head = p.next;
              else list.head = list.tail = null;
            } else {
              list.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        list.length -= c;
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
        if (!state.endEmitted) {
          state.ended = true;
          pna.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
        }
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x) return i;
        }
        return -1;
      }
    }
  });

  // node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform = __commonJS({
    "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      module.exports = Transform;
      var Duplex = require_stream_duplex();
      var util = Object.create(require_util());
      util.inherits = require_inherits();
      util.inherits(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb) {
          return this.emit("error", new Error("write callback called multiple times"));
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function") this._transform = options.transform;
          if (typeof options.flush === "function") this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function") {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("_transform() is not implemented");
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        var _this2 = this;
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
          _this2.emit("close");
        });
      };
      function done(stream, er, data) {
        if (er) return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
        if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
        return stream.push(null);
      }
    }
  });

  // node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough = __commonJS({
    "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      module.exports = PassThrough;
      var Transform = require_stream_transform();
      var util = Object.create(require_util());
      util.inherits = require_inherits();
      util.inherits(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/readable.js
  var require_readable = __commonJS({
    "node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/readable.js"(exports, module) {
      "use strict";
      var Stream = __require("stream");
      if (process.env.READABLE_STREAM === "disable" && Stream) {
        module.exports = Stream;
        exports = module.exports = Stream.Readable;
        exports.Readable = Stream.Readable;
        exports.Writable = Stream.Writable;
        exports.Duplex = Stream.Duplex;
        exports.Transform = Stream.Transform;
        exports.PassThrough = Stream.PassThrough;
        exports.Stream = Stream;
      } else {
        exports = module.exports = require_stream_readable();
        exports.Stream = Stream || exports;
        exports.Readable = exports;
        exports.Writable = require_stream_writable();
        exports.Duplex = require_stream_duplex();
        exports.Transform = require_stream_transform();
        exports.PassThrough = require_stream_passthrough();
      }
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/support.js
  var require_support = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/support.js"(exports) {
      "use strict";
      exports.base64 = true;
      exports.array = true;
      exports.string = true;
      exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
      exports.nodebuffer = typeof Buffer !== "undefined";
      exports.uint8array = typeof Uint8Array !== "undefined";
      if (typeof ArrayBuffer === "undefined") {
        exports.blob = false;
      } else {
        buffer = new ArrayBuffer(0);
        try {
          exports.blob = new Blob([buffer], {
            type: "application/zip"
          }).size === 0;
        } catch (e) {
          try {
            Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob("application/zip").size === 0;
          } catch (e2) {
            exports.blob = false;
          }
        }
      }
      var buffer;
      var Builder;
      var builder;
      try {
        exports.nodestream = !!require_readable().Readable;
      } catch (e) {
        exports.nodestream = false;
      }
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/base64.js
  var require_base64 = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/base64.js"(exports) {
      "use strict";
      var utils = require_utils();
      var support = require_support();
      var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      exports.encode = function(input) {
        var output = [];
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0, len = input.length, remainingBytes = len;
        var isArray = utils.getTypeOf(input) !== "string";
        while (i < input.length) {
          remainingBytes = len - i;
          if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
          } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
          }
          enc1 = chr1 >> 2;
          enc2 = (chr1 & 3) << 4 | chr2 >> 4;
          enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
          enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
          output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
        }
        return output.join("");
      };
      exports.decode = function(input) {
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0, resultIndex = 0;
        var dataUrlPrefix = "data:";
        if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
          throw new Error("Invalid base64 input, it looks like a data url.");
        }
        input = input.replace(/[^A-Za-z0-9+/=]/g, "");
        var totalLength = input.length * 3 / 4;
        if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
          totalLength--;
        }
        if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
          totalLength--;
        }
        if (totalLength % 1 !== 0) {
          throw new Error("Invalid base64 input, bad content length.");
        }
        var output;
        if (support.uint8array) {
          output = new Uint8Array(totalLength | 0);
        } else {
          output = new Array(totalLength | 0);
        }
        while (i < input.length) {
          enc1 = _keyStr.indexOf(input.charAt(i++));
          enc2 = _keyStr.indexOf(input.charAt(i++));
          enc3 = _keyStr.indexOf(input.charAt(i++));
          enc4 = _keyStr.indexOf(input.charAt(i++));
          chr1 = enc1 << 2 | enc2 >> 4;
          chr2 = (enc2 & 15) << 4 | enc3 >> 2;
          chr3 = (enc3 & 3) << 6 | enc4;
          output[resultIndex++] = chr1;
          if (enc3 !== 64) {
            output[resultIndex++] = chr2;
          }
          if (enc4 !== 64) {
            output[resultIndex++] = chr3;
          }
        }
        return output;
      };
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/nodejsUtils.js
  var require_nodejsUtils = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/nodejsUtils.js"(exports, module) {
      "use strict";
      module.exports = {
        /**
         * True if this is running in Nodejs, will be undefined in a browser.
         * In a browser, browserify won't include this file and the whole module
         * will be resolved an empty object.
         */
        isNode: typeof Buffer !== "undefined",
        /**
         * Create a new nodejs Buffer from an existing content.
         * @param {Object} data the data to pass to the constructor.
         * @param {String} encoding the encoding to use.
         * @return {Buffer} a new Buffer.
         */
        newBufferFrom: function(data, encoding) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) {
            return Buffer.from(data, encoding);
          } else {
            if (typeof data === "number") {
              throw new Error('The "data" argument must not be a number');
            }
            return new Buffer(data, encoding);
          }
        },
        /**
         * Create a new nodejs Buffer with the specified size.
         * @param {Integer} size the size of the buffer.
         * @return {Buffer} a new Buffer.
         */
        allocBuffer: function(size) {
          if (Buffer.alloc) {
            return Buffer.alloc(size);
          } else {
            var buf = new Buffer(size);
            buf.fill(0);
            return buf;
          }
        },
        /**
         * Find out if an object is a Buffer.
         * @param {Object} b the object to test.
         * @return {Boolean} true if the object is a Buffer, false otherwise.
         */
        isBuffer: function(b) {
          return Buffer.isBuffer(b);
        },
        isStream: function(obj) {
          return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
        }
      };
    }
  });

  // node_modules/.pnpm/immediate@3.0.6/node_modules/immediate/lib/index.js
  var require_lib = __commonJS({
    "node_modules/.pnpm/immediate@3.0.6/node_modules/immediate/lib/index.js"(exports, module) {
      "use strict";
      var Mutation = global.MutationObserver || global.WebKitMutationObserver;
      var scheduleDrain;
      if (process.browser) {
        if (Mutation) {
          called = 0;
          observer = new Mutation(nextTick);
          element = global.document.createTextNode("");
          observer.observe(element, {
            characterData: true
          });
          scheduleDrain = function() {
            element.data = called = ++called % 2;
          };
        } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
          channel = new global.MessageChannel();
          channel.port1.onmessage = nextTick;
          scheduleDrain = function() {
            channel.port2.postMessage(0);
          };
        } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
          scheduleDrain = function() {
            var scriptEl = global.document.createElement("script");
            scriptEl.onreadystatechange = function() {
              nextTick();
              scriptEl.onreadystatechange = null;
              scriptEl.parentNode.removeChild(scriptEl);
              scriptEl = null;
            };
            global.document.documentElement.appendChild(scriptEl);
          };
        } else {
          scheduleDrain = function() {
            setTimeout(nextTick, 0);
          };
        }
      } else {
        scheduleDrain = function() {
          process.nextTick(nextTick);
        };
      }
      var called;
      var observer;
      var element;
      var channel;
      var draining;
      var queue = [];
      function nextTick() {
        draining = true;
        var i, oldQueue;
        var len = queue.length;
        while (len) {
          oldQueue = queue;
          queue = [];
          i = -1;
          while (++i < len) {
            oldQueue[i]();
          }
          len = queue.length;
        }
        draining = false;
      }
      module.exports = immediate;
      function immediate(task) {
        if (queue.push(task) === 1 && !draining) {
          scheduleDrain();
        }
      }
    }
  });

  // node_modules/.pnpm/lie@3.3.0/node_modules/lie/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/.pnpm/lie@3.3.0/node_modules/lie/lib/index.js"(exports, module) {
      "use strict";
      var immediate = require_lib();
      function INTERNAL() {
      }
      var handlers = {};
      var REJECTED = ["REJECTED"];
      var FULFILLED = ["FULFILLED"];
      var PENDING = ["PENDING"];
      if (!process.browser) {
        UNHANDLED = ["UNHANDLED"];
      }
      var UNHANDLED;
      module.exports = Promise2;
      function Promise2(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function");
        }
        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (!process.browser) {
          this.handled = UNHANDLED;
        }
        if (resolver !== INTERNAL) {
          safelyResolveThenable(this, resolver);
        }
      }
      Promise2.prototype.finally = function(callback) {
        if (typeof callback !== "function") {
          return this;
        }
        var p = this.constructor;
        return this.then(resolve2, reject2);
        function resolve2(value) {
          function yes() {
            return value;
          }
          return p.resolve(callback()).then(yes);
        }
        function reject2(reason) {
          function no() {
            throw reason;
          }
          return p.resolve(callback()).then(no);
        }
      };
      Promise2.prototype.catch = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise2.prototype.then = function(onFulfilled, onRejected) {
        if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
          return this;
        }
        var promise = new this.constructor(INTERNAL);
        if (!process.browser) {
          if (this.handled === UNHANDLED) {
            this.handled = null;
          }
        }
        if (this.state !== PENDING) {
          var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
          unwrap(promise, resolver, this.outcome);
        } else {
          this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }
        return promise;
      };
      function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === "function") {
          this.onFulfilled = onFulfilled;
          this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === "function") {
          this.onRejected = onRejected;
          this.callRejected = this.otherCallRejected;
        }
      }
      QueueItem.prototype.callFulfilled = function(value) {
        handlers.resolve(this.promise, value);
      };
      QueueItem.prototype.otherCallFulfilled = function(value) {
        unwrap(this.promise, this.onFulfilled, value);
      };
      QueueItem.prototype.callRejected = function(value) {
        handlers.reject(this.promise, value);
      };
      QueueItem.prototype.otherCallRejected = function(value) {
        unwrap(this.promise, this.onRejected, value);
      };
      function unwrap(promise, func, value) {
        immediate(function() {
          var returnValue;
          try {
            returnValue = func(value);
          } catch (e) {
            return handlers.reject(promise, e);
          }
          if (returnValue === promise) {
            handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
          } else {
            handlers.resolve(promise, returnValue);
          }
        });
      }
      handlers.resolve = function(self2, value) {
        var result = tryCatch(getThen, value);
        if (result.status === "error") {
          return handlers.reject(self2, result.value);
        }
        var thenable = result.value;
        if (thenable) {
          safelyResolveThenable(self2, thenable);
        } else {
          self2.state = FULFILLED;
          self2.outcome = value;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callFulfilled(value);
          }
        }
        return self2;
      };
      handlers.reject = function(self2, error) {
        self2.state = REJECTED;
        self2.outcome = error;
        if (!process.browser) {
          if (self2.handled === UNHANDLED) {
            immediate(function() {
              if (self2.handled === UNHANDLED) {
                process.emit("unhandledRejection", error, self2);
              }
            });
          }
        }
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callRejected(error);
        }
        return self2;
      };
      function getThen(obj) {
        var then = obj && obj.then;
        if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
          return function appyThen() {
            then.apply(obj, arguments);
          };
        }
      }
      function safelyResolveThenable(self2, thenable) {
        var called = false;
        function onError(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.reject(self2, value);
        }
        function onSuccess(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.resolve(self2, value);
        }
        function tryToUnwrap() {
          thenable(onSuccess, onError);
        }
        var result = tryCatch(tryToUnwrap);
        if (result.status === "error") {
          onError(result.value);
        }
      }
      function tryCatch(func, value) {
        var out = {};
        try {
          out.value = func(value);
          out.status = "success";
        } catch (e) {
          out.status = "error";
          out.value = e;
        }
        return out;
      }
      Promise2.resolve = resolve;
      function resolve(value) {
        if (value instanceof this) {
          return value;
        }
        return handlers.resolve(new this(INTERNAL), value);
      }
      Promise2.reject = reject;
      function reject(reason) {
        var promise = new this(INTERNAL);
        return handlers.reject(promise, reason);
      }
      Promise2.all = all;
      function all(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          allResolver(iterable[i], i);
        }
        return promise;
        function allResolver(value, i2) {
          self2.resolve(value).then(resolveFromAll, function(error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
          function resolveFromAll(outValue) {
            values[i2] = outValue;
            if (++resolved === len && !called) {
              called = true;
              handlers.resolve(promise, values);
            }
          }
        }
      }
      Promise2.race = race;
      function race(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          resolver(iterable[i]);
        }
        return promise;
        function resolver(value) {
          self2.resolve(value).then(function(response) {
            if (!called) {
              called = true;
              handlers.resolve(promise, response);
            }
          }, function(error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
        }
      }
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/external.js
  var require_external = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/external.js"(exports, module) {
      "use strict";
      var ES6Promise = null;
      if (typeof Promise !== "undefined") {
        ES6Promise = Promise;
      } else {
        ES6Promise = require_lib2();
      }
      module.exports = {
        Promise: ES6Promise
      };
    }
  });

  // node_modules/.pnpm/setimmediate@1.0.5/node_modules/setimmediate/setImmediate.js
  var require_setImmediate = __commonJS({
    "node_modules/.pnpm/setimmediate@1.0.5/node_modules/setimmediate/setImmediate.js"(exports) {
      "use strict";
      (function(global2, undefined2) {
        "use strict";
        if (global2.setImmediate) {
          return;
        }
        var nextHandle = 1;
        var tasksByHandle = {};
        var currentlyRunningATask = false;
        var doc = global2.document;
        var registerImmediate;
        function setImmediate2(callback) {
          if (typeof callback !== "function") {
            callback = new Function("" + callback);
          }
          var args = new Array(arguments.length - 1);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
          }
          var task = { callback, args };
          tasksByHandle[nextHandle] = task;
          registerImmediate(nextHandle);
          return nextHandle++;
        }
        function clearImmediate(handle) {
          delete tasksByHandle[handle];
        }
        function run(task) {
          var callback = task.callback;
          var args = task.args;
          switch (args.length) {
            case 0:
              callback();
              break;
            case 1:
              callback(args[0]);
              break;
            case 2:
              callback(args[0], args[1]);
              break;
            case 3:
              callback(args[0], args[1], args[2]);
              break;
            default:
              callback.apply(undefined2, args);
              break;
          }
        }
        function runIfPresent(handle) {
          if (currentlyRunningATask) {
            setTimeout(runIfPresent, 0, handle);
          } else {
            var task = tasksByHandle[handle];
            if (task) {
              currentlyRunningATask = true;
              try {
                run(task);
              } finally {
                clearImmediate(handle);
                currentlyRunningATask = false;
              }
            }
          }
        }
        function installNextTickImplementation() {
          registerImmediate = function(handle) {
            process.nextTick(function() {
              runIfPresent(handle);
            });
          };
        }
        function canUsePostMessage() {
          if (global2.postMessage && !global2.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global2.onmessage;
            global2.onmessage = function() {
              postMessageIsAsynchronous = false;
            };
            global2.postMessage("", "*");
            global2.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
          }
        }
        function installPostMessageImplementation() {
          var messagePrefix = "setImmediate$" + Math.random() + "$";
          var onGlobalMessage = function(event) {
            if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
              runIfPresent(+event.data.slice(messagePrefix.length));
            }
          };
          if (global2.addEventListener) {
            global2.addEventListener("message", onGlobalMessage, false);
          } else {
            global2.attachEvent("onmessage", onGlobalMessage);
          }
          registerImmediate = function(handle) {
            global2.postMessage(messagePrefix + handle, "*");
          };
        }
        function installMessageChannelImplementation() {
          var channel = new MessageChannel();
          channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
          };
          registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
          };
        }
        function installReadyStateChangeImplementation() {
          var html = doc.documentElement;
          registerImmediate = function(handle) {
            var script = doc.createElement("script");
            script.onreadystatechange = function() {
              runIfPresent(handle);
              script.onreadystatechange = null;
              html.removeChild(script);
              script = null;
            };
            html.appendChild(script);
          };
        }
        function installSetTimeoutImplementation() {
          registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
          };
        }
        var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
        attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
        if ({}.toString.call(global2.process) === "[object process]") {
          installNextTickImplementation();
        } else if (canUsePostMessage()) {
          installPostMessageImplementation();
        } else if (global2.MessageChannel) {
          installMessageChannelImplementation();
        } else if (doc && "onreadystatechange" in doc.createElement("script")) {
          installReadyStateChangeImplementation();
        } else {
          installSetTimeoutImplementation();
        }
        attachTo.setImmediate = setImmediate2;
        attachTo.clearImmediate = clearImmediate;
      })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/utils.js"(exports) {
      "use strict";
      var support = require_support();
      var base64 = require_base64();
      var nodejsUtils = require_nodejsUtils();
      var external = require_external();
      require_setImmediate();
      function string2binary(str) {
        var result = null;
        if (support.uint8array) {
          result = new Uint8Array(str.length);
        } else {
          result = new Array(str.length);
        }
        return stringToArrayLike(str, result);
      }
      exports.newBlob = function(part, type) {
        exports.checkSupport("blob");
        try {
          return new Blob([part], {
            type
          });
        } catch (e) {
          try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
          } catch (e2) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      function identity(input) {
        return input;
      }
      function stringToArrayLike(str, array) {
        for (var i = 0; i < str.length; ++i) {
          array[i] = str.charCodeAt(i) & 255;
        }
        return array;
      }
      var arrayToStringHelper = {
        /**
         * Transform an array of int into a string, chunk by chunk.
         * See the performances notes on arrayLikeToString.
         * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
         * @param {String} type the type of the array.
         * @param {Integer} chunk the chunk size.
         * @return {String} the resulting string.
         * @throws Error if the chunk is too big for the stack.
         */
        stringifyByChunk: function(array, type, chunk) {
          var result = [], k = 0, len = array.length;
          if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
          }
          while (k < len) {
            if (type === "array" || type === "nodebuffer") {
              result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            } else {
              result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
          }
          return result.join("");
        },
        /**
         * Call String.fromCharCode on every item in the array.
         * This is the naive implementation, which generate A LOT of intermediate string.
         * This should be used when everything else fail.
         * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
         * @return {String} the result.
         */
        stringifyByChar: function(array) {
          var resultStr = "";
          for (var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
          }
          return resultStr;
        },
        applyCanBeUsed: {
          /**
           * true if the browser accepts to use String.fromCharCode on Uint8Array
           */
          uint8array: (function() {
            try {
              return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
              return false;
            }
          })(),
          /**
           * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
           */
          nodebuffer: (function() {
            try {
              return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
              return false;
            }
          })()
        }
      };
      function arrayLikeToString(array) {
        var chunk = 65536, type = exports.getTypeOf(array), canUseApply = true;
        if (type === "uint8array") {
          canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
        } else if (type === "nodebuffer") {
          canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
        }
        if (canUseApply) {
          while (chunk > 1) {
            try {
              return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
              chunk = Math.floor(chunk / 2);
            }
          }
        }
        return arrayToStringHelper.stringifyByChar(array);
      }
      exports.applyFromCharCode = arrayLikeToString;
      function arrayLikeToArrayLike(arrayFrom, arrayTo) {
        for (var i = 0; i < arrayFrom.length; i++) {
          arrayTo[i] = arrayFrom[i];
        }
        return arrayTo;
      }
      var transform = {};
      transform["string"] = {
        "string": identity,
        "array": function(input) {
          return stringToArrayLike(input, new Array(input.length));
        },
        "arraybuffer": function(input) {
          return transform["string"]["uint8array"](input).buffer;
        },
        "uint8array": function(input) {
          return stringToArrayLike(input, new Uint8Array(input.length));
        },
        "nodebuffer": function(input) {
          return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
        }
      };
      transform["array"] = {
        "string": arrayLikeToString,
        "array": identity,
        "arraybuffer": function(input) {
          return new Uint8Array(input).buffer;
        },
        "uint8array": function(input) {
          return new Uint8Array(input);
        },
        "nodebuffer": function(input) {
          return nodejsUtils.newBufferFrom(input);
        }
      };
      transform["arraybuffer"] = {
        "string": function(input) {
          return arrayLikeToString(new Uint8Array(input));
        },
        "array": function(input) {
          return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
        },
        "arraybuffer": identity,
        "uint8array": function(input) {
          return new Uint8Array(input);
        },
        "nodebuffer": function(input) {
          return nodejsUtils.newBufferFrom(new Uint8Array(input));
        }
      };
      transform["uint8array"] = {
        "string": arrayLikeToString,
        "array": function(input) {
          return arrayLikeToArrayLike(input, new Array(input.length));
        },
        "arraybuffer": function(input) {
          return input.buffer;
        },
        "uint8array": identity,
        "nodebuffer": function(input) {
          return nodejsUtils.newBufferFrom(input);
        }
      };
      transform["nodebuffer"] = {
        "string": arrayLikeToString,
        "array": function(input) {
          return arrayLikeToArrayLike(input, new Array(input.length));
        },
        "arraybuffer": function(input) {
          return transform["nodebuffer"]["uint8array"](input).buffer;
        },
        "uint8array": function(input) {
          return arrayLikeToArrayLike(input, new Uint8Array(input.length));
        },
        "nodebuffer": identity
      };
      exports.transformTo = function(outputType, input) {
        if (!input) {
          input = "";
        }
        if (!outputType) {
          return input;
        }
        exports.checkSupport(outputType);
        var inputType = exports.getTypeOf(input);
        var result = transform[inputType][outputType](input);
        return result;
      };
      exports.resolve = function(path) {
        var parts = path.split("/");
        var result = [];
        for (var index = 0; index < parts.length; index++) {
          var part = parts[index];
          if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
            continue;
          } else if (part === "..") {
            result.pop();
          } else {
            result.push(part);
          }
        }
        return result.join("/");
      };
      exports.getTypeOf = function(input) {
        if (typeof input === "string") {
          return "string";
        }
        if (Object.prototype.toString.call(input) === "[object Array]") {
          return "array";
        }
        if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
          return "nodebuffer";
        }
        if (support.uint8array && input instanceof Uint8Array) {
          return "uint8array";
        }
        if (support.arraybuffer && input instanceof ArrayBuffer) {
          return "arraybuffer";
        }
      };
      exports.checkSupport = function(type) {
        var supported = support[type.toLowerCase()];
        if (!supported) {
          throw new Error(type + " is not supported by this platform");
        }
      };
      exports.MAX_VALUE_16BITS = 65535;
      exports.MAX_VALUE_32BITS = -1;
      exports.pretty = function(str) {
        var res = "", code, i;
        for (i = 0; i < (str || "").length; i++) {
          code = str.charCodeAt(i);
          res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
        }
        return res;
      };
      exports.delay = function(callback, args, self2) {
        setImmediate(function() {
          callback.apply(self2 || null, args || []);
        });
      };
      exports.inherits = function(ctor, superCtor) {
        var Obj = function() {
        };
        Obj.prototype = superCtor.prototype;
        ctor.prototype = new Obj();
      };
      exports.extend = function() {
        var result = {}, i, attr;
        for (i = 0; i < arguments.length; i++) {
          for (attr in arguments[i]) {
            if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
              result[attr] = arguments[i][attr];
            }
          }
        }
        return result;
      };
      exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
        var promise = external.Promise.resolve(inputData).then(function(data) {
          var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
          if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function(resolve, reject) {
              var reader = new FileReader();
              reader.onload = function(e) {
                resolve(e.target.result);
              };
              reader.onerror = function(e) {
                reject(e.target.error);
              };
              reader.readAsArrayBuffer(data);
            });
          } else {
            return data;
          }
        });
        return promise.then(function(data) {
          var dataType = exports.getTypeOf(data);
          if (!dataType) {
            return external.Promise.reject(
              new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
            );
          }
          if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
          } else if (dataType === "string") {
            if (isBase64) {
              data = base64.decode(data);
            } else if (isBinary) {
              if (isOptimizedBinaryString !== true) {
                data = string2binary(data);
              }
            }
          }
          return data;
        });
      };
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/GenericWorker.js
  var require_GenericWorker = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/GenericWorker.js"(exports, module) {
      "use strict";
      function GenericWorker(name) {
        this.name = name || "default";
        this.streamInfo = {};
        this.generatedError = null;
        this.extraStreamInfo = {};
        this.isPaused = true;
        this.isFinished = false;
        this.isLocked = false;
        this._listeners = {
          "data": [],
          "end": [],
          "error": []
        };
        this.previous = null;
      }
      GenericWorker.prototype = {
        /**
         * Push a chunk to the next workers.
         * @param {Object} chunk the chunk to push
         */
        push: function(chunk) {
          this.emit("data", chunk);
        },
        /**
         * End the stream.
         * @return {Boolean} true if this call ended the worker, false otherwise.
         */
        end: function() {
          if (this.isFinished) {
            return false;
          }
          this.flush();
          try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
          } catch (e) {
            this.emit("error", e);
          }
          return true;
        },
        /**
         * End the stream with an error.
         * @param {Error} e the error which caused the premature end.
         * @return {Boolean} true if this call ended the worker with an error, false otherwise.
         */
        error: function(e) {
          if (this.isFinished) {
            return false;
          }
          if (this.isPaused) {
            this.generatedError = e;
          } else {
            this.isFinished = true;
            this.emit("error", e);
            if (this.previous) {
              this.previous.error(e);
            }
            this.cleanUp();
          }
          return true;
        },
        /**
         * Add a callback on an event.
         * @param {String} name the name of the event (data, end, error)
         * @param {Function} listener the function to call when the event is triggered
         * @return {GenericWorker} the current object for chainability
         */
        on: function(name, listener) {
          this._listeners[name].push(listener);
          return this;
        },
        /**
         * Clean any references when a worker is ending.
         */
        cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null;
          this._listeners = [];
        },
        /**
         * Trigger an event. This will call registered callback with the provided arg.
         * @param {String} name the name of the event (data, end, error)
         * @param {Object} arg the argument to call the callback with.
         */
        emit: function(name, arg) {
          if (this._listeners[name]) {
            for (var i = 0; i < this._listeners[name].length; i++) {
              this._listeners[name][i].call(this, arg);
            }
          }
        },
        /**
         * Chain a worker with an other.
         * @param {Worker} next the worker receiving events from the current one.
         * @return {worker} the next worker for chainability
         */
        pipe: function(next) {
          return next.registerPrevious(this);
        },
        /**
         * Same as `pipe` in the other direction.
         * Using an API with `pipe(next)` is very easy.
         * Implementing the API with the point of view of the next one registering
         * a source is easier, see the ZipFileWorker.
         * @param {Worker} previous the previous worker, sending events to this one
         * @return {Worker} the current worker for chainability
         */
        registerPrevious: function(previous) {
          if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
          }
          this.streamInfo = previous.streamInfo;
          this.mergeStreamInfo();
          this.previous = previous;
          var self2 = this;
          previous.on("data", function(chunk) {
            self2.processChunk(chunk);
          });
          previous.on("end", function() {
            self2.end();
          });
          previous.on("error", function(e) {
            self2.error(e);
          });
          return this;
        },
        /**
         * Pause the stream so it doesn't send events anymore.
         * @return {Boolean} true if this call paused the worker, false otherwise.
         */
        pause: function() {
          if (this.isPaused || this.isFinished) {
            return false;
          }
          this.isPaused = true;
          if (this.previous) {
            this.previous.pause();
          }
          return true;
        },
        /**
         * Resume a paused stream.
         * @return {Boolean} true if this call resumed the worker, false otherwise.
         */
        resume: function() {
          if (!this.isPaused || this.isFinished) {
            return false;
          }
          this.isPaused = false;
          var withError = false;
          if (this.generatedError) {
            this.error(this.generatedError);
            withError = true;
          }
          if (this.previous) {
            this.previous.resume();
          }
          return !withError;
        },
        /**
         * Flush any remaining bytes as the stream is ending.
         */
        flush: function() {
        },
        /**
         * Process a chunk. This is usually the method overridden.
         * @param {Object} chunk the chunk to process.
         */
        processChunk: function(chunk) {
          this.push(chunk);
        },
        /**
         * Add a key/value to be added in the workers chain streamInfo once activated.
         * @param {String} key the key to use
         * @param {Object} value the associated value
         * @return {Worker} the current worker for chainability
         */
        withStreamInfo: function(key, value) {
          this.extraStreamInfo[key] = value;
          this.mergeStreamInfo();
          return this;
        },
        /**
         * Merge this worker's streamInfo into the chain's streamInfo.
         */
        mergeStreamInfo: function() {
          for (var key in this.extraStreamInfo) {
            if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
              continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
          }
        },
        /**
         * Lock the stream to prevent further updates on the workers chain.
         * After calling this method, all calls to pipe will fail.
         */
        lock: function() {
          if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
          }
          this.isLocked = true;
          if (this.previous) {
            this.previous.lock();
          }
        },
        /**
         *
         * Pretty print the workers chain.
         */
        toString: function() {
          var me = "Worker " + this.name;
          if (this.previous) {
            return this.previous + " -> " + me;
          } else {
            return me;
          }
        }
      };
      module.exports = GenericWorker;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/utf8.js
  var require_utf8 = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/utf8.js"(exports) {
      "use strict";
      var utils = require_utils();
      var support = require_support();
      var nodejsUtils = require_nodejsUtils();
      var GenericWorker = require_GenericWorker();
      var _utf8len = new Array(256);
      for (i = 0; i < 256; i++) {
        _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
      }
      var i;
      _utf8len[254] = _utf8len[254] = 1;
      var string2buf = function(str) {
        var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        if (support.uint8array) {
          buf = new Uint8Array(buf_len);
        } else {
          buf = new Array(buf_len);
        }
        for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i2++] = c;
          } else if (c < 2048) {
            buf[i2++] = 192 | c >>> 6;
            buf[i2++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i2++] = 224 | c >>> 12;
            buf[i2++] = 128 | c >>> 6 & 63;
            buf[i2++] = 128 | c & 63;
          } else {
            buf[i2++] = 240 | c >>> 18;
            buf[i2++] = 128 | c >>> 12 & 63;
            buf[i2++] = 128 | c >>> 6 & 63;
            buf[i2++] = 128 | c & 63;
          }
        }
        return buf;
      };
      var utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
      var buf2string = function(buf) {
        var i2, out, c, c_len;
        var len = buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i2 = 0; i2 < len; ) {
          c = buf[i2++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue;
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i2 += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i2 < len) {
            c = c << 6 | buf[i2++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out++] = c;
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023;
          }
        }
        if (utf16buf.length !== out) {
          if (utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
          } else {
            utf16buf.length = out;
          }
        }
        return utils.applyFromCharCode(utf16buf);
      };
      exports.utf8encode = function utf8encode(str) {
        if (support.nodebuffer) {
          return nodejsUtils.newBufferFrom(str, "utf-8");
        }
        return string2buf(str);
      };
      exports.utf8decode = function utf8decode(buf) {
        if (support.nodebuffer) {
          return utils.transformTo("nodebuffer", buf).toString("utf-8");
        }
        buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
        return buf2string(buf);
      };
      function Utf8DecodeWorker() {
        GenericWorker.call(this, "utf-8 decode");
        this.leftOver = null;
      }
      utils.inherits(Utf8DecodeWorker, GenericWorker);
      Utf8DecodeWorker.prototype.processChunk = function(chunk) {
        var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
        if (this.leftOver && this.leftOver.length) {
          if (support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
          } else {
            data = this.leftOver.concat(data);
          }
          this.leftOver = null;
        }
        var nextBoundary = utf8border(data);
        var usableData = data;
        if (nextBoundary !== data.length) {
          if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
          } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
          }
        }
        this.push({
          data: exports.utf8decode(usableData),
          meta: chunk.meta
        });
      };
      Utf8DecodeWorker.prototype.flush = function() {
        if (this.leftOver && this.leftOver.length) {
          this.push({
            data: exports.utf8decode(this.leftOver),
            meta: {}
          });
          this.leftOver = null;
        }
      };
      exports.Utf8DecodeWorker = Utf8DecodeWorker;
      function Utf8EncodeWorker() {
        GenericWorker.call(this, "utf-8 encode");
      }
      utils.inherits(Utf8EncodeWorker, GenericWorker);
      Utf8EncodeWorker.prototype.processChunk = function(chunk) {
        this.push({
          data: exports.utf8encode(chunk.data),
          meta: chunk.meta
        });
      };
      exports.Utf8EncodeWorker = Utf8EncodeWorker;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/ConvertWorker.js
  var require_ConvertWorker = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/ConvertWorker.js"(exports, module) {
      "use strict";
      var GenericWorker = require_GenericWorker();
      var utils = require_utils();
      function ConvertWorker(destType) {
        GenericWorker.call(this, "ConvertWorker to " + destType);
        this.destType = destType;
      }
      utils.inherits(ConvertWorker, GenericWorker);
      ConvertWorker.prototype.processChunk = function(chunk) {
        this.push({
          data: utils.transformTo(this.destType, chunk.data),
          meta: chunk.meta
        });
      };
      module.exports = ConvertWorker;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
  var require_NodejsStreamOutputAdapter = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js"(exports, module) {
      "use strict";
      var Readable = require_readable().Readable;
      var utils = require_utils();
      utils.inherits(NodejsStreamOutputAdapter, Readable);
      function NodejsStreamOutputAdapter(helper, options, updateCb) {
        Readable.call(this, options);
        this._helper = helper;
        var self2 = this;
        helper.on("data", function(data, meta) {
          if (!self2.push(data)) {
            self2._helper.pause();
          }
          if (updateCb) {
            updateCb(meta);
          }
        }).on("error", function(e) {
          self2.emit("error", e);
        }).on("end", function() {
          self2.push(null);
        });
      }
      NodejsStreamOutputAdapter.prototype._read = function() {
        this._helper.resume();
      };
      module.exports = NodejsStreamOutputAdapter;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/StreamHelper.js
  var require_StreamHelper = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/StreamHelper.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var ConvertWorker = require_ConvertWorker();
      var GenericWorker = require_GenericWorker();
      var base64 = require_base64();
      var support = require_support();
      var external = require_external();
      var NodejsStreamOutputAdapter = null;
      if (support.nodestream) {
        try {
          NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
        } catch (e) {
        }
      }
      function transformZipOutput(type, content, mimeType) {
        switch (type) {
          case "blob":
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
          case "base64":
            return base64.encode(content);
          default:
            return utils.transformTo(type, content);
        }
      }
      function concat(type, dataArray) {
        var i, index = 0, res = null, totalLength = 0;
        for (i = 0; i < dataArray.length; i++) {
          totalLength += dataArray[i].length;
        }
        switch (type) {
          case "string":
            return dataArray.join("");
          case "array":
            return Array.prototype.concat.apply([], dataArray);
          case "uint8array":
            res = new Uint8Array(totalLength);
            for (i = 0; i < dataArray.length; i++) {
              res.set(dataArray[i], index);
              index += dataArray[i].length;
            }
            return res;
          case "nodebuffer":
            return Buffer.concat(dataArray);
          default:
            throw new Error("concat : unsupported type '" + type + "'");
        }
      }
      function accumulate(helper, updateCallback) {
        return new external.Promise(function(resolve, reject) {
          var dataArray = [];
          var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
          helper.on("data", function(data, meta) {
            dataArray.push(data);
            if (updateCallback) {
              updateCallback(meta);
            }
          }).on("error", function(err) {
            dataArray = [];
            reject(err);
          }).on("end", function() {
            try {
              var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
              resolve(result);
            } catch (e) {
              reject(e);
            }
            dataArray = [];
          }).resume();
        });
      }
      function StreamHelper(worker, outputType, mimeType) {
        var internalType = outputType;
        switch (outputType) {
          case "blob":
          case "arraybuffer":
            internalType = "uint8array";
            break;
          case "base64":
            internalType = "string";
            break;
        }
        try {
          this._internalType = internalType;
          this._outputType = outputType;
          this._mimeType = mimeType;
          utils.checkSupport(internalType);
          this._worker = worker.pipe(new ConvertWorker(internalType));
          worker.lock();
        } catch (e) {
          this._worker = new GenericWorker("error");
          this._worker.error(e);
        }
      }
      StreamHelper.prototype = {
        /**
         * Listen a StreamHelper, accumulate its content and concatenate it into a
         * complete block.
         * @param {Function} updateCb the update callback.
         * @return Promise the promise for the accumulation.
         */
        accumulate: function(updateCb) {
          return accumulate(this, updateCb);
        },
        /**
         * Add a listener on an event triggered on a stream.
         * @param {String} evt the name of the event
         * @param {Function} fn the listener
         * @return {StreamHelper} the current helper.
         */
        on: function(evt, fn) {
          var self2 = this;
          if (evt === "data") {
            this._worker.on(evt, function(chunk) {
              fn.call(self2, chunk.data, chunk.meta);
            });
          } else {
            this._worker.on(evt, function() {
              utils.delay(fn, arguments, self2);
            });
          }
          return this;
        },
        /**
         * Resume the flow of chunks.
         * @return {StreamHelper} the current helper.
         */
        resume: function() {
          utils.delay(this._worker.resume, [], this._worker);
          return this;
        },
        /**
         * Pause the flow of chunks.
         * @return {StreamHelper} the current helper.
         */
        pause: function() {
          this._worker.pause();
          return this;
        },
        /**
         * Return a nodejs stream for this helper.
         * @param {Function} updateCb the update callback.
         * @return {NodejsStreamOutputAdapter} the nodejs stream.
         */
        toNodejsStream: function(updateCb) {
          utils.checkSupport("nodestream");
          if (this._outputType !== "nodebuffer") {
            throw new Error(this._outputType + " is not supported by this method");
          }
          return new NodejsStreamOutputAdapter(this, {
            objectMode: this._outputType !== "nodebuffer"
          }, updateCb);
        }
      };
      module.exports = StreamHelper;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/defaults.js
  var require_defaults = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/defaults.js"(exports) {
      "use strict";
      exports.base64 = false;
      exports.binary = false;
      exports.dir = false;
      exports.createFolders = true;
      exports.date = null;
      exports.compression = null;
      exports.compressionOptions = null;
      exports.comment = null;
      exports.unixPermissions = null;
      exports.dosPermissions = null;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/DataWorker.js
  var require_DataWorker = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/DataWorker.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var GenericWorker = require_GenericWorker();
      var DEFAULT_BLOCK_SIZE = 16 * 1024;
      function DataWorker(dataP) {
        GenericWorker.call(this, "DataWorker");
        var self2 = this;
        this.dataIsReady = false;
        this.index = 0;
        this.max = 0;
        this.data = null;
        this.type = "";
        this._tickScheduled = false;
        dataP.then(function(data) {
          self2.dataIsReady = true;
          self2.data = data;
          self2.max = data && data.length || 0;
          self2.type = utils.getTypeOf(data);
          if (!self2.isPaused) {
            self2._tickAndRepeat();
          }
        }, function(e) {
          self2.error(e);
        });
      }
      utils.inherits(DataWorker, GenericWorker);
      DataWorker.prototype.cleanUp = function() {
        GenericWorker.prototype.cleanUp.call(this);
        this.data = null;
      };
      DataWorker.prototype.resume = function() {
        if (!GenericWorker.prototype.resume.call(this)) {
          return false;
        }
        if (!this._tickScheduled && this.dataIsReady) {
          this._tickScheduled = true;
          utils.delay(this._tickAndRepeat, [], this);
        }
        return true;
      };
      DataWorker.prototype._tickAndRepeat = function() {
        this._tickScheduled = false;
        if (this.isPaused || this.isFinished) {
          return;
        }
        this._tick();
        if (!this.isFinished) {
          utils.delay(this._tickAndRepeat, [], this);
          this._tickScheduled = true;
        }
      };
      DataWorker.prototype._tick = function() {
        if (this.isPaused || this.isFinished) {
          return false;
        }
        var size = DEFAULT_BLOCK_SIZE;
        var data = null, nextIndex = Math.min(this.max, this.index + size);
        if (this.index >= this.max) {
          return this.end();
        } else {
          switch (this.type) {
            case "string":
              data = this.data.substring(this.index, nextIndex);
              break;
            case "uint8array":
              data = this.data.subarray(this.index, nextIndex);
              break;
            case "array":
            case "nodebuffer":
              data = this.data.slice(this.index, nextIndex);
              break;
          }
          this.index = nextIndex;
          return this.push({
            data,
            meta: {
              percent: this.max ? this.index / this.max * 100 : 0
            }
          });
        }
      };
      module.exports = DataWorker;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/crc32.js
  var require_crc32 = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/crc32.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n] = c;
        }
        return table;
      }
      var crcTable = makeTable();
      function crc32(crc, buf, len, pos) {
        var t = crcTable, end = pos + len;
        crc = crc ^ -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      }
      function crc32str(crc, str, len, pos) {
        var t = crcTable, end = pos + len;
        crc = crc ^ -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
        }
        return crc ^ -1;
      }
      module.exports = function crc32wrapper(input, crc) {
        if (typeof input === "undefined" || !input.length) {
          return 0;
        }
        var isArray = utils.getTypeOf(input) !== "string";
        if (isArray) {
          return crc32(crc | 0, input, input.length, 0);
        } else {
          return crc32str(crc | 0, input, input.length, 0);
        }
      };
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/Crc32Probe.js
  var require_Crc32Probe = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/Crc32Probe.js"(exports, module) {
      "use strict";
      var GenericWorker = require_GenericWorker();
      var crc32 = require_crc32();
      var utils = require_utils();
      function Crc32Probe() {
        GenericWorker.call(this, "Crc32Probe");
        this.withStreamInfo("crc32", 0);
      }
      utils.inherits(Crc32Probe, GenericWorker);
      Crc32Probe.prototype.processChunk = function(chunk) {
        this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
        this.push(chunk);
      };
      module.exports = Crc32Probe;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/DataLengthProbe.js
  var require_DataLengthProbe = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/stream/DataLengthProbe.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var GenericWorker = require_GenericWorker();
      function DataLengthProbe(propName) {
        GenericWorker.call(this, "DataLengthProbe for " + propName);
        this.propName = propName;
        this.withStreamInfo(propName, 0);
      }
      utils.inherits(DataLengthProbe, GenericWorker);
      DataLengthProbe.prototype.processChunk = function(chunk) {
        if (chunk) {
          var length = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = length + chunk.data.length;
        }
        GenericWorker.prototype.processChunk.call(this, chunk);
      };
      module.exports = DataLengthProbe;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/compressedObject.js
  var require_compressedObject = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/compressedObject.js"(exports, module) {
      "use strict";
      var external = require_external();
      var DataWorker = require_DataWorker();
      var Crc32Probe = require_Crc32Probe();
      var DataLengthProbe = require_DataLengthProbe();
      function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
        this.compressedSize = compressedSize;
        this.uncompressedSize = uncompressedSize;
        this.crc32 = crc32;
        this.compression = compression;
        this.compressedContent = data;
      }
      CompressedObject.prototype = {
        /**
         * Create a worker to get the uncompressed content.
         * @return {GenericWorker} the worker.
         */
        getContentWorker: function() {
          var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
          var that = this;
          worker.on("end", function() {
            if (this.streamInfo["data_length"] !== that.uncompressedSize) {
              throw new Error("Bug : uncompressed data size mismatch");
            }
          });
          return worker;
        },
        /**
         * Create a worker to get the compressed content.
         * @return {GenericWorker} the worker.
         */
        getCompressedWorker: function() {
          return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        }
      };
      CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
        return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
      };
      module.exports = CompressedObject;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/zipObject.js
  var require_zipObject = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/zipObject.js"(exports, module) {
      "use strict";
      var StreamHelper = require_StreamHelper();
      var DataWorker = require_DataWorker();
      var utf8 = require_utf8();
      var CompressedObject = require_compressedObject();
      var GenericWorker = require_GenericWorker();
      var ZipObject = function(name, data, options) {
        this.name = name;
        this.dir = options.dir;
        this.date = options.date;
        this.comment = options.comment;
        this.unixPermissions = options.unixPermissions;
        this.dosPermissions = options.dosPermissions;
        this._data = data;
        this._dataBinary = options.binary;
        this.options = {
          compression: options.compression,
          compressionOptions: options.compressionOptions
        };
      };
      ZipObject.prototype = {
        /**
         * Create an internal stream for the content of this object.
         * @param {String} type the type of each chunk.
         * @return StreamHelper the stream.
         */
        internalStream: function(type) {
          var result = null, outputType = "string";
          try {
            if (!type) {
              throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
              outputType = "string";
            }
            result = this._decompressWorker();
            var isUnicodeString = !this._dataBinary;
            if (isUnicodeString && !askUnicodeString) {
              result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
              result = result.pipe(new utf8.Utf8DecodeWorker());
            }
          } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
          }
          return new StreamHelper(result, outputType, "");
        },
        /**
         * Prepare the content in the asked type.
         * @param {String} type the type of the result.
         * @param {Function} onUpdate a function to call on each internal update.
         * @return Promise the promise of the result.
         */
        async: function(type, onUpdate) {
          return this.internalStream(type).accumulate(onUpdate);
        },
        /**
         * Prepare the content as a nodejs stream.
         * @param {String} type the type of each chunk.
         * @param {Function} onUpdate a function to call on each internal update.
         * @return Stream the stream.
         */
        nodeStream: function(type, onUpdate) {
          return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
        },
        /**
         * Return a worker for the compressed content.
         * @private
         * @param {Object} compression the compression object to use.
         * @param {Object} compressionOptions the options to use when compressing.
         * @return Worker the worker.
         */
        _compressWorker: function(compression, compressionOptions) {
          if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
            return this._data.getCompressedWorker();
          } else {
            var result = this._decompressWorker();
            if (!this._dataBinary) {
              result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
          }
        },
        /**
         * Return a worker for the decompressed content.
         * @private
         * @return Worker the worker.
         */
        _decompressWorker: function() {
          if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
          } else if (this._data instanceof GenericWorker) {
            return this._data;
          } else {
            return new DataWorker(this._data);
          }
        }
      };
      var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
      var removedFn = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      };
      for (i = 0; i < removedMethods.length; i++) {
        ZipObject.prototype[removedMethods[i]] = removedFn;
      }
      var i;
      module.exports = ZipObject;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js
  var require_common = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js"(exports) {
      "use strict";
      var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
      function _has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      exports.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (var p in source) {
            if (_has(source, p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      };
      exports.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
          return buf;
        }
        if (buf.subarray) {
          return buf.subarray(0, size);
        }
        buf.length = size;
        return buf;
      };
      var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return;
          }
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
          var i, l, len, pos, chunk, result;
          len = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
          }
          result = new Uint8Array(len);
          pos = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
          }
          return result;
        }
      };
      var fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
          return [].concat.apply([], chunks);
        }
      };
      exports.setTyped = function(on) {
        if (on) {
          exports.Buf8 = Uint8Array;
          exports.Buf16 = Uint16Array;
          exports.Buf32 = Int32Array;
          exports.assign(exports, fnTyped);
        } else {
          exports.Buf8 = Array;
          exports.Buf16 = Array;
          exports.Buf32 = Array;
          exports.assign(exports, fnUntyped);
        }
      };
      exports.setTyped(TYPED_OK);
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js
  var require_trees = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js"(exports) {
      "use strict";
      var utils = require_common();
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;
      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = (
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
      );
      var extra_dbits = (
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
      );
      var extra_blbits = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      );
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);
      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      }
      function put_short(s, w) {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
      }
      function send_bits(s, value, length) {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length;
        }
      }
      function send_code(s, c, tree) {
        send_bits(
          s,
          tree[c * 2],
          tree[c * 2 + 1]
          /*.Len*/
        );
      }
      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      }
      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      }
      function gen_bitlen(s, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h;
        var n, m;
        var bits;
        var xbits;
        var f;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      }
      function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
      }
      function tr_static_init() {
        var n;
        var bits;
        var length;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code;
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      }
      function init_block(s) {
        var n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
      }
      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      }
      function copy_block(s, buf, len, header) {
        bi_windup(s);
        if (header) {
          put_short(s, len);
          put_short(s, ~len);
        }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
      }
      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
      }
      function pqdownheap(s, tree, k) {
        var v = s.heap[k];
        var j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1;
        }
        s.heap[k] = v;
      }
      function compress_block(s, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s.last_lit !== 0) {
          do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);
              }
            }
          } while (lx < s.last_lit);
        }
        send_code(s, END_BLOCK, ltree);
      }
      function build_tree(s, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        var max_code = -1;
        var node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[
            1
            /*SMALLEST*/
          ];
          s.heap[
            1
            /*SMALLEST*/
          ] = s.heap[s.heap_len--];
          pqdownheap(
            s,
            tree,
            1
            /*SMALLEST*/
          );
          m = s.heap[
            1
            /*SMALLEST*/
          ];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[
            1
            /*SMALLEST*/
          ] = node++;
          pqdownheap(
            s,
            tree,
            1
            /*SMALLEST*/
          );
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[
          1
          /*SMALLEST*/
        ];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      }
      function scan_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function send_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function build_bl_tree(s) {
        var max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      }
      function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      }
      function detect_data_type(s) {
        var black_mask = 4093624447;
        var n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      }
      var static_init_done = false;
      function _tr_init(s) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      }
      function _tr_stored_block(s, buf, stored_len, last) {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true);
      }
      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      }
      function _tr_flush_block(s, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
          bi_windup(s);
        }
      }
      function _tr_tally(s, dist, lc) {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.last_lit === s.lit_bufsize - 1;
      }
      exports._tr_init = _tr_init;
      exports._tr_stored_block = _tr_stored_block;
      exports._tr_flush_block = _tr_flush_block;
      exports._tr_tally = _tr_tally;
      exports._tr_align = _tr_align;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js
  var require_adler32 = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js"(exports, module) {
      "use strict";
      function adler32(adler, buf, len, pos) {
        var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      }
      module.exports = adler32;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js
  var require_crc322 = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js"(exports, module) {
      "use strict";
      function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n] = c;
        }
        return table;
      }
      var crcTable = makeTable();
      function crc32(crc, buf, len, pos) {
        var t = crcTable, end = pos + len;
        crc ^= -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      }
      module.exports = crc32;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js
  var require_messages = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js"(exports, module) {
      "use strict";
      module.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js
  var require_deflate = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js"(exports) {
      "use strict";
      var utils = require_common();
      var trees = require_trees();
      var adler32 = require_adler32();
      var crc32 = require_crc322();
      var msg = require_messages();
      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1;
      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_BUF_ERROR = -5;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_UNKNOWN = 2;
      var Z_DEFLATED = 8;
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;
      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
      }
      function rank(f) {
        return (f << 1) - (f > 4 ? 9 : 0);
      }
      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      function flush_pending(strm) {
        var s = strm.state;
        var len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      }
      function flush_block_only(s, last) {
        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      }
      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
      }
      function putShortMSB(s, b) {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
      }
      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      }
      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        var scan = s.strstart;
        var match;
        var len;
        var best_len = s.prev_length;
        var nice_match = s.nice_match;
        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        var _win = s.window;
        var wmask = s.w_mask;
        var prev = s.prev;
        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      }
      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
            while (s.insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      }
      function deflate_stored(s, flush) {
        var max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5;
        }
        for (; ; ) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          var max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_NEED_MORE;
      }
      function deflate_fast(s, flush) {
        var hash_head;
        var bflush;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
            }
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_slow(s, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_rle(s, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s.window;
        for (; ; ) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_huff(s, flush) {
        var bflush;
        for (; ; ) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table;
      configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored),
        /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast),
        /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast),
        /* 2 */
        new Config(4, 6, 32, 32, deflate_fast),
        /* 3 */
        new Config(4, 4, 16, 16, deflate_slow),
        /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow),
        /* 5 */
        new Config(8, 16, 128, 128, deflate_slow),
        /* 6 */
        new Config(8, 32, 128, 256, deflate_slow),
        /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow),
        /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow)
        /* 9 max compression */
      ];
      function lm_init(s) {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      }
      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      function deflateResetKeep(strm) {
        var s;
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK;
      }
      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      }
      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      }
      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        var s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      }
      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      }
      function deflate(strm, flush) {
        var old_flush, s;
        var beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        s.strm = strm;
        old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE;
            } else {
              put_byte(
                s,
                (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
              );
              put_byte(s, s.gzhead.time & 255);
              put_byte(s, s.gzhead.time >> 8 & 255);
              put_byte(s, s.gzhead.time >> 16 & 255);
              put_byte(s, s.gzhead.time >> 24 & 255);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 255);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 255);
                put_byte(s, s.gzhead.extra.length >> 8 & 255);
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE;
            }
          } else {
            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0;
            } else if (s.level < 6) {
              level_flags = 1;
            } else if (s.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535);
            }
            strm.adler = 1;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 65535)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break;
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 255);
              s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE;
            }
          } else {
            s.status = NAME_STATE;
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE;
            }
          } else {
            s.status = COMMENT_STATE;
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.status = HCRC_STATE;
            }
          } else {
            s.status = HCRC_STATE;
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              strm.adler = 0;
              s.status = BUSY_STATE;
            }
          } else {
            s.status = BUSY_STATE;
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s);
            } else if (flush !== Z_BLOCK) {
              trees._tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      }
      function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      }
      function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s;
        var str, n;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        s = strm.state;
        wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          tmpDict = new utils.Buf8(s.w_size);
          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          str = s.strstart;
          n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      }
      exports.deflateInit = deflateInit;
      exports.deflateInit2 = deflateInit2;
      exports.deflateReset = deflateReset;
      exports.deflateResetKeep = deflateResetKeep;
      exports.deflateSetHeader = deflateSetHeader;
      exports.deflate = deflate;
      exports.deflateEnd = deflateEnd;
      exports.deflateSetDictionary = deflateSetDictionary;
      exports.deflateInfo = "pako deflate (from Nodeca project)";
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js
  var require_strings = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js"(exports) {
      "use strict";
      var utils = require_common();
      var STR_APPLY_OK = true;
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (__) {
        STR_APPLY_OK = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new utils.Buf8(256);
      for (q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
      }
      var q;
      _utf8len[254] = _utf8len[254] = 1;
      exports.string2buf = function(str) {
        var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new utils.Buf8(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i++] = c;
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          }
        }
        return buf;
      };
      function buf2binstring(buf, len) {
        if (len < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
          }
        }
        var result = "";
        for (var i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      }
      exports.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length);
      };
      exports.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i = 0, len = buf.length; i < len; i++) {
          buf[i] = str.charCodeAt(i);
        }
        return buf;
      };
      exports.buf2string = function(buf, max) {
        var i, out, c, c_len;
        var len = max || buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
          c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue;
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out++] = c;
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023;
          }
        }
        return buf2binstring(utf16buf, out);
      };
      exports.utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js
  var require_zstream = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js"(exports, module) {
      "use strict";
      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module.exports = ZStream;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js
  var require_deflate2 = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js"(exports) {
      "use strict";
      var zlib_deflate = require_deflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var toString = Object.prototype.toString;
      var Z_NO_FLUSH = 0;
      var Z_FINISH = 4;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_SYNC_FLUSH = 2;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_DEFLATED = 8;
      function Deflate(options) {
        if (!(this instanceof Deflate)) return new Deflate(options);
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_deflate.deflateInit2(
          this.strm,
          opt.level,
          opt.method,
          opt.windowBits,
          opt.memLevel,
          opt.strategy
        );
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          var dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_deflate.deflate(strm, _mode);
          if (status !== Z_STREAM_END && status !== Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
        if (_mode === Z_FINISH) {
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (_mode === Z_SYNC_FLUSH) {
          this.onEnd(Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function deflate(input, options) {
        var deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || msg[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }
      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      exports.Deflate = Deflate;
      exports.deflate = deflate;
      exports.deflateRaw = deflateRaw;
      exports.gzip = gzip;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js
  var require_inffast = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js"(exports, module) {
      "use strict";
      var BAD = 30;
      var TYPE = 12;
      module.exports = function inflate_fast(strm, start) {
        var state;
        var _in;
        var last;
        var _out;
        var beg;
        var end;
        var dmax;
        var wsize;
        var whave;
        var wnext;
        var s_window;
        var hold;
        var bits;
        var lcode;
        var dcode;
        var lmask;
        var dmask;
        var here;
        var op;
        var len;
        var dist;
        var from;
        var from_source;
        var input, output;
        state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output[_out++] = here & 65535;
                } else if (op & 16) {
                  len = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (; ; ) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = here >>> 16 & 255;
                      if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                          op = dist - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break top;
                            }
                          }
                          from = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from += wsize - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          } else if (wnext < op) {
                            from += wsize + wnext - op;
                            op -= wnext;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = 0;
                              if (wnext < len) {
                                op = wnext;
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                          } else {
                            from += wnext - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                          while (len > 2) {
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            len -= 3;
                          }
                          if (len) {
                            output[_out++] = from_source[from++];
                            if (len > 1) {
                              output[_out++] = from_source[from++];
                            }
                          }
                        } else {
                          from = _out - dist;
                          do {
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            len -= 3;
                          } while (len > 2);
                          if (len) {
                            output[_out++] = output[from++];
                            if (len > 1) {
                              output[_out++] = output[from++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                      } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js
  var require_inftrees = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
      "use strict";
      var utils = require_common();
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = [
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ];
      var lext = [
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ];
      var dbase = [
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ];
      var dext = [
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        var len = 0;
        var sym = 0;
        var min = 0, max = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill;
        var low;
        var mask;
        var next;
        var base = null;
        var base_index = 0;
        var end;
        var count = new utils.Buf16(MAXBITS + 1);
        var offs = new utils.Buf16(MAXBITS + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }
        if (root > max) {
          root = max;
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }
        if (root < min) {
          root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19;
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256;
        } else {
          base = dbase;
          extra = dext;
          end = -1;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        for (; ; ) {
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len - drop;
          fill = 1 << curr;
          min = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
      };
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js
  var require_inflate = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js"(exports) {
      "use strict";
      var utils = require_common();
      var adler32 = require_adler32();
      var crc32 = require_crc322();
      var inflate_fast = require_inffast();
      var inflate_table = require_inftrees();
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_TREES = 6;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_NEED_DICT = 2;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR = -5;
      var Z_DEFLATED = 8;
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;
      function zswap32(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      }
      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new utils.Buf16(320);
        this.work = new utils.Buf16(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }
      function inflateResetKeep(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
      }
      function inflateReset(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      }
      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      }
      function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        state = new InflateState();
        strm.state = state;
        state.window = null;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null;
        }
        return ret;
      }
      function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS);
      }
      var virgin = true;
      var lenfix;
      var distfix;
      function fixedtables(state) {
        if (virgin) {
          var sym;
          lenfix = new utils.Buf32(512);
          distfix = new utils.Buf32(32);
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      }
      function updatewindow(strm, src, end, copy) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new utils.Buf8(state.wsize);
        }
        if (copy >= state.wsize) {
          utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy) {
            dist = copy;
          }
          utils.arraySet(state.window, src, end - copy, dist, state.wnext);
          copy -= dist;
          if (copy) {
            utils.arraySet(state.window, src, end - copy, copy, 0);
            state.wnext = copy;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      }
      function inflate(strm, flush) {
        var state;
        var input, output;
        var next;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy;
        var from;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len;
        var ret;
        var hbuf = new utils.Buf8(4);
        var opts;
        var n;
        var order = (
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
        );
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave:
          for (; ; ) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                  state.check = 0;
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                state.flags = 0;
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) || /* check if zlib header allowed */
                (((hold & 255) << 8) + (hold >> 8)) % 31) {
                  strm.msg = "incorrect header check";
                  state.mode = BAD;
                  break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                  state.wbits = len;
                } else if (len > state.wbits) {
                  strm.msg = "invalid window size";
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << len;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 57344) {
                  strm.msg = "unknown header flags set";
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              /* falls through */
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  hbuf[2] = hold >>> 16 & 255;
                  hbuf[3] = hold >>> 24 & 255;
                  state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              /* falls through */
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = hold & 255;
                  state.head.os = hold >> 8;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              /* falls through */
              case EXLEN:
                if (state.flags & 1024) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA;
              /* falls through */
              case EXTRA:
                if (state.flags & 1024) {
                  copy = state.length;
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy) {
                    if (state.head) {
                      len = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Array(state.head.extra_len);
                      }
                      utils.arraySet(
                        state.head.extra,
                        input,
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        copy,
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        len
                      );
                    }
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    state.length -= copy;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              /* falls through */
              case NAME:
                if (state.flags & 2048) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.name += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              /* falls through */
              case COMMENT:
                if (state.flags & 4096) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy = 0;
                  do {
                    len = input[next + copy++];
                    if (state.head && len && state.length < 65536) {
                      state.head.comment += String.fromCharCode(len);
                    }
                  } while (len && copy < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              /* falls through */
              case HCRC:
                if (state.flags & 512) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.check & 65535)) {
                    strm.msg = "header crc mismatch";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = state.flags >> 9 & 1;
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              /* falls through */
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              /* falls through */
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              /* falls through */
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                  strm.msg = "invalid stored block lengths";
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              /* falls through */
              case COPY_:
                state.mode = COPY;
              /* falls through */
              case COPY:
                copy = state.length;
                if (copy) {
                  if (copy > have) {
                    copy = have;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  if (copy === 0) {
                    break inf_leave;
                  }
                  utils.arraySet(output, input, next, copy, put);
                  have -= copy;
                  next += copy;
                  left -= copy;
                  put += copy;
                  state.length -= copy;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = "too many length or distance symbols";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              /* falls through */
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = hold & 7;
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = { bits: state.lenbits };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid code lengths set";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              /* falls through */
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      len = state.lens[state.have - 1];
                      copy = 3 + (hold & 3);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 3 + (hold & 7);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy = 11 + (hold & 127);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy > state.nlen + state.ndist) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    while (copy--) {
                      state.lens[state.have++] = len;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = "invalid code -- missing end-of-block";
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = { bits: state.lenbits };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid literal/lengths set";
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = { bits: state.distbits };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid distances set";
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              /* falls through */
              case LEN_:
                state.mode = LEN;
              /* falls through */
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inflate_fast(strm, _out);
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              /* falls through */
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              /* falls through */
              case DIST:
                for (; ; ) {
                  here = state.distcode[hold & (1 << state.distbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
              /* falls through */
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              /* falls through */
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy = _out - left;
                if (state.offset > copy) {
                  copy = state.offset - copy;
                  if (copy > state.whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy > state.wnext) {
                    copy -= state.wnext;
                    from = state.wsize - copy;
                  } else {
                    from = state.wnext - copy;
                  }
                  if (copy > state.length) {
                    copy = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output;
                  from = put - state.offset;
                  copy = state.length;
                }
                if (copy > left) {
                  copy = left;
                }
                left -= copy;
                state.length -= copy;
                do {
                  output[put++] = from_source[from++];
                } while (--copy);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (_out) {
                    strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                    state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                  }
                  _out = left;
                  if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = "incorrect data check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              /* falls through */
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.total & 4294967295)) {
                    strm.msg = "incorrect length check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              /* falls through */
              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR;
              case SYNC:
              /* falls through */
              default:
                return Z_STREAM_ERROR;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      }
      function inflateEnd(strm) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        var state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK;
      }
      function inflateGetHeader(strm, head) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
      }
      function inflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
      }
      exports.inflateReset = inflateReset;
      exports.inflateReset2 = inflateReset2;
      exports.inflateResetKeep = inflateResetKeep;
      exports.inflateInit = inflateInit;
      exports.inflateInit2 = inflateInit2;
      exports.inflate = inflate;
      exports.inflateEnd = inflateEnd;
      exports.inflateGetHeader = inflateGetHeader;
      exports.inflateSetDictionary = inflateSetDictionary;
      exports.inflateInfo = "pako inflate (from Nodeca project)";
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js
  var require_constants = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,
        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,
        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
      };
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js
  var require_gzheader = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
      "use strict";
      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
      }
      module.exports = GZheader;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js
  var require_inflate2 = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js"(exports) {
      "use strict";
      var zlib_inflate = require_inflate();
      var utils = require_common();
      var strings = require_strings();
      var c = require_constants();
      var msg = require_messages();
      var ZStream = require_zstream();
      var GZheader = require_gzheader();
      var toString = Object.prototype.toString;
      function Inflate(options) {
        if (!(this instanceof Inflate)) return new Inflate(options);
        this.options = utils.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15;
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_inflate.inflateInit2(
          this.strm,
          opt.windowBits
        );
        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
        this.header = new GZheader();
        zlib_inflate.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
          if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
          }
          if (opt.raw) {
            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== c.Z_OK) {
              throw new Error(msg[status]);
            }
          }
        }
      }
      Inflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var dictionary = this.options.dictionary;
        var status, _mode;
        var next_out_utf8, tail, utf8str;
        var allowBufError = false;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.binstring2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
          if (status === c.Z_NEED_DICT && dictionary) {
            status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
          }
          if (status === c.Z_BUF_ERROR && allowBufError === true) {
            status = c.Z_OK;
            allowBufError = false;
          }
          if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                tail = strm.next_out - next_out_utf8;
                utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail) {
                  utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                }
                this.onData(utf8str);
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          }
          if (strm.avail_in === 0 && strm.avail_out === 0) {
            allowBufError = true;
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
        if (status === c.Z_STREAM_END) {
          _mode = c.Z_FINISH;
        }
        if (_mode === c.Z_FINISH) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === c.Z_OK;
        }
        if (_mode === c.Z_SYNC_FLUSH) {
          this.onEnd(c.Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === c.Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function inflate(input, options) {
        var inflator = new Inflate(options);
        inflator.push(input, true);
        if (inflator.err) {
          throw inflator.msg || msg[inflator.err];
        }
        return inflator.result;
      }
      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
      }
      exports.Inflate = Inflate;
      exports.inflate = inflate;
      exports.inflateRaw = inflateRaw;
      exports.ungzip = inflate;
    }
  });

  // node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js
  var require_pako = __commonJS({
    "node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js"(exports, module) {
      "use strict";
      var assign = require_common().assign;
      var deflate = require_deflate2();
      var inflate = require_inflate2();
      var constants = require_constants();
      var pako = {};
      assign(pako, deflate, inflate, constants);
      module.exports = pako;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/flate.js
  var require_flate = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/flate.js"(exports) {
      "use strict";
      var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
      var pako = require_pako();
      var utils = require_utils();
      var GenericWorker = require_GenericWorker();
      var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
      exports.magic = "\b\0";
      function FlateWorker(action, options) {
        GenericWorker.call(this, "FlateWorker/" + action);
        this._pako = null;
        this._pakoAction = action;
        this._pakoOptions = options;
        this.meta = {};
      }
      utils.inherits(FlateWorker, GenericWorker);
      FlateWorker.prototype.processChunk = function(chunk) {
        this.meta = chunk.meta;
        if (this._pako === null) {
          this._createPako();
        }
        this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
      };
      FlateWorker.prototype.flush = function() {
        GenericWorker.prototype.flush.call(this);
        if (this._pako === null) {
          this._createPako();
        }
        this._pako.push([], true);
      };
      FlateWorker.prototype.cleanUp = function() {
        GenericWorker.prototype.cleanUp.call(this);
        this._pako = null;
      };
      FlateWorker.prototype._createPako = function() {
        this._pako = new pako[this._pakoAction]({
          raw: true,
          level: this._pakoOptions.level || -1
          // default compression
        });
        var self2 = this;
        this._pako.onData = function(data) {
          self2.push({
            data,
            meta: self2.meta
          });
        };
      };
      exports.compressWorker = function(compressionOptions) {
        return new FlateWorker("Deflate", compressionOptions);
      };
      exports.uncompressWorker = function() {
        return new FlateWorker("Inflate", {});
      };
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/compressions.js
  var require_compressions = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/compressions.js"(exports) {
      "use strict";
      var GenericWorker = require_GenericWorker();
      exports.STORE = {
        magic: "\0\0",
        compressWorker: function() {
          return new GenericWorker("STORE compression");
        },
        uncompressWorker: function() {
          return new GenericWorker("STORE decompression");
        }
      };
      exports.DEFLATE = require_flate();
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/signature.js
  var require_signature = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/signature.js"(exports) {
      "use strict";
      exports.LOCAL_FILE_HEADER = "PK";
      exports.CENTRAL_FILE_HEADER = "PK";
      exports.CENTRAL_DIRECTORY_END = "PK";
      exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
      exports.ZIP64_CENTRAL_DIRECTORY_END = "PK";
      exports.DATA_DESCRIPTOR = "PK\x07\b";
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/generate/ZipFileWorker.js
  var require_ZipFileWorker = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/generate/ZipFileWorker.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var GenericWorker = require_GenericWorker();
      var utf8 = require_utf8();
      var crc32 = require_crc32();
      var signature = require_signature();
      var decToHex = function(dec, bytes) {
        var hex = "", i;
        for (i = 0; i < bytes; i++) {
          hex += String.fromCharCode(dec & 255);
          dec = dec >>> 8;
        }
        return hex;
      };
      var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
        var result = unixPermissions;
        if (!unixPermissions) {
          result = isDir ? 16893 : 33204;
        }
        return (result & 65535) << 16;
      };
      var generateDosExternalFileAttr = function(dosPermissions) {
        return (dosPermissions || 0) & 63;
      };
      var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
        var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
        var dataInfo = {
          crc32: 0,
          compressedSize: 0,
          uncompressedSize: 0
        };
        if (!streamedContent || streamingEnded) {
          dataInfo.crc32 = streamInfo["crc32"];
          dataInfo.compressedSize = streamInfo["compressedSize"];
          dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
        }
        var bitflag = 0;
        if (streamedContent) {
          bitflag |= 8;
        }
        if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
          bitflag |= 2048;
        }
        var extFileAttr = 0;
        var versionMadeBy = 0;
        if (dir) {
          extFileAttr |= 16;
        }
        if (platform === "UNIX") {
          versionMadeBy = 798;
          extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
        } else {
          versionMadeBy = 20;
          extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
        }
        dosTime = date.getUTCHours();
        dosTime = dosTime << 6;
        dosTime = dosTime | date.getUTCMinutes();
        dosTime = dosTime << 5;
        dosTime = dosTime | date.getUTCSeconds() / 2;
        dosDate = date.getUTCFullYear() - 1980;
        dosDate = dosDate << 4;
        dosDate = dosDate | date.getUTCMonth() + 1;
        dosDate = dosDate << 5;
        dosDate = dosDate | date.getUTCDate();
        if (useUTF8ForFileName) {
          unicodePathExtraField = // Version
          decToHex(1, 1) + // NameCRC32
          decToHex(crc32(encodedFileName), 4) + // UnicodeName
          utfEncodedFileName;
          extraFields += // Info-ZIP Unicode Path Extra Field
          "up" + // size
          decToHex(unicodePathExtraField.length, 2) + // content
          unicodePathExtraField;
        }
        if (useUTF8ForComment) {
          unicodeCommentExtraField = // Version
          decToHex(1, 1) + // CommentCRC32
          decToHex(crc32(encodedComment), 4) + // UnicodeName
          utfEncodedComment;
          extraFields += // Info-ZIP Unicode Path Extra Field
          "uc" + // size
          decToHex(unicodeCommentExtraField.length, 2) + // content
          unicodeCommentExtraField;
        }
        var header = "";
        header += "\n\0";
        header += decToHex(bitflag, 2);
        header += compression.magic;
        header += decToHex(dosTime, 2);
        header += decToHex(dosDate, 2);
        header += decToHex(dataInfo.crc32, 4);
        header += decToHex(dataInfo.compressedSize, 4);
        header += decToHex(dataInfo.uncompressedSize, 4);
        header += decToHex(encodedFileName.length, 2);
        header += decToHex(extraFields.length, 2);
        var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
        var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
        decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
        header + // file comment length
        decToHex(encodedComment.length, 2) + // disk number start
        "\0\0\0\0" + // external file attributes
        decToHex(extFileAttr, 4) + // relative offset of local header
        decToHex(offset, 4) + // file name
        encodedFileName + // extra field
        extraFields + // file comment
        encodedComment;
        return {
          fileRecord,
          dirRecord
        };
      };
      var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
        var dirEnd = "";
        var encodedComment = utils.transformTo("string", encodeFileName(comment));
        dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
        "\0\0\0\0" + // total number of entries in the central directory on this disk
        decToHex(entriesCount, 2) + // total number of entries in the central directory
        decToHex(entriesCount, 2) + // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) + // .ZIP file comment length
        decToHex(encodedComment.length, 2) + // .ZIP file comment
        encodedComment;
        return dirEnd;
      };
      var generateDataDescriptors = function(streamInfo) {
        var descriptor = "";
        descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
        decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
        decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
        decToHex(streamInfo["uncompressedSize"], 4);
        return descriptor;
      };
      function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
        GenericWorker.call(this, "ZipFileWorker");
        this.bytesWritten = 0;
        this.zipComment = comment;
        this.zipPlatform = platform;
        this.encodeFileName = encodeFileName;
        this.streamFiles = streamFiles;
        this.accumulate = false;
        this.contentBuffer = [];
        this.dirRecords = [];
        this.currentSourceOffset = 0;
        this.entriesCount = 0;
        this.currentFile = null;
        this._sources = [];
      }
      utils.inherits(ZipFileWorker, GenericWorker);
      ZipFileWorker.prototype.push = function(chunk) {
        var currentFilePercent = chunk.meta.percent || 0;
        var entriesCount = this.entriesCount;
        var remainingFiles = this._sources.length;
        if (this.accumulate) {
          this.contentBuffer.push(chunk);
        } else {
          this.bytesWritten += chunk.data.length;
          GenericWorker.prototype.push.call(this, {
            data: chunk.data,
            meta: {
              currentFile: this.currentFile,
              percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
          });
        }
      };
      ZipFileWorker.prototype.openedSource = function(streamInfo) {
        this.currentSourceOffset = this.bytesWritten;
        this.currentFile = streamInfo["file"].name;
        var streamedContent = this.streamFiles && !streamInfo["file"].dir;
        if (streamedContent) {
          var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({
            data: record.fileRecord,
            meta: { percent: 0 }
          });
        } else {
          this.accumulate = true;
        }
      };
      ZipFileWorker.prototype.closedSource = function(streamInfo) {
        this.accumulate = false;
        var streamedContent = this.streamFiles && !streamInfo["file"].dir;
        var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.dirRecords.push(record.dirRecord);
        if (streamedContent) {
          this.push({
            data: generateDataDescriptors(streamInfo),
            meta: { percent: 100 }
          });
        } else {
          this.push({
            data: record.fileRecord,
            meta: { percent: 0 }
          });
          while (this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
          }
        }
        this.currentFile = null;
      };
      ZipFileWorker.prototype.flush = function() {
        var localDirLength = this.bytesWritten;
        for (var i = 0; i < this.dirRecords.length; i++) {
          this.push({
            data: this.dirRecords[i],
            meta: { percent: 100 }
          });
        }
        var centralDirLength = this.bytesWritten - localDirLength;
        var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
        this.push({
          data: dirEnd,
          meta: { percent: 100 }
        });
      };
      ZipFileWorker.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift();
        this.openedSource(this.previous.streamInfo);
        if (this.isPaused) {
          this.previous.pause();
        } else {
          this.previous.resume();
        }
      };
      ZipFileWorker.prototype.registerPrevious = function(previous) {
        this._sources.push(previous);
        var self2 = this;
        previous.on("data", function(chunk) {
          self2.processChunk(chunk);
        });
        previous.on("end", function() {
          self2.closedSource(self2.previous.streamInfo);
          if (self2._sources.length) {
            self2.prepareNextSource();
          } else {
            self2.end();
          }
        });
        previous.on("error", function(e) {
          self2.error(e);
        });
        return this;
      };
      ZipFileWorker.prototype.resume = function() {
        if (!GenericWorker.prototype.resume.call(this)) {
          return false;
        }
        if (!this.previous && this._sources.length) {
          this.prepareNextSource();
          return true;
        }
        if (!this.previous && !this._sources.length && !this.generatedError) {
          this.end();
          return true;
        }
      };
      ZipFileWorker.prototype.error = function(e) {
        var sources = this._sources;
        if (!GenericWorker.prototype.error.call(this, e)) {
          return false;
        }
        for (var i = 0; i < sources.length; i++) {
          try {
            sources[i].error(e);
          } catch (e2) {
          }
        }
        return true;
      };
      ZipFileWorker.prototype.lock = function() {
        GenericWorker.prototype.lock.call(this);
        var sources = this._sources;
        for (var i = 0; i < sources.length; i++) {
          sources[i].lock();
        }
      };
      module.exports = ZipFileWorker;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/generate/index.js
  var require_generate = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/generate/index.js"(exports) {
      "use strict";
      var compressions = require_compressions();
      var ZipFileWorker = require_ZipFileWorker();
      var getCompression = function(fileCompression, zipCompression) {
        var compressionName = fileCompression || zipCompression;
        var compression = compressions[compressionName];
        if (!compression) {
          throw new Error(compressionName + " is not a valid compression method !");
        }
        return compression;
      };
      exports.generateWorker = function(zip, options, comment) {
        var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
        var entriesCount = 0;
        try {
          zip.forEach(function(relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir, date = file.date;
            file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
              name: relativePath,
              dir,
              date,
              comment: file.comment || "",
              unixPermissions: file.unixPermissions,
              dosPermissions: file.dosPermissions
            }).pipe(zipFileWorker);
          });
          zipFileWorker.entriesCount = entriesCount;
        } catch (e) {
          zipFileWorker.error(e);
        }
        return zipFileWorker;
      };
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
  var require_NodejsStreamInputAdapter = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var GenericWorker = require_GenericWorker();
      function NodejsStreamInputAdapter(filename, stream) {
        GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
        this._upstreamEnded = false;
        this._bindStream(stream);
      }
      utils.inherits(NodejsStreamInputAdapter, GenericWorker);
      NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
        var self2 = this;
        this._stream = stream;
        stream.pause();
        stream.on("data", function(chunk) {
          self2.push({
            data: chunk,
            meta: {
              percent: 0
            }
          });
        }).on("error", function(e) {
          if (self2.isPaused) {
            this.generatedError = e;
          } else {
            self2.error(e);
          }
        }).on("end", function() {
          if (self2.isPaused) {
            self2._upstreamEnded = true;
          } else {
            self2.end();
          }
        });
      };
      NodejsStreamInputAdapter.prototype.pause = function() {
        if (!GenericWorker.prototype.pause.call(this)) {
          return false;
        }
        this._stream.pause();
        return true;
      };
      NodejsStreamInputAdapter.prototype.resume = function() {
        if (!GenericWorker.prototype.resume.call(this)) {
          return false;
        }
        if (this._upstreamEnded) {
          this.end();
        } else {
          this._stream.resume();
        }
        return true;
      };
      module.exports = NodejsStreamInputAdapter;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/object.js
  var require_object = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/object.js"(exports, module) {
      "use strict";
      var utf8 = require_utf8();
      var utils = require_utils();
      var GenericWorker = require_GenericWorker();
      var StreamHelper = require_StreamHelper();
      var defaults = require_defaults();
      var CompressedObject = require_compressedObject();
      var ZipObject = require_zipObject();
      var generate = require_generate();
      var nodejsUtils = require_nodejsUtils();
      var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
      var fileAdd = function(name, data, originalOptions) {
        var dataType = utils.getTypeOf(data), parent;
        var o = utils.extend(originalOptions || {}, defaults);
        o.date = o.date || /* @__PURE__ */ new Date();
        if (o.compression !== null) {
          o.compression = o.compression.toUpperCase();
        }
        if (typeof o.unixPermissions === "string") {
          o.unixPermissions = parseInt(o.unixPermissions, 8);
        }
        if (o.unixPermissions && o.unixPermissions & 16384) {
          o.dir = true;
        }
        if (o.dosPermissions && o.dosPermissions & 16) {
          o.dir = true;
        }
        if (o.dir) {
          name = forceTrailingSlash(name);
        }
        if (o.createFolders && (parent = parentFolder(name))) {
          folderAdd.call(this, parent, true);
        }
        var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
        if (!originalOptions || typeof originalOptions.binary === "undefined") {
          o.binary = !isUnicodeString;
        }
        var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
        if (isCompressedEmpty || o.dir || !data || data.length === 0) {
          o.base64 = false;
          o.binary = true;
          data = "";
          o.compression = "STORE";
          dataType = "string";
        }
        var zipObjectContent = null;
        if (data instanceof CompressedObject || data instanceof GenericWorker) {
          zipObjectContent = data;
        } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
          zipObjectContent = new NodejsStreamInputAdapter(name, data);
        } else {
          zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
        }
        var object = new ZipObject(name, zipObjectContent, o);
        this.files[name] = object;
      };
      var parentFolder = function(path) {
        if (path.slice(-1) === "/") {
          path = path.substring(0, path.length - 1);
        }
        var lastSlash = path.lastIndexOf("/");
        return lastSlash > 0 ? path.substring(0, lastSlash) : "";
      };
      var forceTrailingSlash = function(path) {
        if (path.slice(-1) !== "/") {
          path += "/";
        }
        return path;
      };
      var folderAdd = function(name, createFolders) {
        createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
        name = forceTrailingSlash(name);
        if (!this.files[name]) {
          fileAdd.call(this, name, null, {
            dir: true,
            createFolders
          });
        }
        return this.files[name];
      };
      function isRegExp(object) {
        return Object.prototype.toString.call(object) === "[object RegExp]";
      }
      var out = {
        /**
         * @see loadAsync
         */
        load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
         * Call a callback function for each entry at this folder level.
         * @param {Function} cb the callback function:
         * function (relativePath, file) {...}
         * It takes 2 arguments : the relative path and the file.
         */
        forEach: function(cb) {
          var filename, relativePath, file;
          for (filename in this.files) {
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) {
              cb(relativePath, file);
            }
          }
        },
        /**
         * Filter nested files/folders with the specified function.
         * @param {Function} search the predicate to use :
         * function (relativePath, file) {...}
         * It takes 2 arguments : the relative path and the file.
         * @return {Array} An array of matching elements.
         */
        filter: function(search) {
          var result = [];
          this.forEach(function(relativePath, entry) {
            if (search(relativePath, entry)) {
              result.push(entry);
            }
          });
          return result;
        },
        /**
         * Add a file to the zip file, or search a file.
         * @param   {string|RegExp} name The name of the file to add (if data is defined),
         * the name of the file to find (if no data) or a regex to match files.
         * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
         * @param   {Object} o     File options
         * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
         * a file (when searching by string) or an array of files (when searching by regex).
         */
        file: function(name, data, o) {
          if (arguments.length === 1) {
            if (isRegExp(name)) {
              var regexp = name;
              return this.filter(function(relativePath, file) {
                return !file.dir && regexp.test(relativePath);
              });
            } else {
              var obj = this.files[this.root + name];
              if (obj && !obj.dir) {
                return obj;
              } else {
                return null;
              }
            }
          } else {
            name = this.root + name;
            fileAdd.call(this, name, data, o);
          }
          return this;
        },
        /**
         * Add a directory to the zip file, or search.
         * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
         * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
         */
        folder: function(arg) {
          if (!arg) {
            return this;
          }
          if (isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
              return file.dir && arg.test(relativePath);
            });
          }
          var name = this.root + arg;
          var newFolder = folderAdd.call(this, name);
          var ret = this.clone();
          ret.root = newFolder.name;
          return ret;
        },
        /**
         * Delete a file, or a directory and all sub-files, from the zip
         * @param {string} name the name of the file to delete
         * @return {JSZip} this JSZip object
         */
        remove: function(name) {
          name = this.root + name;
          var file = this.files[name];
          if (!file) {
            if (name.slice(-1) !== "/") {
              name += "/";
            }
            file = this.files[name];
          }
          if (file && !file.dir) {
            delete this.files[name];
          } else {
            var kids = this.filter(function(relativePath, file2) {
              return file2.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
              delete this.files[kids[i].name];
            }
          }
          return this;
        },
        /**
         * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
         */
        generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
         * Generate the complete zip file as an internal stream.
         * @param {Object} options the options to generate the zip file :
         * - compression, "STORE" by default.
         * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
         * @return {StreamHelper} the streamed zip file.
         */
        generateInternalStream: function(options) {
          var worker, opts = {};
          try {
            opts = utils.extend(options || {}, {
              streamFiles: false,
              compression: "STORE",
              compressionOptions: null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: "application/zip",
              encodeFileName: utf8.utf8encode
            });
            opts.type = opts.type.toLowerCase();
            opts.compression = opts.compression.toUpperCase();
            if (opts.type === "binarystring") {
              opts.type = "string";
            }
            if (!opts.type) {
              throw new Error("No output type specified.");
            }
            utils.checkSupport(opts.type);
            if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
              opts.platform = "UNIX";
            }
            if (opts.platform === "win32") {
              opts.platform = "DOS";
            }
            var comment = opts.comment || this.comment || "";
            worker = generate.generateWorker(this, opts, comment);
          } catch (e) {
            worker = new GenericWorker("error");
            worker.error(e);
          }
          return new StreamHelper(worker, opts.type || "string", opts.mimeType);
        },
        /**
         * Generate the complete zip file asynchronously.
         * @see generateInternalStream
         */
        generateAsync: function(options, onUpdate) {
          return this.generateInternalStream(options).accumulate(onUpdate);
        },
        /**
         * Generate the complete zip file asynchronously.
         * @see generateInternalStream
         */
        generateNodeStream: function(options, onUpdate) {
          options = options || {};
          if (!options.type) {
            options.type = "nodebuffer";
          }
          return this.generateInternalStream(options).toNodejsStream(onUpdate);
        }
      };
      module.exports = out;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/DataReader.js
  var require_DataReader = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/DataReader.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      function DataReader(data) {
        this.data = data;
        this.length = data.length;
        this.index = 0;
        this.zero = 0;
      }
      DataReader.prototype = {
        /**
         * Check that the offset will not go too far.
         * @param {string} offset the additional offset to check.
         * @throws {Error} an Error if the offset is out of bounds.
         */
        checkOffset: function(offset) {
          this.checkIndex(this.index + offset);
        },
        /**
         * Check that the specified index will not be too far.
         * @param {string} newIndex the index to check.
         * @throws {Error} an Error if the index is out of bounds.
         */
        checkIndex: function(newIndex) {
          if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
          }
        },
        /**
         * Change the index.
         * @param {number} newIndex The new index.
         * @throws {Error} if the new index is out of the data.
         */
        setIndex: function(newIndex) {
          this.checkIndex(newIndex);
          this.index = newIndex;
        },
        /**
         * Skip the next n bytes.
         * @param {number} n the number of bytes to skip.
         * @throws {Error} if the new index is out of the data.
         */
        skip: function(n) {
          this.setIndex(this.index + n);
        },
        /**
         * Get the byte at the specified index.
         * @param {number} i the index to use.
         * @return {number} a byte.
         */
        byteAt: function() {
        },
        /**
         * Get the next number with a given byte size.
         * @param {number} size the number of bytes to read.
         * @return {number} the corresponding number.
         */
        readInt: function(size) {
          var result = 0, i;
          this.checkOffset(size);
          for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
          }
          this.index += size;
          return result;
        },
        /**
         * Get the next string with a given byte size.
         * @param {number} size the number of bytes to read.
         * @return {string} the corresponding string.
         */
        readString: function(size) {
          return utils.transformTo("string", this.readData(size));
        },
        /**
         * Get raw data without conversion, <size> bytes.
         * @param {number} size the number of bytes to read.
         * @return {Object} the raw data, implementation specific.
         */
        readData: function() {
        },
        /**
         * Find the last occurrence of a zip signature (4 bytes).
         * @param {string} sig the signature to find.
         * @return {number} the index of the last occurrence, -1 if not found.
         */
        lastIndexOfSignature: function() {
        },
        /**
         * Read the signature (4 bytes) at the current position and compare it with sig.
         * @param {string} sig the expected signature
         * @return {boolean} true if the signature matches, false otherwise.
         */
        readAndCheckSignature: function() {
        },
        /**
         * Get the next date.
         * @return {Date} the date.
         */
        readDate: function() {
          var dostime = this.readInt(4);
          return new Date(Date.UTC(
            (dostime >> 25 & 127) + 1980,
            // year
            (dostime >> 21 & 15) - 1,
            // month
            dostime >> 16 & 31,
            // day
            dostime >> 11 & 31,
            // hour
            dostime >> 5 & 63,
            // minute
            (dostime & 31) << 1
          ));
        }
      };
      module.exports = DataReader;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/ArrayReader.js
  var require_ArrayReader = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/ArrayReader.js"(exports, module) {
      "use strict";
      var DataReader = require_DataReader();
      var utils = require_utils();
      function ArrayReader(data) {
        DataReader.call(this, data);
        for (var i = 0; i < this.data.length; i++) {
          data[i] = data[i] & 255;
        }
      }
      utils.inherits(ArrayReader, DataReader);
      ArrayReader.prototype.byteAt = function(i) {
        return this.data[this.zero + i];
      };
      ArrayReader.prototype.lastIndexOfSignature = function(sig) {
        var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
        for (var i = this.length - 4; i >= 0; --i) {
          if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
          }
        }
        return -1;
      };
      ArrayReader.prototype.readAndCheckSignature = function(sig) {
        var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
        return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
      };
      ArrayReader.prototype.readData = function(size) {
        this.checkOffset(size);
        if (size === 0) {
          return [];
        }
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module.exports = ArrayReader;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/StringReader.js
  var require_StringReader = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/StringReader.js"(exports, module) {
      "use strict";
      var DataReader = require_DataReader();
      var utils = require_utils();
      function StringReader(data) {
        DataReader.call(this, data);
      }
      utils.inherits(StringReader, DataReader);
      StringReader.prototype.byteAt = function(i) {
        return this.data.charCodeAt(this.zero + i);
      };
      StringReader.prototype.lastIndexOfSignature = function(sig) {
        return this.data.lastIndexOf(sig) - this.zero;
      };
      StringReader.prototype.readAndCheckSignature = function(sig) {
        var data = this.readData(4);
        return sig === data;
      };
      StringReader.prototype.readData = function(size) {
        this.checkOffset(size);
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module.exports = StringReader;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/Uint8ArrayReader.js
  var require_Uint8ArrayReader = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/Uint8ArrayReader.js"(exports, module) {
      "use strict";
      var ArrayReader = require_ArrayReader();
      var utils = require_utils();
      function Uint8ArrayReader(data) {
        ArrayReader.call(this, data);
      }
      utils.inherits(Uint8ArrayReader, ArrayReader);
      Uint8ArrayReader.prototype.readData = function(size) {
        this.checkOffset(size);
        if (size === 0) {
          return new Uint8Array(0);
        }
        var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module.exports = Uint8ArrayReader;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/NodeBufferReader.js
  var require_NodeBufferReader = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/NodeBufferReader.js"(exports, module) {
      "use strict";
      var Uint8ArrayReader = require_Uint8ArrayReader();
      var utils = require_utils();
      function NodeBufferReader(data) {
        Uint8ArrayReader.call(this, data);
      }
      utils.inherits(NodeBufferReader, Uint8ArrayReader);
      NodeBufferReader.prototype.readData = function(size) {
        this.checkOffset(size);
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module.exports = NodeBufferReader;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/readerFor.js
  var require_readerFor = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/reader/readerFor.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var support = require_support();
      var ArrayReader = require_ArrayReader();
      var StringReader = require_StringReader();
      var NodeBufferReader = require_NodeBufferReader();
      var Uint8ArrayReader = require_Uint8ArrayReader();
      module.exports = function(data) {
        var type = utils.getTypeOf(data);
        utils.checkSupport(type);
        if (type === "string" && !support.uint8array) {
          return new StringReader(data);
        }
        if (type === "nodebuffer") {
          return new NodeBufferReader(data);
        }
        if (support.uint8array) {
          return new Uint8ArrayReader(utils.transformTo("uint8array", data));
        }
        return new ArrayReader(utils.transformTo("array", data));
      };
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/zipEntry.js
  var require_zipEntry = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/zipEntry.js"(exports, module) {
      "use strict";
      var readerFor = require_readerFor();
      var utils = require_utils();
      var CompressedObject = require_compressedObject();
      var crc32fn = require_crc32();
      var utf8 = require_utf8();
      var compressions = require_compressions();
      var support = require_support();
      var MADE_BY_DOS = 0;
      var MADE_BY_UNIX = 3;
      var findCompression = function(compressionMethod) {
        for (var method in compressions) {
          if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
            continue;
          }
          if (compressions[method].magic === compressionMethod) {
            return compressions[method];
          }
        }
        return null;
      };
      function ZipEntry(options, loadOptions) {
        this.options = options;
        this.loadOptions = loadOptions;
      }
      ZipEntry.prototype = {
        /**
         * say if the file is encrypted.
         * @return {boolean} true if the file is encrypted, false otherwise.
         */
        isEncrypted: function() {
          return (this.bitFlag & 1) === 1;
        },
        /**
         * say if the file has utf-8 filename/comment.
         * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
         */
        useUTF8: function() {
          return (this.bitFlag & 2048) === 2048;
        },
        /**
         * Read the local part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readLocalPart: function(reader) {
          var compression, localExtraFieldsLength;
          reader.skip(22);
          this.fileNameLength = reader.readInt(2);
          localExtraFieldsLength = reader.readInt(2);
          this.fileName = reader.readData(this.fileNameLength);
          reader.skip(localExtraFieldsLength);
          if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          }
          compression = findCompression(this.compressionMethod);
          if (compression === null) {
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
          }
          this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
        },
        /**
         * Read the central part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readCentralPart: function(reader) {
          this.versionMadeBy = reader.readInt(2);
          reader.skip(2);
          this.bitFlag = reader.readInt(2);
          this.compressionMethod = reader.readString(2);
          this.date = reader.readDate();
          this.crc32 = reader.readInt(4);
          this.compressedSize = reader.readInt(4);
          this.uncompressedSize = reader.readInt(4);
          var fileNameLength = reader.readInt(2);
          this.extraFieldsLength = reader.readInt(2);
          this.fileCommentLength = reader.readInt(2);
          this.diskNumberStart = reader.readInt(2);
          this.internalFileAttributes = reader.readInt(2);
          this.externalFileAttributes = reader.readInt(4);
          this.localHeaderOffset = reader.readInt(4);
          if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
          }
          reader.skip(fileNameLength);
          this.readExtraFields(reader);
          this.parseZIP64ExtraField(reader);
          this.fileComment = reader.readData(this.fileCommentLength);
        },
        /**
         * Parse the external file attributes and get the unix/dos permissions.
         */
        processAttributes: function() {
          this.unixPermissions = null;
          this.dosPermissions = null;
          var madeBy = this.versionMadeBy >> 8;
          this.dir = this.externalFileAttributes & 16 ? true : false;
          if (madeBy === MADE_BY_DOS) {
            this.dosPermissions = this.externalFileAttributes & 63;
          }
          if (madeBy === MADE_BY_UNIX) {
            this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
          }
          if (!this.dir && this.fileNameStr.slice(-1) === "/") {
            this.dir = true;
          }
        },
        /**
         * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
         * @param {DataReader} reader the reader to use.
         */
        parseZIP64ExtraField: function() {
          if (!this.extraFields[1]) {
            return;
          }
          var extraReader = readerFor(this.extraFields[1].value);
          if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
          }
          if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
          }
          if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
          }
          if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
          }
        },
        /**
         * Read the central part of a zip file and add the info in this object.
         * @param {DataReader} reader the reader to use.
         */
        readExtraFields: function(reader) {
          var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
          if (!this.extraFields) {
            this.extraFields = {};
          }
          while (reader.index + 4 < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);
            this.extraFields[extraFieldId] = {
              id: extraFieldId,
              length: extraFieldLength,
              value: extraFieldValue
            };
          }
          reader.setIndex(end);
        },
        /**
         * Apply an UTF8 transformation if needed.
         */
        handleUTF8: function() {
          var decodeParamType = support.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
          } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
              this.fileNameStr = upath;
            } else {
              var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }
            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
              this.fileCommentStr = ucomment;
            } else {
              var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
          }
        },
        /**
         * Find the unicode path declared in the extra field, if any.
         * @return {String} the unicode path, null otherwise.
         */
        findExtraFieldUnicodePath: function() {
          var upathField = this.extraFields[28789];
          if (upathField) {
            var extraReader = readerFor(upathField.value);
            if (extraReader.readInt(1) !== 1) {
              return null;
            }
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
              return null;
            }
            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
          }
          return null;
        },
        /**
         * Find the unicode comment declared in the extra field, if any.
         * @return {String} the unicode comment, null otherwise.
         */
        findExtraFieldUnicodeComment: function() {
          var ucommentField = this.extraFields[25461];
          if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);
            if (extraReader.readInt(1) !== 1) {
              return null;
            }
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
              return null;
            }
            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
          }
          return null;
        }
      };
      module.exports = ZipEntry;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/zipEntries.js
  var require_zipEntries = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/zipEntries.js"(exports, module) {
      "use strict";
      var readerFor = require_readerFor();
      var utils = require_utils();
      var sig = require_signature();
      var ZipEntry = require_zipEntry();
      var support = require_support();
      function ZipEntries(loadOptions) {
        this.files = [];
        this.loadOptions = loadOptions;
      }
      ZipEntries.prototype = {
        /**
         * Check that the reader is on the specified signature.
         * @param {string} expectedSignature the expected signature.
         * @throws {Error} if it is an other signature.
         */
        checkSignature: function(expectedSignature) {
          if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
          }
        },
        /**
         * Check if the given signature is at the given index.
         * @param {number} askedIndex the index to check.
         * @param {string} expectedSignature the signature to expect.
         * @return {boolean} true if the signature is here, false otherwise.
         */
        isSignature: function(askedIndex, expectedSignature) {
          var currentIndex = this.reader.index;
          this.reader.setIndex(askedIndex);
          var signature = this.reader.readString(4);
          var result = signature === expectedSignature;
          this.reader.setIndex(currentIndex);
          return result;
        },
        /**
         * Read the end of the central directory.
         */
        readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2);
          this.diskWithCentralDirStart = this.reader.readInt(2);
          this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
          this.centralDirRecords = this.reader.readInt(2);
          this.centralDirSize = this.reader.readInt(4);
          this.centralDirOffset = this.reader.readInt(4);
          this.zipCommentLength = this.reader.readInt(2);
          var zipComment = this.reader.readData(this.zipCommentLength);
          var decodeParamType = support.uint8array ? "uint8array" : "array";
          var decodeContent = utils.transformTo(decodeParamType, zipComment);
          this.zipComment = this.loadOptions.decodeFileName(decodeContent);
        },
        /**
         * Read the end of the Zip 64 central directory.
         * Not merged with the method readEndOfCentral :
         * The end of central can coexist with its Zip64 brother,
         * I don't want to read the wrong number of bytes !
         */
        readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8);
          this.reader.skip(4);
          this.diskNumber = this.reader.readInt(4);
          this.diskWithCentralDirStart = this.reader.readInt(4);
          this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
          this.centralDirRecords = this.reader.readInt(8);
          this.centralDirSize = this.reader.readInt(8);
          this.centralDirOffset = this.reader.readInt(8);
          this.zip64ExtensibleData = {};
          var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
          while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
              id: extraFieldId,
              length: extraFieldLength,
              value: extraFieldValue
            };
          }
        },
        /**
         * Read the end of the Zip 64 central directory locator.
         */
        readBlockZip64EndOfCentralLocator: function() {
          this.diskWithZip64CentralDirStart = this.reader.readInt(4);
          this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
          this.disksCount = this.reader.readInt(4);
          if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
          }
        },
        /**
         * Read the local files, based on the offset read in the central part.
         */
        readLocalFiles: function() {
          var i, file;
          for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
          }
        },
        /**
         * Read the central directory.
         */
        readCentralDir: function() {
          var file;
          this.reader.setIndex(this.centralDirOffset);
          while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
              zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
          }
          if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
              throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
            }
          }
        },
        /**
         * Read the end of central directory.
         */
        readEndOfCentral: function() {
          var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
          if (offset < 0) {
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
            if (isGarbage) {
              throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
              throw new Error("Corrupted zip: can't find end of central directory");
            }
          }
          this.reader.setIndex(offset);
          var endOfCentralDirOffset = offset;
          this.checkSignature(sig.CENTRAL_DIRECTORY_END);
          this.readBlockEndOfCentral();
          if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
              this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
              if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
              }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
          }
          var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
          if (this.zip64) {
            expectedEndOfCentralDirOffset += 20;
            expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
          }
          var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
          if (extraBytes > 0) {
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
            } else {
              this.reader.zero = extraBytes;
            }
          } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
          }
        },
        prepareReader: function(data) {
          this.reader = readerFor(data);
        },
        /**
         * Read a zip file and create ZipEntries.
         * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
         */
        load: function(data) {
          this.prepareReader(data);
          this.readEndOfCentral();
          this.readCentralDir();
          this.readLocalFiles();
        }
      };
      module.exports = ZipEntries;
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/load.js
  var require_load = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/load.js"(exports, module) {
      "use strict";
      var utils = require_utils();
      var external = require_external();
      var utf8 = require_utf8();
      var ZipEntries = require_zipEntries();
      var Crc32Probe = require_Crc32Probe();
      var nodejsUtils = require_nodejsUtils();
      function checkEntryCRC32(zipEntry) {
        return new external.Promise(function(resolve, reject) {
          var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
          worker.on("error", function(e) {
            reject(e);
          }).on("end", function() {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
              reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
              resolve();
            }
          }).resume();
        });
      }
      module.exports = function(data, options) {
        var zip = this;
        options = utils.extend(options || {}, {
          base64: false,
          checkCRC32: false,
          optimizedBinaryString: false,
          createFolders: false,
          decodeFileName: utf8.utf8decode
        });
        if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
          return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
        }
        return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
          var zipEntries = new ZipEntries(options);
          zipEntries.load(data2);
          return zipEntries;
        }).then(function checkCRC32(zipEntries) {
          var promises = [external.Promise.resolve(zipEntries)];
          var files = zipEntries.files;
          if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
              promises.push(checkEntryCRC32(files[i]));
            }
          }
          return external.Promise.all(promises);
        }).then(function addFiles(results) {
          var zipEntries = results.shift();
          var files = zipEntries.files;
          for (var i = 0; i < files.length; i++) {
            var input = files[i];
            var unsafeName = input.fileNameStr;
            var safeName = utils.resolve(input.fileNameStr);
            zip.file(safeName, input.decompressed, {
              binary: true,
              optimizedBinaryString: true,
              date: input.date,
              dir: input.dir,
              comment: input.fileCommentStr.length ? input.fileCommentStr : null,
              unixPermissions: input.unixPermissions,
              dosPermissions: input.dosPermissions,
              createFolders: options.createFolders
            });
            if (!input.dir) {
              zip.file(safeName).unsafeOriginalName = unsafeName;
            }
          }
          if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
          }
          return zip;
        });
      };
    }
  });

  // node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/.pnpm/jszip@3.10.1/node_modules/jszip/lib/index.js"(exports, module) {
      "use strict";
      function JSZip3() {
        if (!(this instanceof JSZip3)) {
          return new JSZip3();
        }
        if (arguments.length) {
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        }
        this.files = /* @__PURE__ */ Object.create(null);
        this.comment = null;
        this.root = "";
        this.clone = function() {
          var newObj = new JSZip3();
          for (var i in this) {
            if (typeof this[i] !== "function") {
              newObj[i] = this[i];
            }
          }
          return newObj;
        };
      }
      JSZip3.prototype = require_object();
      JSZip3.prototype.loadAsync = require_load();
      JSZip3.support = require_support();
      JSZip3.defaults = require_defaults();
      JSZip3.version = "3.10.1";
      JSZip3.loadAsync = function(content, options) {
        return new JSZip3().loadAsync(content, options);
      };
      JSZip3.external = require_external();
      module.exports = JSZip3;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/interfaces.js
  var require_interfaces = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/interfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultXMLBuilderCBOptions = exports.XMLBuilderOptionKeys = exports.DefaultBuilderOptions = void 0;
      exports.DefaultBuilderOptions = {
        version: "1.0",
        encoding: void 0,
        standalone: void 0,
        keepNullNodes: false,
        keepNullAttributes: false,
        ignoreConverters: false,
        skipWhitespaceOnlyText: true,
        convert: {
          att: "@",
          ins: "?",
          text: "#",
          cdata: "$",
          comment: "!"
        },
        defaultNamespace: {
          ele: void 0,
          att: void 0
        },
        namespaceAlias: {
          html: "http://www.w3.org/1999/xhtml",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/",
          mathml: "http://www.w3.org/1998/Math/MathML",
          svg: "http://www.w3.org/2000/svg",
          xlink: "http://www.w3.org/1999/xlink"
        },
        invalidCharReplacement: void 0,
        parser: void 0
      };
      exports.XMLBuilderOptionKeys = new Set(Object.keys(exports.DefaultBuilderOptions));
      exports.DefaultXMLBuilderCBOptions = {
        format: "xml",
        wellFormed: false,
        prettyPrint: false,
        indent: "  ",
        newline: "\n",
        offset: 0,
        width: 0,
        allowEmptyTags: false,
        spaceBeforeSlash: false,
        keepNullNodes: false,
        keepNullAttributes: false,
        ignoreConverters: false,
        convert: {
          att: "@",
          ins: "?",
          text: "#",
          cdata: "$",
          comment: "!"
        },
        defaultNamespace: {
          ele: void 0,
          att: void 0
        },
        namespaceAlias: {
          html: "http://www.w3.org/1999/xhtml",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/",
          mathml: "http://www.w3.org/1998/Math/MathML",
          svg: "http://www.w3.org/2000/svg",
          xlink: "http://www.w3.org/1999/xlink"
        }
      };
    }
  });

  // node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/FixedSizeSet.js
  var require_FixedSizeSet = __commonJS({
    "node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/FixedSizeSet.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FixedSizeSet = void 0;
      var FixedSizeSet = class {
        /**
         * Initializes a new instance of `FixedSizeSet`.
         *
         * @param limit - maximum number of items to keep in the set. When the limit
         * is exceeded the first item is removed from the set.
         */
        constructor(limit = 1e3) {
          __publicField(this, "_limit");
          __publicField(this, "_items", /* @__PURE__ */ new Set());
          this._limit = limit;
        }
        /**
         * Adds a new item to the set.
         *
         * @param item - an item
         */
        add(item) {
          this._items.add(item);
          if (this._items.size > this._limit) {
            const it = this._items.values().next();
            if (!it.done) {
              this._items.delete(it.value);
            }
          }
          return this;
        }
        /**
         * Removes an item from the set.
         *
         * @param item - an item
         */
        delete(item) {
          return this._items.delete(item);
        }
        /**
         * Determines if an item is in the set.
         *
         * @param item - an item
         */
        has(item) {
          return this._items.has(item);
        }
        /**
         * Removes all items from the set.
         */
        clear() {
          this._items.clear();
        }
        /**
         * Gets the number of items in the set.
         */
        get size() {
          return this._items.size;
        }
        /**
         * Applies the given callback function to all elements of the set.
         */
        forEach(callback, thisArg) {
          this._items.forEach((e) => callback.call(thisArg, e, e, this));
        }
        /**
         * Iterates through the items in the set.
         */
        *keys() {
          yield* __yieldStar(this._items.keys());
        }
        /**
         * Iterates through the items in the set.
         */
        *values() {
          yield* __yieldStar(this._items.values());
        }
        /**
         * Iterates through the items in the set.
         */
        *entries() {
          yield* __yieldStar(this._items.entries());
        }
        /**
         * Iterates through the items in the set.
         */
        *[Symbol.iterator]() {
          yield* __yieldStar(this._items);
        }
        /**
         * Returns the string tag of the set.
         */
        get [Symbol.toStringTag]() {
          return "FixedSizeSet";
        }
      };
      exports.FixedSizeSet = FixedSizeSet;
    }
  });

  // node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/ObjectCache.js
  var require_ObjectCache = __commonJS({
    "node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/ObjectCache.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ObjectCache = void 0;
      var ObjectCache = class {
        /**
         * Initializes a new instance of `ObjectCache`.
         *
         * @param limit - maximum number of items to keep in the cache. When the limit
         * is exceeded the first item is removed from the cache.
         */
        constructor(limit = 1e3) {
          __publicField(this, "_limit");
          __publicField(this, "_items", /* @__PURE__ */ new Map());
          this._limit = limit;
        }
        /**
         * Gets an item from the cache.
         *
         * @param key - object key
         */
        get(key) {
          return this._items.get(key);
        }
        /**
         * Adds a new item to the cache.
         *
         * @param key - object key
         * @param value - object value
         */
        set(key, value) {
          this._items.set(key, value);
          if (this._items.size > this._limit) {
            const it = this._items.keys().next();
            if (!it.done) {
              this._items.delete(it.value);
            }
          }
        }
        /**
         * Removes an item from the cache.
         *
         * @param item - an item
         */
        delete(key) {
          return this._items.delete(key);
        }
        /**
         * Determines if an item is in the cache.
         *
         * @param item - an item
         */
        has(key) {
          return this._items.has(key);
        }
        /**
         * Removes all items from the cache.
         */
        clear() {
          this._items.clear();
        }
        /**
         * Gets the number of items in the cache.
         */
        get size() {
          return this._items.size;
        }
        /**
         * Applies the given callback function to all elements of the cache.
         */
        forEach(callback, thisArg) {
          this._items.forEach((v, k) => callback.call(thisArg, k, v));
        }
        /**
         * Iterates through the items in the set.
         */
        *keys() {
          yield* __yieldStar(this._items.keys());
        }
        /**
         * Iterates through the items in the set.
         */
        *values() {
          yield* __yieldStar(this._items.values());
        }
        /**
         * Iterates through the items in the set.
         */
        *entries() {
          yield* __yieldStar(this._items.entries());
        }
        /**
         * Iterates through the items in the set.
         */
        *[Symbol.iterator]() {
          yield* __yieldStar(this._items);
        }
        /**
         * Returns the string tag of the cache.
         */
        get [Symbol.toStringTag]() {
          return "ObjectCache";
        }
      };
      exports.ObjectCache = ObjectCache;
    }
  });

  // node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/CompareCache.js
  var require_CompareCache = __commonJS({
    "node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/CompareCache.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CompareCache = void 0;
      var CompareCache = class {
        /**
         * Initializes a new instance of `CompareCache`.
         *
         * @param limit - maximum number of items to keep in the cache. When the limit
         * is exceeded the first item is removed from the cache.
         */
        constructor(limit = 1e3) {
          __publicField(this, "_limit");
          __publicField(this, "_items", /* @__PURE__ */ new Map());
          this._limit = limit;
        }
        /**
         * Compares and caches the given objects. Returns `true` if `objA < objB` and
         * `false` otherwise.
         *
         * @param objA - an item to compare
         * @param objB - an item to compare
         */
        check(objA, objB) {
          if (this._items.get(objA) === objB)
            return true;
          else if (this._items.get(objB) === objA)
            return false;
          const result = Math.random() < 0.5;
          if (result) {
            this._items.set(objA, objB);
          } else {
            this._items.set(objB, objA);
          }
          if (this._items.size > this._limit) {
            const it = this._items.keys().next();
            if (!it.done) {
              this._items.delete(it.value);
            }
          }
          return result;
        }
      };
      exports.CompareCache = CompareCache;
    }
  });

  // node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/Lazy.js
  var require_Lazy = __commonJS({
    "node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/Lazy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Lazy = void 0;
      var Lazy = class {
        /**
         * Initializes a new instance of `Lazy`.
         *
         * @param initFunc - initializer function
         */
        constructor(initFunc) {
          __publicField(this, "_initialized", false);
          __publicField(this, "_initFunc");
          __publicField(this, "_value");
          this._value = void 0;
          this._initFunc = initFunc;
        }
        /**
         * Gets the value of the object.
         */
        get value() {
          if (!this._initialized) {
            this._value = this._initFunc();
            this._initialized = true;
          }
          return this._value;
        }
      };
      exports.Lazy = Lazy;
    }
  });

  // node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/StringWalker.js
  var require_StringWalker = __commonJS({
    "node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/StringWalker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StringWalker = void 0;
      var StringWalker = class {
        /**
         * Initializes a new `StringWalker`.
         *
         * @param input - input string
         */
        constructor(input) {
          __publicField(this, "_chars");
          __publicField(this, "_length");
          __publicField(this, "_pointer", 0);
          __publicField(this, "_codePoint");
          __publicField(this, "_c");
          __publicField(this, "_remaining");
          __publicField(this, "_substring");
          this._chars = Array.from(input);
          this._length = this._chars.length;
        }
        /**
         * Determines if the current position is beyond the end of string.
         */
        get eof() {
          return this._pointer >= this._length;
        }
        /**
         * Returns the number of code points in the input string.
         */
        get length() {
          return this._length;
        }
        /**
         * Returns the current code point. Returns `-1` if the position is beyond
         * the end of string.
         */
        codePoint() {
          if (this._codePoint === void 0) {
            if (this.eof) {
              this._codePoint = -1;
            } else {
              const cp = this._chars[this._pointer].codePointAt(0);
              if (cp !== void 0) {
                this._codePoint = cp;
              } else {
                this._codePoint = -1;
              }
            }
          }
          return this._codePoint;
        }
        /**
         * Returns the current character. Returns an empty string if the position is
         * beyond the end of string.
         */
        c() {
          if (this._c === void 0) {
            this._c = this.eof ? "" : this._chars[this._pointer];
          }
          return this._c;
        }
        /**
         * Returns the remaining string.
         */
        remaining() {
          if (this._remaining === void 0) {
            this._remaining = this.eof ? "" : this._chars.slice(this._pointer + 1).join("");
          }
          return this._remaining;
        }
        /**
         * Returns the substring from the current character to the end of string.
         */
        substring() {
          if (this._substring === void 0) {
            this._substring = this.eof ? "" : this._chars.slice(this._pointer).join("");
          }
          return this._substring;
        }
        /**
         * Gets or sets the current position.
         */
        get pointer() {
          return this._pointer;
        }
        set pointer(val) {
          if (val === this._pointer)
            return;
          this._pointer = val;
          this._codePoint = void 0;
          this._c = void 0;
          this._remaining = void 0;
          this._substring = void 0;
        }
      };
      exports.StringWalker = StringWalker;
    }
  });

  // node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/.pnpm/@oozcitak+util@10.0.0/node_modules/@oozcitak/util/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StringWalker = exports.Lazy = exports.CompareCache = exports.ObjectCache = exports.FixedSizeSet = void 0;
      exports.applyMixin = applyMixin;
      exports.applyDefaults = applyDefaults;
      exports.forEachArray = forEachArray;
      exports.forEachObject = forEachObject;
      exports.arrayLength = arrayLength;
      exports.objectLength = objectLength;
      exports.getObjectValue = getObjectValue;
      exports.removeObjectValue = removeObjectValue;
      exports.clone = clone;
      exports.isBoolean = isBoolean;
      exports.isNumber = isNumber;
      exports.isString = isString;
      exports.isFunction = isFunction;
      exports.isObject = isObject;
      exports.isArray = isArray;
      exports.isSet = isSet;
      exports.isMap = isMap;
      exports.isEmpty = isEmpty;
      exports.isPlainObject = isPlainObject;
      exports.isIterable = isIterable;
      exports.getValue = getValue;
      exports.utf8Encode = utf8Encode;
      exports.utf8Decode = utf8Decode;
      var FixedSizeSet_js_1 = require_FixedSizeSet();
      Object.defineProperty(exports, "FixedSizeSet", { enumerable: true, get: function() {
        return FixedSizeSet_js_1.FixedSizeSet;
      } });
      var ObjectCache_js_1 = require_ObjectCache();
      Object.defineProperty(exports, "ObjectCache", { enumerable: true, get: function() {
        return ObjectCache_js_1.ObjectCache;
      } });
      var CompareCache_js_1 = require_CompareCache();
      Object.defineProperty(exports, "CompareCache", { enumerable: true, get: function() {
        return CompareCache_js_1.CompareCache;
      } });
      var Lazy_js_1 = require_Lazy();
      Object.defineProperty(exports, "Lazy", { enumerable: true, get: function() {
        return Lazy_js_1.Lazy;
      } });
      var StringWalker_js_1 = require_StringWalker();
      Object.defineProperty(exports, "StringWalker", { enumerable: true, get: function() {
        return StringWalker_js_1.StringWalker;
      } });
      function applyMixin(baseClass, mixinClass, ...overrides) {
        Object.getOwnPropertyNames(mixinClass.prototype).forEach((name) => {
          if (name !== "constructor") {
            if (overrides.indexOf(name) !== -1) {
              const orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);
              if (orgPropDesc) {
                Object.defineProperty(baseClass.prototype, "_" + name, orgPropDesc);
              }
            }
            const propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);
            if (propDesc) {
              Object.defineProperty(baseClass.prototype, name, propDesc);
            }
          }
        });
      }
      function applyDefaults(obj, defaults, overwrite = false) {
        const result = clone(obj || {});
        forEachObject(defaults, (key, val) => {
          if (isPlainObject(val)) {
            result[key] = applyDefaults(result[key], val, overwrite);
          } else if (overwrite || result[key] === void 0) {
            result[key] = val;
          }
        });
        return result;
      }
      function forEachArray(arr, callback, thisArg) {
        arr.forEach(callback, thisArg);
      }
      function forEachObject(obj, callback, thisArg) {
        if (isMap(obj)) {
          obj.forEach((value, key) => callback.call(thisArg, key, value));
        } else {
          for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
              callback.call(thisArg, key, obj[key]);
            }
          }
        }
      }
      function arrayLength(obj) {
        if (isSet(obj)) {
          return obj.size;
        } else {
          return obj.length;
        }
      }
      function objectLength(obj) {
        if (isMap(obj)) {
          return obj.size;
        } else {
          return Object.keys(obj).length;
        }
      }
      function getObjectValue(obj, key) {
        if (isMap(obj)) {
          return obj.get(key);
        } else {
          return obj[key];
        }
      }
      function removeObjectValue(obj, key) {
        if (isMap(obj)) {
          obj.delete(key);
        } else {
          delete obj[key];
        }
      }
      function clone(obj) {
        if (isFunction(obj)) {
          return obj;
        } else if (isArray(obj)) {
          const result = [];
          for (const item of obj) {
            result.push(clone(item));
          }
          return result;
        } else if (isPlainObject(obj)) {
          const result = {};
          for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
              const val = obj[key];
              result[key] = clone(val);
            }
          }
          return result;
        } else {
          return obj;
        }
      }
      function isBoolean(x) {
        return typeof x === "boolean";
      }
      function isNumber(x) {
        return typeof x === "number";
      }
      function isString(x) {
        return typeof x === "string";
      }
      function isFunction(x) {
        return !!x && typeof x === "function";
      }
      function isObject(x) {
        const type = typeof x;
        return !!x && (type === "function" || type === "object");
      }
      function isArray(x) {
        return Array.isArray(x);
      }
      function isSet(x) {
        return x instanceof Set;
      }
      function isMap(x) {
        return x instanceof Map;
      }
      function isEmpty(x) {
        if (isArray(x)) {
          return !x.length;
        } else if (isSet(x)) {
          return !x.size;
        } else if (isMap(x)) {
          return !x.size;
        } else if (isObject(x)) {
          for (const key in x) {
            if (x.hasOwnProperty(key)) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      function isPlainObject(x) {
        if (isObject(x)) {
          const proto = Object.getPrototypeOf(x);
          const ctor = proto.constructor;
          return proto && ctor && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
        }
        return false;
      }
      function isIterable(x) {
        return x && typeof x[Symbol.iterator] === "function";
      }
      function getValue(obj) {
        if (isFunction(obj.valueOf)) {
          return obj.valueOf();
        } else {
          return obj;
        }
      }
      function utf8Encode(input) {
        const bytes = new Uint8Array(input.length * 4);
        let byteIndex = 0;
        for (let i = 0; i < input.length; i++) {
          let char = input.charCodeAt(i);
          if (char < 128) {
            bytes[byteIndex++] = char;
            continue;
          } else if (char < 2048) {
            bytes[byteIndex++] = char >> 6 | 192;
          } else {
            if (char > 55295 && char < 56320) {
              if (++i >= input.length) {
                throw new Error("Incomplete surrogate pair.");
              }
              const c2 = input.charCodeAt(i);
              if (c2 < 56320 || c2 > 57343) {
                throw new Error("Invalid surrogate character.");
              }
              char = 65536 + ((char & 1023) << 10) + (c2 & 1023);
              bytes[byteIndex++] = char >> 18 | 240;
              bytes[byteIndex++] = char >> 12 & 63 | 128;
            } else {
              bytes[byteIndex++] = char >> 12 | 224;
            }
            bytes[byteIndex++] = char >> 6 & 63 | 128;
          }
          bytes[byteIndex++] = char & 63 | 128;
        }
        return bytes.subarray(0, byteIndex);
      }
      function utf8Decode(bytes) {
        let result = "";
        let i = 0;
        while (i < bytes.length) {
          var c = bytes[i++];
          if (c > 127) {
            if (c > 191 && c < 224) {
              if (i >= bytes.length) {
                throw new Error("Incomplete 2-byte sequence.");
              }
              c = (c & 31) << 6 | bytes[i++] & 63;
            } else if (c > 223 && c < 240) {
              if (i + 1 >= bytes.length) {
                throw new Error("Incomplete 3-byte sequence.");
              }
              c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
            } else if (c > 239 && c < 248) {
              if (i + 2 >= bytes.length) {
                throw new Error("Incomplete 4-byte sequence.");
              }
              c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
            } else {
              throw new Error("Unknown multi-byte start.");
            }
          }
          if (c <= 65535) {
            result += String.fromCharCode(c);
          } else if (c <= 1114111) {
            c -= 65536;
            result += String.fromCharCode(c >> 10 | 55296);
            result += String.fromCharCode(c & 1023 | 56320);
          } else {
            throw new Error("Code point exceeds UTF-16 limit.");
          }
        }
        return result;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/interfaces.js
  var require_interfaces2 = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/interfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HowToCompare = exports.WhatToShow = exports.FilterResult = exports.Position = exports.NodeType = exports.EventPhase = exports.BoundaryPosition = void 0;
      var BoundaryPosition;
      (function(BoundaryPosition2) {
        BoundaryPosition2[BoundaryPosition2["Before"] = 0] = "Before";
        BoundaryPosition2[BoundaryPosition2["Equal"] = 1] = "Equal";
        BoundaryPosition2[BoundaryPosition2["After"] = 2] = "After";
      })(BoundaryPosition || (exports.BoundaryPosition = BoundaryPosition = {}));
      var EventPhase;
      (function(EventPhase2) {
        EventPhase2[EventPhase2["None"] = 0] = "None";
        EventPhase2[EventPhase2["Capturing"] = 1] = "Capturing";
        EventPhase2[EventPhase2["AtTarget"] = 2] = "AtTarget";
        EventPhase2[EventPhase2["Bubbling"] = 3] = "Bubbling";
      })(EventPhase || (exports.EventPhase = EventPhase = {}));
      var NodeType;
      (function(NodeType2) {
        NodeType2[NodeType2["Element"] = 1] = "Element";
        NodeType2[NodeType2["Attribute"] = 2] = "Attribute";
        NodeType2[NodeType2["Text"] = 3] = "Text";
        NodeType2[NodeType2["CData"] = 4] = "CData";
        NodeType2[NodeType2["EntityReference"] = 5] = "EntityReference";
        NodeType2[NodeType2["Entity"] = 6] = "Entity";
        NodeType2[NodeType2["ProcessingInstruction"] = 7] = "ProcessingInstruction";
        NodeType2[NodeType2["Comment"] = 8] = "Comment";
        NodeType2[NodeType2["Document"] = 9] = "Document";
        NodeType2[NodeType2["DocumentType"] = 10] = "DocumentType";
        NodeType2[NodeType2["DocumentFragment"] = 11] = "DocumentFragment";
        NodeType2[NodeType2["Notation"] = 12] = "Notation";
      })(NodeType || (exports.NodeType = NodeType = {}));
      var Position;
      (function(Position2) {
        Position2[Position2["SameNode"] = 0] = "SameNode";
        Position2[Position2["Disconnected"] = 1] = "Disconnected";
        Position2[Position2["Preceding"] = 2] = "Preceding";
        Position2[Position2["Following"] = 4] = "Following";
        Position2[Position2["Contains"] = 8] = "Contains";
        Position2[Position2["ContainedBy"] = 16] = "ContainedBy";
        Position2[Position2["ImplementationSpecific"] = 32] = "ImplementationSpecific";
      })(Position || (exports.Position = Position = {}));
      var FilterResult;
      (function(FilterResult2) {
        FilterResult2[FilterResult2["Accept"] = 1] = "Accept";
        FilterResult2[FilterResult2["Reject"] = 2] = "Reject";
        FilterResult2[FilterResult2["Skip"] = 3] = "Skip";
      })(FilterResult || (exports.FilterResult = FilterResult = {}));
      var WhatToShow;
      (function(WhatToShow2) {
        WhatToShow2[WhatToShow2["All"] = 4294967295] = "All";
        WhatToShow2[WhatToShow2["Element"] = 1] = "Element";
        WhatToShow2[WhatToShow2["Attribute"] = 2] = "Attribute";
        WhatToShow2[WhatToShow2["Text"] = 4] = "Text";
        WhatToShow2[WhatToShow2["CDataSection"] = 8] = "CDataSection";
        WhatToShow2[WhatToShow2["EntityReference"] = 16] = "EntityReference";
        WhatToShow2[WhatToShow2["Entity"] = 32] = "Entity";
        WhatToShow2[WhatToShow2["ProcessingInstruction"] = 64] = "ProcessingInstruction";
        WhatToShow2[WhatToShow2["Comment"] = 128] = "Comment";
        WhatToShow2[WhatToShow2["Document"] = 256] = "Document";
        WhatToShow2[WhatToShow2["DocumentType"] = 512] = "DocumentType";
        WhatToShow2[WhatToShow2["DocumentFragment"] = 1024] = "DocumentFragment";
        WhatToShow2[WhatToShow2["Notation"] = 2048] = "Notation";
      })(WhatToShow || (exports.WhatToShow = WhatToShow = {}));
      var HowToCompare;
      (function(HowToCompare2) {
        HowToCompare2[HowToCompare2["StartToStart"] = 0] = "StartToStart";
        HowToCompare2[HowToCompare2["StartToEnd"] = 1] = "StartToEnd";
        HowToCompare2[HowToCompare2["EndToEnd"] = 2] = "EndToEnd";
        HowToCompare2[HowToCompare2["EndToStart"] = 3] = "EndToStart";
      })(HowToCompare || (exports.HowToCompare = HowToCompare = {}));
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/serializer/LocalNameSet.js
  var require_LocalNameSet = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/serializer/LocalNameSet.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LocalNameSet = void 0;
      var LocalNameSet = class {
        constructor() {
          // tuple storage
          __publicField(this, "_items", {});
          __publicField(this, "_nullItems", {});
        }
        /**
         * Adds or replaces a tuple.
         *
         * @param ns - namespace URI
         * @param localName - attribute local name
         */
        set(ns, localName) {
          if (ns === null) {
            this._nullItems[localName] = true;
          } else if (this._items[ns]) {
            this._items[ns][localName] = true;
          } else {
            this._items[ns] = {};
            this._items[ns][localName] = true;
          }
        }
        /**
         * Determines if the given tuple exists in the set.
         *
         * @param ns - namespace URI
         * @param localName - attribute local name
         */
        has(ns, localName) {
          if (ns === null) {
            return this._nullItems[localName] === true;
          } else if (this._items[ns]) {
            return this._items[ns][localName] === true;
          } else {
            return false;
          }
        }
      };
      exports.LocalNameSet = LocalNameSet;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/serializer/NamespacePrefixMap.js
  var require_NamespacePrefixMap = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/serializer/NamespacePrefixMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NamespacePrefixMap = void 0;
      var NamespacePrefixMap = class _NamespacePrefixMap {
        constructor() {
          __publicField(this, "_items", {});
          __publicField(this, "_nullItems", []);
        }
        /**
         * Creates a copy of the map.
         */
        copy() {
          const mapCopy = new _NamespacePrefixMap();
          for (const key in this._items) {
            mapCopy._items[key] = this._items[key].slice(0);
          }
          mapCopy._nullItems = this._nullItems.slice(0);
          return mapCopy;
        }
        /**
         * Retrieves a preferred prefix string from the namespace prefix map.
         *
         * @param preferredPrefix - preferred prefix string
         * @param ns - namespace
         */
        get(preferredPrefix, ns) {
          const candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
          if (candidatesList === null) {
            return null;
          }
          let prefix = null;
          for (let i = 0; i < candidatesList.length; i++) {
            prefix = candidatesList[i];
            if (prefix === preferredPrefix) {
              return prefix;
            }
          }
          return prefix;
        }
        /**
         * Checks if a prefix string is found in the namespace prefix map associated
         * with the given namespace.
         *
         * @param prefix - prefix string
         * @param ns - namespace
         */
        has(prefix, ns) {
          const candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
          if (candidatesList === null) {
            return false;
          }
          return candidatesList.indexOf(prefix) !== -1;
        }
        /**
         * Checks if a prefix string is found in the namespace prefix map.
         *
         * @param prefix - prefix string
         */
        hasPrefix(prefix) {
          if (this._nullItems.indexOf(prefix) !== -1)
            return true;
          for (const key in this._items) {
            if (this._items[key].indexOf(prefix) !== -1)
              return true;
          }
          return false;
        }
        /**
         * Adds a prefix string associated with a namespace to the prefix map.
         *
         * @param prefix - prefix string
         * @param ns - namespace
         */
        set(prefix, ns) {
          const candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
          if (ns !== null && candidatesList === null) {
            this._items[ns] = [prefix];
          } else {
            candidatesList.push(prefix);
          }
        }
      };
      exports.NamespacePrefixMap = NamespacePrefixMap;
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/CodePoints.js
  var require_CodePoints = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/CodePoints.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ASCIIAlphanumeric = exports.ASCIIAlpha = exports.ASCIILowerAlpha = exports.ASCIIUpperAlpha = exports.ASCIIHexDigit = exports.ASCIILowerHexDigit = exports.ASCIIUpperHexDigit = exports.ASCIIDigit = exports.Control = exports.C0ControlOrSpace = exports.C0Control = exports.ASCIIWhiteSpace = exports.ASCIITabOrNewLine = exports.ASCIICodePoint = exports.NonCharacter = exports.ScalarValue = exports.Surrogate = void 0;
      exports.Surrogate = /[\uD800-\uDFFF]/;
      exports.ScalarValue = /[\uD800-\uDFFF]/;
      exports.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/;
      exports.ASCIICodePoint = /[\u0000-\u007F]/;
      exports.ASCIITabOrNewLine = /[\t\n\r]/;
      exports.ASCIIWhiteSpace = /[\t\n\f\r ]/;
      exports.C0Control = /[\u0000-\u001F]/;
      exports.C0ControlOrSpace = /[\u0000-\u001F ]/;
      exports.Control = /[\u0000-\u001F\u007F-\u009F]/;
      exports.ASCIIDigit = /[0-9]/;
      exports.ASCIIUpperHexDigit = /[0-9A-F]/;
      exports.ASCIILowerHexDigit = /[0-9a-f]/;
      exports.ASCIIHexDigit = /[0-9A-Fa-f]/;
      exports.ASCIIUpperAlpha = /[A-Z]/;
      exports.ASCIILowerAlpha = /[a-z]/;
      exports.ASCIIAlpha = /[A-Za-z]/;
      exports.ASCIIAlphanumeric = /[0-9A-Za-z]/;
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Base64.js
  var require_Base64 = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Base64.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.forgivingBase64Encode = forgivingBase64Encode;
      exports.forgivingBase64Decode = forgivingBase64Decode;
      var CodePoints_1 = require_CodePoints();
      function forgivingBase64Encode(input) {
        return Buffer.from(input).toString("base64");
      }
      function forgivingBase64Decode(input) {
        if (input === "")
          return "";
        input = input.replace(CodePoints_1.ASCIIWhiteSpace, "");
        if (input.length % 4 === 0) {
          if (input.endsWith("==")) {
            input = input.substr(0, input.length - 2);
          } else if (input.endsWith("=")) {
            input = input.substr(0, input.length - 1);
          }
        }
        if (input.length % 4 === 1)
          return null;
        if (!/[0-9A-Za-z+/]/.test(input))
          return null;
        return Buffer.from(input, "base64").toString("utf8");
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Byte.js
  var require_Byte = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Byte.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isASCIIByte = isASCIIByte;
      function isASCIIByte(byte) {
        return byte >= 0 && byte <= 127;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/ByteSequence.js
  var require_ByteSequence = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/ByteSequence.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.length = length;
      exports.byteLowercase = byteLowercase;
      exports.byteUppercase = byteUppercase;
      exports.byteCaseInsensitiveMatch = byteCaseInsensitiveMatch;
      exports.startsWith = startsWith;
      exports.byteLessThan = byteLessThan;
      exports.isomorphicDecode = isomorphicDecode;
      function length(list) {
        return list.length;
      }
      function byteLowercase(list) {
        for (let i = 0; i < list.length; i++) {
          const c = list[i];
          if (c >= 65 && c <= 90) {
            list[i] = c + 32;
          }
        }
      }
      function byteUppercase(list) {
        for (let i = 0; i < list.length; i++) {
          const c = list[i];
          if (c >= 97 && c <= 122) {
            list[i] = c - 32;
          }
        }
      }
      function byteCaseInsensitiveMatch(listA, listB) {
        if (listA.length !== listB.length)
          return false;
        for (let i = 0; i < listA.length; i++) {
          let a = listA[i];
          let b = listB[i];
          if (a >= 65 && a <= 90)
            a += 32;
          if (b >= 65 && b <= 90)
            b += 32;
          if (a !== b)
            return false;
        }
        return true;
      }
      function startsWith(listA, listB) {
        let i = 0;
        while (true) {
          if (i >= listA.length)
            return false;
          if (i >= listB.length)
            return true;
          if (listA[i] !== listB[i])
            return false;
          i++;
        }
      }
      function byteLessThan(listA, listB) {
        let i = 0;
        while (true) {
          if (i >= listA.length)
            return false;
          if (i >= listB.length)
            return true;
          const a = listA[i];
          const b = listB[i];
          if (a < b)
            return true;
          else if (a > b)
            return false;
          i++;
        }
      }
      function isomorphicDecode(list) {
        return String.fromCodePoint(...list);
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/JSON.js
  var require_JSON = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/JSON.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseJSONFromBytes = parseJSONFromBytes;
      exports.serializeJSONToBytes = serializeJSONToBytes;
      exports.parseJSONIntoInfraValues = parseJSONIntoInfraValues;
      exports.convertAJSONDerivedJavaScriptValueToAnInfraValue = convertAJSONDerivedJavaScriptValueToAnInfraValue;
      var util_1 = require_lib4();
      function parseJSONFromBytes(bytes) {
        const jsonText = (0, util_1.utf8Decode)(bytes);
        return JSON.parse.call(void 0, jsonText);
      }
      function serializeJSONToBytes(value) {
        const jsonString = JSON.stringify.call(void 0, value);
        return (0, util_1.utf8Encode)(jsonString);
      }
      function parseJSONIntoInfraValues(jsonText) {
        const jsValue = JSON.parse.call(void 0, jsonText);
        return convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue);
      }
      function convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue) {
        if (jsValue === null || (0, util_1.isString)(jsValue) || (0, util_1.isNumber)(jsValue))
          return jsValue;
        if ((0, util_1.isArray)(jsValue)) {
          const result = new Array();
          for (const jsValueAtIndex of jsValue) {
            result.push(convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtIndex));
          }
          return result;
        } else if ((0, util_1.isObject)(jsValue)) {
          const result = /* @__PURE__ */ new Map();
          for (const key in jsValue) {
            if (jsValue.hasOwnProperty(key)) {
              const jsValueAtKey = jsValue[key];
              result.set(key, convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtKey));
            }
          }
          return result;
        }
        return jsValue;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/List.js
  var require_List = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/List.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.append = append;
      exports.extend = extend;
      exports.prepend = prepend;
      exports.replace = replace;
      exports.insert = insert;
      exports.remove = remove;
      exports.empty = empty;
      exports.contains = contains;
      exports.size = size;
      exports.isEmpty = isEmpty;
      exports.forEach = forEach;
      exports.clone = clone;
      exports.sortInAscendingOrder = sortInAscendingOrder;
      exports.sortInDescendingOrder = sortInDescendingOrder;
      var util_1 = require_lib4();
      function append(list, item) {
        list.push(item);
      }
      function extend(listA, listB) {
        listA.push(...listB);
      }
      function prepend(list, item) {
        list.unshift(item);
      }
      function replace(list, conditionOrItem, newItem) {
        let i = 0;
        for (const oldItem of list) {
          if ((0, util_1.isFunction)(conditionOrItem)) {
            if (!!conditionOrItem.call(null, oldItem)) {
              list[i] = newItem;
            }
          } else if (oldItem === conditionOrItem) {
            list[i] = newItem;
            return;
          }
          i++;
        }
      }
      function insert(list, item, index) {
        list.splice(index, 0, item);
      }
      function remove(list, conditionOrItem) {
        let i = list.length;
        while (i--) {
          const oldItem = list[i];
          if ((0, util_1.isFunction)(conditionOrItem)) {
            if (!!conditionOrItem.call(null, oldItem)) {
              list.splice(i, 1);
            }
          } else if (oldItem === conditionOrItem) {
            list.splice(i, 1);
            return;
          }
        }
      }
      function empty(list) {
        list.length = 0;
      }
      function contains(list, conditionOrItem) {
        for (const oldItem of list) {
          if ((0, util_1.isFunction)(conditionOrItem)) {
            if (!!conditionOrItem.call(null, oldItem)) {
              return true;
            }
          } else if (oldItem === conditionOrItem) {
            return true;
          }
        }
        return false;
      }
      function size(list, condition) {
        if (condition === void 0) {
          return list.length;
        } else {
          let count = 0;
          for (const item of list) {
            if (!!condition.call(null, item)) {
              count++;
            }
          }
          return count;
        }
      }
      function isEmpty(list) {
        return list.length === 0;
      }
      function* forEach(list, condition) {
        if (condition === void 0) {
          yield* __yieldStar(list);
        } else {
          for (const item of list) {
            if (!!condition.call(null, item)) {
              yield item;
            }
          }
        }
      }
      function clone(list) {
        return new Array(...list);
      }
      function sortInAscendingOrder(list, lessThanAlgo) {
        return list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
      }
      function sortInDescendingOrder(list, lessThanAlgo) {
        return list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Map.js
  var require_Map = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Map.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.get = get;
      exports.set = set;
      exports.remove = remove;
      exports.contains = contains;
      exports.keys = keys;
      exports.values = values;
      exports.size = size;
      exports.isEmpty = isEmpty;
      exports.forEach = forEach;
      exports.clone = clone;
      exports.sortInAscendingOrder = sortInAscendingOrder;
      exports.sortInDescendingOrder = sortInDescendingOrder;
      var util_1 = require_lib4();
      function get(map, key) {
        return map.get(key);
      }
      function set(map, key, val) {
        map.set(key, val);
      }
      function remove(map, conditionOrItem) {
        if (!(0, util_1.isFunction)(conditionOrItem)) {
          map.delete(conditionOrItem);
        } else {
          const toRemove = [];
          for (const item of map) {
            if (!!conditionOrItem.call(null, item)) {
              toRemove.push(item[0]);
            }
          }
          for (const key of toRemove) {
            map.delete(key);
          }
        }
      }
      function contains(map, conditionOrItem) {
        if (!(0, util_1.isFunction)(conditionOrItem)) {
          return map.has(conditionOrItem);
        } else {
          for (const item of map) {
            if (!!conditionOrItem.call(null, item)) {
              return true;
            }
          }
          return false;
        }
      }
      function keys(map) {
        return new Set(map.keys());
      }
      function values(map) {
        return [...map.values()];
      }
      function size(map, condition) {
        if (condition === void 0) {
          return map.size;
        } else {
          let count = 0;
          for (const item of map) {
            if (!!condition.call(null, item)) {
              count++;
            }
          }
          return count;
        }
      }
      function isEmpty(map) {
        return map.size === 0;
      }
      function* forEach(map, condition) {
        if (condition === void 0) {
          yield* __yieldStar(map);
        } else {
          for (const item of map) {
            if (!!condition.call(null, item)) {
              yield item;
            }
          }
        }
      }
      function clone(map) {
        return new Map(map);
      }
      function sortInAscendingOrder(map, lessThanAlgo) {
        const list = new Array(...map);
        list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
        return new Map(list);
      }
      function sortInDescendingOrder(map, lessThanAlgo) {
        const list = new Array(...map);
        list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
        return new Map(list);
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Namespace.js
  var require_Namespace = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Namespace.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XLink = exports.SVG = exports.MathML = exports.XMLNS = exports.XML = exports.HTML = void 0;
      exports.HTML = "http://www.w3.org/1999/xhtml";
      exports.XML = "http://www.w3.org/XML/1998/namespace";
      exports.XMLNS = "http://www.w3.org/2000/xmlns/";
      exports.MathML = "http://www.w3.org/1998/Math/MathML";
      exports.SVG = "http://www.w3.org/2000/svg";
      exports.XLink = "http://www.w3.org/1999/xlink";
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Queue.js
  var require_Queue = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Queue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.enqueue = enqueue;
      exports.dequeue = dequeue;
      function enqueue(list, item) {
        list.push(item);
      }
      function dequeue(list) {
        return list.shift() || null;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Set.js
  var require_Set = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Set.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.append = append;
      exports.extend = extend;
      exports.prepend = prepend;
      exports.replace = replace;
      exports.insert = insert;
      exports.remove = remove;
      exports.empty = empty;
      exports.contains = contains;
      exports.size = size;
      exports.isEmpty = isEmpty;
      exports.forEach = forEach;
      exports.clone = clone;
      exports.sortInAscendingOrder = sortInAscendingOrder;
      exports.sortInDescendingOrder = sortInDescendingOrder;
      exports.isSubsetOf = isSubsetOf;
      exports.isSupersetOf = isSupersetOf;
      exports.intersection = intersection;
      exports.union = union;
      exports.range = range;
      var util_1 = require_lib4();
      function append(set, item) {
        set.add(item);
      }
      function extend(setA, setB) {
        setB.forEach(setA.add, setA);
      }
      function prepend(set, item) {
        const cloned = new Set(set);
        set.clear();
        set.add(item);
        cloned.forEach(set.add, set);
      }
      function replace(set, conditionOrItem, newItem) {
        const newSet = /* @__PURE__ */ new Set();
        for (const oldItem of set) {
          if ((0, util_1.isFunction)(conditionOrItem)) {
            if (!!conditionOrItem.call(null, oldItem)) {
              newSet.add(newItem);
            } else {
              newSet.add(oldItem);
            }
          } else if (oldItem === conditionOrItem) {
            newSet.add(newItem);
          } else {
            newSet.add(oldItem);
          }
        }
        set.clear();
        newSet.forEach(set.add, set);
      }
      function insert(set, item, index) {
        const newSet = /* @__PURE__ */ new Set();
        let i = 0;
        for (const oldItem of set) {
          if (i === index)
            newSet.add(item);
          newSet.add(oldItem);
          i++;
        }
        set.clear();
        newSet.forEach(set.add, set);
      }
      function remove(set, conditionOrItem) {
        if (!(0, util_1.isFunction)(conditionOrItem)) {
          set.delete(conditionOrItem);
        } else {
          const toRemove = [];
          for (const item of set) {
            if (!!conditionOrItem.call(null, item)) {
              toRemove.push(item);
            }
          }
          for (const oldItem of toRemove) {
            set.delete(oldItem);
          }
        }
      }
      function empty(set) {
        set.clear();
      }
      function contains(set, conditionOrItem) {
        if (!(0, util_1.isFunction)(conditionOrItem)) {
          return set.has(conditionOrItem);
        } else {
          for (const oldItem of set) {
            if (!!conditionOrItem.call(null, oldItem)) {
              return true;
            }
          }
        }
        return false;
      }
      function size(set, condition) {
        if (condition === void 0) {
          return set.size;
        } else {
          let count = 0;
          for (const item of set) {
            if (!!condition.call(null, item)) {
              count++;
            }
          }
          return count;
        }
      }
      function isEmpty(set) {
        return set.size === 0;
      }
      function* forEach(set, condition) {
        if (condition === void 0) {
          yield* __yieldStar(set);
        } else {
          for (const item of set) {
            if (!!condition.call(null, item)) {
              yield item;
            }
          }
        }
      }
      function clone(set) {
        return new Set(set);
      }
      function sortInAscendingOrder(set, lessThanAlgo) {
        const list = new Array(...set);
        list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? -1 : 1);
        return new Set(list);
      }
      function sortInDescendingOrder(set, lessThanAlgo) {
        const list = new Array(...set);
        list.sort((itemA, itemB) => lessThanAlgo.call(null, itemA, itemB) ? 1 : -1);
        return new Set(list);
      }
      function isSubsetOf(subset, superset) {
        for (const item of subset) {
          if (!superset.has(item))
            return false;
        }
        return true;
      }
      function isSupersetOf(superset, subset) {
        return isSubsetOf(subset, superset);
      }
      function intersection(setA, setB) {
        const newSet = /* @__PURE__ */ new Set();
        for (const item of setA) {
          if (setB.has(item))
            newSet.add(item);
        }
        return newSet;
      }
      function union(setA, setB) {
        const newSet = new Set(setA);
        setB.forEach(newSet.add, newSet);
        return newSet;
      }
      function range(n, m) {
        const newSet = /* @__PURE__ */ new Set();
        for (let i = n; i <= m; i++) {
          newSet.add(i);
        }
        return newSet;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Stack.js
  var require_Stack = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/Stack.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.push = push;
      exports.pop = pop;
      function push(list, item) {
        list.push(item);
      }
      function pop(list) {
        return list.pop() || null;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/String.js
  var require_String = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/String.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isCodeUnitPrefix = isCodeUnitPrefix;
      exports.isCodeUnitLessThan = isCodeUnitLessThan;
      exports.isomorphicEncode = isomorphicEncode;
      exports.isASCIIString = isASCIIString;
      exports.asciiLowercase = asciiLowercase;
      exports.asciiUppercase = asciiUppercase;
      exports.asciiCaseInsensitiveMatch = asciiCaseInsensitiveMatch;
      exports.asciiEncode = asciiEncode;
      exports.asciiDecode = asciiDecode;
      exports.stripNewlines = stripNewlines;
      exports.normalizeNewlines = normalizeNewlines;
      exports.stripLeadingAndTrailingASCIIWhitespace = stripLeadingAndTrailingASCIIWhitespace;
      exports.stripAndCollapseASCIIWhitespace = stripAndCollapseASCIIWhitespace;
      exports.collectASequenceOfCodePoints = collectASequenceOfCodePoints;
      exports.skipASCIIWhitespace = skipASCIIWhitespace;
      exports.strictlySplit = strictlySplit;
      exports.splitAStringOnASCIIWhitespace = splitAStringOnASCIIWhitespace;
      exports.splitAStringOnCommas = splitAStringOnCommas;
      exports.concatenate = concatenate;
      var CodePoints_1 = require_CodePoints();
      var ByteSequence_1 = require_ByteSequence();
      var Byte_1 = require_Byte();
      var util_1 = require_lib4();
      function isCodeUnitPrefix(a, b) {
        let i = 0;
        while (true) {
          const aCodeUnit = i < a.length ? a.charCodeAt(i) : null;
          const bCodeUnit = i < b.length ? b.charCodeAt(i) : null;
          if (aCodeUnit === null)
            return true;
          if (aCodeUnit !== bCodeUnit)
            return false;
          i++;
        }
      }
      function isCodeUnitLessThan(a, b) {
        if (isCodeUnitPrefix(b, a))
          return false;
        if (isCodeUnitPrefix(a, b))
          return true;
        for (let i = 0; i < Math.min(a.length, b.length); i++) {
          const aCodeUnit = a.charCodeAt(i);
          const bCodeUnit = b.charCodeAt(i);
          if (aCodeUnit === bCodeUnit)
            continue;
          return aCodeUnit < bCodeUnit;
        }
        return false;
      }
      function isomorphicEncode(str) {
        const codePoints = Array.from(str);
        const bytes = new Uint8Array(codePoints.length);
        let i = 0;
        for (const codePoint of str) {
          const byte = codePoint.codePointAt(0);
          console.assert(byte !== void 0 && byte <= 255, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF.");
          if (byte !== void 0 && byte <= 255) {
            bytes[i++] = byte;
          }
        }
        return bytes;
      }
      function isASCIIString(str) {
        return /^[\u0000-\u007F]*$/.test(str);
      }
      function asciiLowercase(str) {
        let result = "";
        for (const c of str) {
          const code = c.codePointAt(0);
          if (code !== void 0 && code >= 65 && code <= 90) {
            result += String.fromCodePoint(code + 32);
          } else {
            result += c;
          }
        }
        return result;
      }
      function asciiUppercase(str) {
        let result = "";
        for (const c of str) {
          const code = c.codePointAt(0);
          if (code !== void 0 && code >= 97 && code <= 122) {
            result += String.fromCodePoint(code - 32);
          } else {
            result += c;
          }
        }
        return result;
      }
      function asciiCaseInsensitiveMatch(a, b) {
        return asciiLowercase(a) === asciiLowercase(b);
      }
      function asciiEncode(str) {
        console.assert(isASCIIString(str), "asciiEncode requires an ASCII string.");
        return isomorphicEncode(str);
      }
      function asciiDecode(bytes) {
        for (const byte of bytes) {
          console.assert((0, Byte_1.isASCIIByte)(byte), "asciiDecode requires an ASCII byte sequence.");
        }
        return (0, ByteSequence_1.isomorphicDecode)(bytes);
      }
      function stripNewlines(str) {
        return str.replace(/[\n\r]/g, "");
      }
      function normalizeNewlines(str) {
        return str.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      }
      function stripLeadingAndTrailingASCIIWhitespace(str) {
        return str.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
      }
      function stripAndCollapseASCIIWhitespace(str) {
        return stripLeadingAndTrailingASCIIWhitespace(str.replace(/[\t\n\f\r ]{2,}/g, " "));
      }
      function collectASequenceOfCodePoints(condition, input, options) {
        if (!(0, util_1.isArray)(input))
          return collectASequenceOfCodePoints(condition, Array.from(input), options);
        let result = "";
        while (options.position < input.length && !!condition.call(null, input[options.position])) {
          result += input[options.position];
          options.position++;
        }
        return result;
      }
      function skipASCIIWhitespace(input, options) {
        collectASequenceOfCodePoints((str) => CodePoints_1.ASCIIWhiteSpace.test(str), input, options);
      }
      function strictlySplit(input, delimiter) {
        if (!(0, util_1.isArray)(input))
          return strictlySplit(Array.from(input), delimiter);
        const options = { position: 0 };
        const tokens = [];
        let token = collectASequenceOfCodePoints((str) => delimiter !== str, input, options);
        tokens.push(token);
        while (options.position < input.length) {
          console.assert(input[options.position] === delimiter, "strictlySplit found no delimiter in input string.");
          options.position++;
          token = collectASequenceOfCodePoints((str) => delimiter !== str, input, options);
          tokens.push(token);
        }
        return tokens;
      }
      function splitAStringOnASCIIWhitespace(input) {
        if (!(0, util_1.isArray)(input))
          return splitAStringOnASCIIWhitespace(Array.from(input));
        const options = { position: 0 };
        const tokens = [];
        skipASCIIWhitespace(input, options);
        while (options.position < input.length) {
          const token = collectASequenceOfCodePoints((str) => !CodePoints_1.ASCIIWhiteSpace.test(str), input, options);
          tokens.push(token);
          skipASCIIWhitespace(input, options);
        }
        return tokens;
      }
      function splitAStringOnCommas(input) {
        if (!(0, util_1.isArray)(input))
          return splitAStringOnCommas(Array.from(input));
        const options = { position: 0 };
        const tokens = [];
        while (options.position < input.length) {
          const token = collectASequenceOfCodePoints((str) => str !== ",", input, options);
          tokens.push(stripLeadingAndTrailingASCIIWhitespace(token));
          if (options.position < input.length) {
            console.assert(input[options.position] === ",", "splitAStringOnCommas found no delimiter in input string.");
            options.position++;
          }
        }
        return tokens;
      }
      function concatenate(list, separator = "") {
        if (list.length === 0)
          return "";
        return list.join(separator);
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/.pnpm/@oozcitak+infra@2.0.2/node_modules/@oozcitak/infra/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o) {
          ownKeys = Object.getOwnPropertyNames || function(o2) {
            var ar = [];
            for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
            return ar;
          };
          return ownKeys(o);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.string = exports.stack = exports.set = exports.queue = exports.namespace = exports.map = exports.list = exports.json = exports.codePoint = exports.byteSequence = exports.byte = exports.base64 = void 0;
      var base64 = __importStar(require_Base64());
      exports.base64 = base64;
      var byte = __importStar(require_Byte());
      exports.byte = byte;
      var byteSequence = __importStar(require_ByteSequence());
      exports.byteSequence = byteSequence;
      var codePoint = __importStar(require_CodePoints());
      exports.codePoint = codePoint;
      var json = __importStar(require_JSON());
      exports.json = json;
      var list = __importStar(require_List());
      exports.list = list;
      var map = __importStar(require_Map());
      exports.map = map;
      var namespace = __importStar(require_Namespace());
      exports.namespace = namespace;
      var queue = __importStar(require_Queue());
      exports.queue = queue;
      var set = __importStar(require_Set());
      exports.set = set;
      var stack = __importStar(require_Stack());
      exports.stack = stack;
      var string = __importStar(require_String());
      exports.string = string;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/WebIDLAlgorithm.js
  var require_WebIDLAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/WebIDLAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.idl_defineConst = idl_defineConst;
      function idl_defineConst(o, name, value) {
        Object.defineProperty(o, name, { writable: false, enumerable: true, configurable: false, value });
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DOMImplementationImpl.js
  var require_DOMImplementationImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DOMImplementationImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DOMImplementationImpl = void 0;
      var DOMImpl_1 = require_DOMImpl();
      var infra_1 = require_lib5();
      var algorithm_1 = require_algorithm();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var DOMImplementationImpl = class _DOMImplementationImpl {
        /**
         * Initializes a new instance of `DOMImplementation`.
         *
         * @param document - the associated document
         */
        constructor(document2) {
          __publicField(this, "_ID", "@oozcitak/dom");
          __publicField(this, "_associatedDocument");
          this._associatedDocument = document2 || DOMImpl_1.dom.window.document;
        }
        /** @inheritdoc */
        createDocumentType(qualifiedName, publicId, systemId) {
          (0, algorithm_1.namespace_validate)(qualifiedName);
          return (0, algorithm_1.create_documentType)(this._associatedDocument, qualifiedName, publicId, systemId);
        }
        /** @inheritdoc */
        createDocument(namespace, qualifiedName, doctype = null) {
          const document2 = (0, algorithm_1.create_xmlDocument)();
          let element = null;
          if (qualifiedName) {
            element = (0, algorithm_1.document_internalCreateElementNS)(document2, namespace, qualifiedName);
          }
          if (doctype)
            document2.appendChild(doctype);
          if (element)
            document2.appendChild(element);
          document2._origin = this._associatedDocument._origin;
          if (namespace === infra_1.namespace.HTML)
            document2._contentType = "application/xhtml+xml";
          else if (namespace === infra_1.namespace.SVG)
            document2._contentType = "image/svg+xml";
          else
            document2._contentType = "application/xml";
          return document2;
        }
        /** @inheritdoc */
        createHTMLDocument(title) {
          const doc = (0, algorithm_1.create_document)();
          doc._type = "html";
          doc._contentType = "text/html";
          doc.appendChild((0, algorithm_1.create_documentType)(doc, "html", "", ""));
          const htmlElement = (0, algorithm_1.element_createAnElement)(doc, "html", infra_1.namespace.HTML);
          doc.appendChild(htmlElement);
          const headElement = (0, algorithm_1.element_createAnElement)(doc, "head", infra_1.namespace.HTML);
          htmlElement.appendChild(headElement);
          if (title !== void 0) {
            const titleElement = (0, algorithm_1.element_createAnElement)(doc, "title", infra_1.namespace.HTML);
            headElement.appendChild(titleElement);
            const textElement = (0, algorithm_1.create_text)(doc, title);
            titleElement.appendChild(textElement);
          }
          const bodyElement = (0, algorithm_1.element_createAnElement)(doc, "body", infra_1.namespace.HTML);
          htmlElement.appendChild(bodyElement);
          doc._origin = this._associatedDocument._origin;
          return doc;
        }
        /** @inheritdoc */
        hasFeature() {
          return true;
        }
        /**
         * Creates a new `DOMImplementation`.
         *
         * @param document - owner document
         */
        static _create(document2) {
          return new _DOMImplementationImpl(document2);
        }
      };
      exports.DOMImplementationImpl = DOMImplementationImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(DOMImplementationImpl.prototype, "_ID", "@oozcitak/dom");
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DOMException.js
  var require_DOMException = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DOMException.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InvalidCharacterError = exports.SyntaxError = exports.IndexSizeError = exports.NotFoundError = exports.HierarchyRequestError = exports.NotImplementedError = exports.DataCloneError = exports.InvalidNodeTypeError = exports.TimeoutError = exports.QuotaExceededError = exports.URLMismatchError = exports.AbortError = exports.NetworkError = exports.SecurityError = exports.TypeMismatchError = exports.ValidationError = exports.InvalidAccessError = exports.NamespaceError = exports.InvalidModificationError = exports.InvalidStateError = exports.InUseAttributeError = exports.NotSupportedError = exports.NoModificationAllowedError = exports.NoDataAllowedError = exports.WrongDocumentError = exports.DOMStringSizeError = exports.DOMException = void 0;
      var DOMException = class extends Error {
        /**
         *
         * @param name - message name
         * @param message - error message
         */
        constructor(name, message = "") {
          super(message);
          /**
           * Returns the name of the error message.
           */
          __publicField(this, "name");
          this.name = name;
        }
      };
      exports.DOMException = DOMException;
      var DOMStringSizeError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("DOMStringSizeError", message);
        }
      };
      exports.DOMStringSizeError = DOMStringSizeError;
      var WrongDocumentError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("WrongDocumentError", "The object is in the wrong document. " + message);
        }
      };
      exports.WrongDocumentError = WrongDocumentError;
      var NoDataAllowedError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("NoDataAllowedError", message);
        }
      };
      exports.NoDataAllowedError = NoDataAllowedError;
      var NoModificationAllowedError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("NoModificationAllowedError", "The object can not be modified. " + message);
        }
      };
      exports.NoModificationAllowedError = NoModificationAllowedError;
      var NotSupportedError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("NotSupportedError", "The operation is not supported. " + message);
        }
      };
      exports.NotSupportedError = NotSupportedError;
      var InUseAttributeError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("InUseAttributeError", message);
        }
      };
      exports.InUseAttributeError = InUseAttributeError;
      var InvalidStateError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("InvalidStateError", "The object is in an invalid state. " + message);
        }
      };
      exports.InvalidStateError = InvalidStateError;
      var InvalidModificationError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("InvalidModificationError", "The object can not be modified in this way. " + message);
        }
      };
      exports.InvalidModificationError = InvalidModificationError;
      var NamespaceError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("NamespaceError", "The operation is not allowed by Namespaces in XML. [XMLNS] " + message);
        }
      };
      exports.NamespaceError = NamespaceError;
      var InvalidAccessError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("InvalidAccessError", "The object does not support the operation or argument. " + message);
        }
      };
      exports.InvalidAccessError = InvalidAccessError;
      var ValidationError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("ValidationError", message);
        }
      };
      exports.ValidationError = ValidationError;
      var TypeMismatchError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("TypeMismatchError", message);
        }
      };
      exports.TypeMismatchError = TypeMismatchError;
      var SecurityError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("SecurityError", "The operation is insecure. " + message);
        }
      };
      exports.SecurityError = SecurityError;
      var NetworkError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("NetworkError", "A network error occurred. " + message);
        }
      };
      exports.NetworkError = NetworkError;
      var AbortError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("AbortError", "The operation was aborted. " + message);
        }
      };
      exports.AbortError = AbortError;
      var URLMismatchError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("URLMismatchError", "The given URL does not match another URL. " + message);
        }
      };
      exports.URLMismatchError = URLMismatchError;
      var QuotaExceededError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("QuotaExceededError", "The quota has been exceeded. " + message);
        }
      };
      exports.QuotaExceededError = QuotaExceededError;
      var TimeoutError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("TimeoutError", "The operation timed out. " + message);
        }
      };
      exports.TimeoutError = TimeoutError;
      var InvalidNodeTypeError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("InvalidNodeTypeError", "The supplied node is incorrect or has an incorrect ancestor for this operation. " + message);
        }
      };
      exports.InvalidNodeTypeError = InvalidNodeTypeError;
      var DataCloneError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("DataCloneError", "The object can not be cloned. " + message);
        }
      };
      exports.DataCloneError = DataCloneError;
      var NotImplementedError = class extends DOMException {
        /**
        * @param message - error message
        */
        constructor(message = "") {
          super("NotImplementedError", "The DOM method is not implemented by this module. " + message);
        }
      };
      exports.NotImplementedError = NotImplementedError;
      var HierarchyRequestError = class extends DOMException {
        /**
         * @param message - error message
         */
        constructor(message = "") {
          super("HierarchyRequestError", "The operation would yield an incorrect node tree. " + message);
        }
      };
      exports.HierarchyRequestError = HierarchyRequestError;
      var NotFoundError = class extends DOMException {
        /**
         * @param message - error message
         */
        constructor(message = "") {
          super("NotFoundError", "The object can not be found here. " + message);
        }
      };
      exports.NotFoundError = NotFoundError;
      var IndexSizeError = class extends DOMException {
        /**
         * @param message - error message
         */
        constructor(message = "") {
          super("IndexSizeError", "The index is not in the allowed range. " + message);
        }
      };
      exports.IndexSizeError = IndexSizeError;
      var SyntaxError = class extends DOMException {
        /**
         * @param message - error message
         */
        constructor(message = "") {
          super("SyntaxError", "The string did not match the expected pattern. " + message);
        }
      };
      exports.SyntaxError = SyntaxError;
      var InvalidCharacterError = class extends DOMException {
        /**
         * @param message - error message
         */
        constructor(message = "") {
          super("InvalidCharacterError", "The string contains invalid characters. " + message);
        }
      };
      exports.InvalidCharacterError = InvalidCharacterError;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/util/Guard.js
  var require_Guard = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/util/Guard.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Guard = void 0;
      var interfaces_1 = require_interfaces2();
      var Guard = class _Guard {
        /**
         * Determines if the given object is a `Node`.
         *
         * @param a - the object to check
         */
        static isNode(a) {
          return !!a && a._nodeType !== void 0;
        }
        /**
         * Determines if the given object is a `Document`.
         *
         * @param a - the object to check
         */
        static isDocumentNode(a) {
          return _Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Document;
        }
        /**
         * Determines if the given object is a `DocumentType`.
         *
         * @param a - the object to check
         */
        static isDocumentTypeNode(a) {
          return _Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentType;
        }
        /**
         * Determines if the given object is a `DocumentFragment`.
         *
         * @param a - the object to check
         */
        static isDocumentFragmentNode(a) {
          return _Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentFragment;
        }
        /**
         * Determines if the given object is a `Attr`.
         *
         * @param a - the object to check
         */
        static isAttrNode(a) {
          return _Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Attribute;
        }
        /**
         * Determines if the given node is a `CharacterData` node.
         *
         * @param a - the object to check
         */
        static isCharacterDataNode(a) {
          if (!_Guard.isNode(a))
            return false;
          const type = a._nodeType;
          return type === interfaces_1.NodeType.Text || type === interfaces_1.NodeType.ProcessingInstruction || type === interfaces_1.NodeType.Comment || type === interfaces_1.NodeType.CData;
        }
        /**
         * Determines if the given object is a `Text` or a `CDATASection`.
         *
         * @param a - the object to check
         */
        static isTextNode(a) {
          return _Guard.isNode(a) && (a._nodeType === interfaces_1.NodeType.Text || a._nodeType === interfaces_1.NodeType.CData);
        }
        /**
         * Determines if the given object is a `Text`.
         *
         * @param a - the object to check
         */
        static isExclusiveTextNode(a) {
          return _Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Text;
        }
        /**
         * Determines if the given object is a `CDATASection`.
         *
         * @param a - the object to check
         */
        static isCDATASectionNode(a) {
          return _Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.CData;
        }
        /**
         * Determines if the given object is a `Comment`.
         *
         * @param a - the object to check
         */
        static isCommentNode(a) {
          return _Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Comment;
        }
        /**
         * Determines if the given object is a `ProcessingInstruction`.
         *
         * @param a - the object to check
         */
        static isProcessingInstructionNode(a) {
          return _Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.ProcessingInstruction;
        }
        /**
         * Determines if the given object is an `Element`.
         *
         * @param a - the object to check
         */
        static isElementNode(a) {
          return _Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Element;
        }
        /**
         * Determines if the given object is a custom `Element`.
         *
         * @param a - the object to check
         */
        static isCustomElementNode(a) {
          return _Guard.isElementNode(a) && a._customElementState === "custom";
        }
        /**
         * Determines if the given object is a `ShadowRoot`.
         *
         * @param a - the object to check
         */
        static isShadowRoot(a) {
          return !!a && a.host !== void 0;
        }
        /**
         * Determines if the given object is a `MouseEvent`.
         *
         * @param a - the object to check
         */
        static isMouseEvent(a) {
          return !!a && a.screenX !== void 0 && a.screenY != void 0;
        }
        /**
         * Determines if the given object is a slotable.
         *
         * Element and Text nodes are slotables. A slotable has an associated name
         * (a string).
         *
         * @param a - the object to check
         */
        static isSlotable(a) {
          return !!a && a._name !== void 0 && a._assignedSlot !== void 0 && (_Guard.isTextNode(a) || _Guard.isElementNode(a));
        }
        /**
         * Determines if the given object is a slot.
         *
         * @param a - the object to check
         */
        static isSlot(a) {
          return !!a && a._name !== void 0 && a._assignedNodes !== void 0 && _Guard.isElementNode(a);
        }
        /**
         * Determines if the given object is a `Window`.
         *
         * @param a - the object to check
         */
        static isWindow(a) {
          return !!a && a.navigator !== void 0;
        }
        /**
         * Determines if the given object is an `EventListener`.
         *
         * @param a - the object to check
         */
        static isEventListener(a) {
          return !!a && a.handleEvent !== void 0;
        }
        /**
         * Determines if the given object is a `RegisteredObserver`.
         *
         * @param a - the object to check
         */
        static isRegisteredObserver(a) {
          return !!a && a.observer !== void 0 && a.options !== void 0;
        }
        /**
        * Determines if the given object is a `TransientRegisteredObserver`.
        *
        * @param a - the object to check
        */
        static isTransientRegisteredObserver(a) {
          return !!a && a.source !== void 0 && _Guard.isRegisteredObserver(a);
        }
      };
      exports.Guard = Guard;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/util/Cast.js
  var require_Cast = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/util/Cast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Cast = void 0;
      var Guard_1 = require_Guard();
      var Cast = class {
        /**
         * Casts the given object to a `Node`.
         *
         * @param a - the object to cast
         */
        static asNode(a) {
          if (Guard_1.Guard.isNode(a)) {
            return a;
          } else {
            throw new Error("Invalid object. Node expected.");
          }
        }
      };
      exports.Cast = Cast;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/util/EmptySet.js
  var require_EmptySet = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/util/EmptySet.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EmptySet = void 0;
      var EmptySet = class {
        get size() {
          return 0;
        }
        add(value) {
          throw new Error("Cannot add to an empty set.");
        }
        clear() {
        }
        delete(value) {
          return false;
        }
        forEach(callbackfn, thisArg) {
        }
        has(value) {
          return false;
        }
        [Symbol.iterator]() {
          return new EmptySetIterator();
        }
        entries() {
          return new EmptySetIterator();
        }
        keys() {
          return new EmptySetIterator();
        }
        values() {
          return new EmptySetIterator();
        }
        get [Symbol.toStringTag]() {
          return "EmptySet";
        }
      };
      exports.EmptySet = EmptySet;
      var EmptySetIterator = class {
        [Symbol.iterator]() {
          return this;
        }
        next() {
          return { done: true, value: null };
        }
      };
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/util/index.js
  var require_util2 = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/util/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EmptySet = exports.Guard = exports.Cast = void 0;
      var Cast_1 = require_Cast();
      Object.defineProperty(exports, "Cast", { enumerable: true, get: function() {
        return Cast_1.Cast;
      } });
      var Guard_1 = require_Guard();
      Object.defineProperty(exports, "Guard", { enumerable: true, get: function() {
        return Guard_1.Guard;
      } });
      var EmptySet_1 = require_EmptySet();
      Object.defineProperty(exports, "EmptySet", { enumerable: true, get: function() {
        return EmptySet_1.EmptySet;
      } });
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/EventTargetImpl.js
  var require_EventTargetImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/EventTargetImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EventTargetImpl = void 0;
      var DOMException_1 = require_DOMException();
      var util_1 = require_util2();
      var algorithm_1 = require_algorithm();
      var EventTargetImpl = class {
        /**
         * Initializes a new instance of `EventTarget`.
         */
        constructor() {
          __publicField(this, "__eventListenerList");
          __publicField(this, "__eventHandlerMap");
        }
        get _eventListenerList() {
          return this.__eventListenerList || (this.__eventListenerList = []);
        }
        get _eventHandlerMap() {
          return this.__eventHandlerMap || (this.__eventHandlerMap = {});
        }
        /** @inheritdoc */
        addEventListener(type, callback, options = { passive: false, once: false, capture: false }) {
          const [capture, passive, once] = (0, algorithm_1.eventTarget_flattenMore)(options);
          let listenerCallback;
          if (!callback) {
            return;
          } else if (util_1.Guard.isEventListener(callback)) {
            listenerCallback = callback;
          } else {
            listenerCallback = { handleEvent: callback };
          }
          (0, algorithm_1.eventTarget_addEventListener)(this, {
            type,
            callback: listenerCallback,
            capture,
            passive,
            once,
            removed: false
          });
        }
        /** @inheritdoc */
        removeEventListener(type, callback, options = { capture: false }) {
          const capture = (0, algorithm_1.eventTarget_flatten)(options);
          if (!callback)
            return;
          for (let i = 0; i < this._eventListenerList.length; i++) {
            const entry = this._eventListenerList[i];
            if (entry.type !== type || entry.capture !== capture)
              continue;
            if (util_1.Guard.isEventListener(callback) && entry.callback === callback) {
              (0, algorithm_1.eventTarget_removeEventListener)(this, entry, i);
              break;
            } else if (callback && entry.callback.handleEvent === callback) {
              (0, algorithm_1.eventTarget_removeEventListener)(this, entry, i);
              break;
            }
          }
        }
        /** @inheritdoc */
        dispatchEvent(event) {
          if (event._dispatchFlag || !event._initializedFlag) {
            throw new DOMException_1.InvalidStateError();
          }
          event._isTrusted = false;
          return (0, algorithm_1.event_dispatch)(event, this);
        }
        /** @inheritdoc */
        _getTheParent(event) {
          return null;
        }
      };
      exports.EventTargetImpl = EventTargetImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/WindowImpl.js
  var require_WindowImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/WindowImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.WindowImpl = void 0;
      var EventTargetImpl_1 = require_EventTargetImpl();
      var util_1 = require_lib4();
      var algorithm_1 = require_algorithm();
      var WindowImpl = class _WindowImpl extends EventTargetImpl_1.EventTargetImpl {
        /**
         * Initializes a new instance of `Window`.
         */
        constructor() {
          super();
          __publicField(this, "_currentEvent");
          __publicField(this, "_signalSlots", /* @__PURE__ */ new Set());
          __publicField(this, "_mutationObserverMicrotaskQueued", false);
          __publicField(this, "_mutationObservers", /* @__PURE__ */ new Set());
          __publicField(this, "_associatedDocument");
          __publicField(this, "_iteratorList", new util_1.FixedSizeSet());
          this._associatedDocument = (0, algorithm_1.create_document)();
        }
        /** @inheritdoc */
        get document() {
          return this._associatedDocument;
        }
        /** @inheritdoc */
        get event() {
          return this._currentEvent;
        }
        /**
         * Creates a new window with a blank document.
         */
        static _create() {
          return new _WindowImpl();
        }
      };
      exports.WindowImpl = WindowImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+url@3.0.0/node_modules/@oozcitak/url/lib/interfaces.js
  var require_interfaces3 = __commonJS({
    "node_modules/.pnpm/@oozcitak+url@3.0.0/node_modules/@oozcitak/url/lib/interfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OpaqueOrigin = exports.ParserState = void 0;
      var ParserState;
      (function(ParserState2) {
        ParserState2[ParserState2["SchemeStart"] = 0] = "SchemeStart";
        ParserState2[ParserState2["Scheme"] = 1] = "Scheme";
        ParserState2[ParserState2["NoScheme"] = 2] = "NoScheme";
        ParserState2[ParserState2["SpecialRelativeOrAuthority"] = 3] = "SpecialRelativeOrAuthority";
        ParserState2[ParserState2["PathOrAuthority"] = 4] = "PathOrAuthority";
        ParserState2[ParserState2["Relative"] = 5] = "Relative";
        ParserState2[ParserState2["RelativeSlash"] = 6] = "RelativeSlash";
        ParserState2[ParserState2["SpecialAuthoritySlashes"] = 7] = "SpecialAuthoritySlashes";
        ParserState2[ParserState2["SpecialAuthorityIgnoreSlashes"] = 8] = "SpecialAuthorityIgnoreSlashes";
        ParserState2[ParserState2["Authority"] = 9] = "Authority";
        ParserState2[ParserState2["Host"] = 10] = "Host";
        ParserState2[ParserState2["Hostname"] = 11] = "Hostname";
        ParserState2[ParserState2["Port"] = 12] = "Port";
        ParserState2[ParserState2["File"] = 13] = "File";
        ParserState2[ParserState2["FileSlash"] = 14] = "FileSlash";
        ParserState2[ParserState2["FileHost"] = 15] = "FileHost";
        ParserState2[ParserState2["PathStart"] = 16] = "PathStart";
        ParserState2[ParserState2["Path"] = 17] = "Path";
        ParserState2[ParserState2["CannotBeABaseURLPath"] = 18] = "CannotBeABaseURLPath";
        ParserState2[ParserState2["Query"] = 19] = "Query";
        ParserState2[ParserState2["Fragment"] = 20] = "Fragment";
      })(ParserState || (exports.ParserState = ParserState = {}));
      exports.OpaqueOrigin = ["", "", null, null];
    }
  });

  // node_modules/.pnpm/@oozcitak+url@3.0.0/node_modules/@oozcitak/url/lib/URLAlgorithm.js
  var require_URLAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+url@3.0.0/node_modules/@oozcitak/url/lib/URLAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.setValidationErrorCallback = setValidationErrorCallback;
      exports.newURL = newURL;
      exports.isSpecialScheme = isSpecialScheme;
      exports.isSpecial = isSpecial;
      exports.defaultPort = defaultPort;
      exports.includesCredentials = includesCredentials;
      exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
      exports.urlSerializer = urlSerializer;
      exports.hostSerializer = hostSerializer;
      exports.iPv4Serializer = iPv4Serializer;
      exports.iPv6Serializer = iPv6Serializer;
      exports.urlParser = urlParser;
      exports.basicURLParser = basicURLParser;
      exports.setTheUsername = setTheUsername;
      exports.setThePassword = setThePassword;
      exports.isSingleDotPathSegment = isSingleDotPathSegment;
      exports.isDoubleDotPathSegment = isDoubleDotPathSegment;
      exports.shorten = shorten;
      exports.isNormalizedWindowsDriveLetter = isNormalizedWindowsDriveLetter;
      exports.isWindowsDriveLetter = isWindowsDriveLetter;
      exports.startsWithAWindowsDriveLetter = startsWithAWindowsDriveLetter;
      exports.hostParser = hostParser;
      exports.iPv4NumberParser = iPv4NumberParser;
      exports.iPv4Parser = iPv4Parser;
      exports.iPv6Parser = iPv6Parser;
      exports.opaqueHostParser = opaqueHostParser;
      exports.resolveABlobURL = resolveABlobURL;
      exports.percentEncode = percentEncode;
      exports.percentDecode = percentDecode;
      exports.stringPercentDecode = stringPercentDecode;
      exports.utf8PercentEncode = utf8PercentEncode;
      exports.hostEquals = hostEquals;
      exports.urlEquals = urlEquals;
      exports.urlEncodedStringParser = urlEncodedStringParser;
      exports.urlEncodedParser = urlEncodedParser;
      exports.urlEncodedByteSerializer = urlEncodedByteSerializer;
      exports.urlEncodedSerializer = urlEncodedSerializer;
      exports.origin = origin;
      exports.domainToASCII = domainToASCII;
      exports.domainToUnicode = domainToUnicode;
      exports.asciiSerializationOfAnOrigin = asciiSerializationOfAnOrigin;
      var util_1 = require_lib4();
      var interfaces_1 = require_interfaces3();
      var infra_1 = require_lib5();
      var url_1 = __require("url");
      var _validationErrorCallback;
      var _defaultPorts = {
        "ftp": 21,
        "file": null,
        "http": 80,
        "https": 443,
        "ws": 80,
        "wss": 443
      };
      var _c0ControlPercentEncodeSet = /[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var _fragmentPercentEncodeSet = /[ "<>`]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var _pathPercentEncodeSet = /[ "<>`#?{}]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var _userInfoPercentEncodeSet = /[ "<>`#?{}/:;=@\[\]\\\^\|]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var _urlCodePoints = /[0-9A-Za-z!\$&-\/:;=\?@_~\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB40-\uDB7E\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDC00-\uDFFD]/;
      var _forbiddenHostCodePoint = /[\0\t\f\r #%/:?@\[\\\]]/;
      function setValidationErrorCallback(validationErrorCallback) {
        _validationErrorCallback = validationErrorCallback;
      }
      function validationError(message) {
        if (_validationErrorCallback !== void 0) {
          _validationErrorCallback.call(null, "Validation Error: " + message);
        }
      }
      function newURL() {
        return {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          _cannotBeABaseURLFlag: false,
          _blobURLEntry: null
        };
      }
      function isSpecialScheme(scheme) {
        return scheme in _defaultPorts;
      }
      function isSpecial(url) {
        return isSpecialScheme(url.scheme);
      }
      function defaultPort(scheme) {
        return _defaultPorts[scheme] || null;
      }
      function includesCredentials(url) {
        return url.username !== "" || url.password !== "";
      }
      function cannotHaveAUsernamePasswordPort(url) {
        return url.host === null || url.host === "" || url._cannotBeABaseURLFlag || url.scheme === "file";
      }
      function urlSerializer(url, excludeFragmentFlag = false) {
        let output = url.scheme + ":";
        if (url.host !== null) {
          output += "//";
          if (includesCredentials(url)) {
            output += url.username;
            if (url.password !== "") {
              output += ":" + url.password;
            }
            output += "@";
          }
          output += hostSerializer(url.host);
          if (url.port !== null) {
            output += ":" + url.port;
          }
        } else if (url.host === null && url.scheme === "file") {
          output += "//";
        }
        if (url._cannotBeABaseURLFlag) {
          output += url.path[0];
        } else {
          for (const str of url.path) {
            output += "/" + str;
          }
        }
        if (url.query !== null) {
          output += "?" + url.query;
        }
        if (!excludeFragmentFlag && url.fragment !== null) {
          output += "#" + url.fragment;
        }
        return output;
      }
      function hostSerializer(host) {
        if ((0, util_1.isNumber)(host)) {
          return iPv4Serializer(host);
        } else if ((0, util_1.isArray)(host)) {
          return "[" + iPv6Serializer(host) + "]";
        } else {
          return host;
        }
      }
      function iPv4Serializer(address) {
        let output = "";
        let n = address;
        for (let i = 1; i <= 4; i++) {
          output = (n % 256).toString() + output;
          if (i !== 4) {
            output = "." + output;
          }
          n = Math.floor(n / 256);
        }
        return output;
      }
      function iPv6Serializer(address) {
        let output = "";
        let compress = null;
        let lastIndex = -1;
        let count = 0;
        let lastCount = 0;
        for (let i = 0; i < 8; i++) {
          if (address[i] !== 0)
            continue;
          count = 1;
          for (let j = i + 1; j < 8; j++) {
            if (address[j] !== 0)
              break;
            count++;
            continue;
          }
          if (count > lastCount) {
            lastCount = count;
            lastIndex = i;
          }
        }
        if (lastCount > 1)
          compress = lastIndex;
        let ignore0 = false;
        for (let pieceIndex = 0; pieceIndex < 8; pieceIndex++) {
          if (ignore0 && address[pieceIndex] === 0)
            continue;
          if (ignore0)
            ignore0 = false;
          if (compress === pieceIndex) {
            output += pieceIndex === 0 ? "::" : ":";
            ignore0 = true;
            continue;
          }
          output += address[pieceIndex].toString(16);
          if (pieceIndex !== 7)
            output += ":";
        }
        return output;
      }
      function urlParser(input, baseURL, encodingOverride) {
        const url = basicURLParser(input, baseURL, encodingOverride);
        if (url === null)
          return null;
        if (url.scheme !== "blob")
          return url;
        const entry = resolveABlobURL(url);
        if (entry !== null) {
          url._blobURLEntry = entry;
        } else {
          url._blobURLEntry = null;
        }
        return url;
      }
      function basicURLParser(input, baseURL, encodingOverride, url, stateOverride) {
        if (url === void 0) {
          url = newURL();
          const leadingControlOrSpace = /^[\u0000-\u001F\u0020]+/;
          const trailingControlOrSpace = /[\u0000-\u001F\u0020]+$/;
          if (leadingControlOrSpace.test(input) || trailingControlOrSpace.test(input)) {
            validationError("Input string contains leading or trailing control characters or space.");
          }
          input = input.replace(leadingControlOrSpace, "");
          input = input.replace(trailingControlOrSpace, "");
        }
        const tabOrNewline = /[\u0009\u000A\u000D]/g;
        if (tabOrNewline.test(input)) {
          validationError("Input string contains tab or newline characters.");
        }
        input = input.replace(tabOrNewline, "");
        let state = stateOverride === void 0 ? interfaces_1.ParserState.SchemeStart : stateOverride;
        if (baseURL === void 0)
          baseURL = null;
        let encoding = encodingOverride === void 0 || encodingOverride === "replacement" || encodingOverride === "UTF-16BE" || encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride;
        let buffer = "";
        let atFlag = false;
        let arrayFlag = false;
        let passwordTokenSeenFlag = false;
        const EOF = "";
        const walker = new util_1.StringWalker(input);
        while (true) {
          switch (state) {
            case interfaces_1.ParserState.SchemeStart:
              if (infra_1.codePoint.ASCIIAlpha.test(walker.c())) {
                buffer += walker.c().toLowerCase();
                state = interfaces_1.ParserState.Scheme;
              } else if (stateOverride === void 0) {
                state = interfaces_1.ParserState.NoScheme;
                walker.pointer--;
              } else {
                validationError("Invalid scheme start character.");
                return null;
              }
              break;
            case interfaces_1.ParserState.Scheme:
              if (infra_1.codePoint.ASCIIAlphanumeric.test(walker.c()) || walker.c() === "+" || walker.c() === "-" || walker.c() === ".") {
                buffer += walker.c().toLowerCase();
              } else if (walker.c() === ":") {
                if (stateOverride !== void 0) {
                  if (isSpecialScheme(url.scheme) && !isSpecialScheme(buffer))
                    return url;
                  if (!isSpecialScheme(url.scheme) && isSpecialScheme(buffer))
                    return url;
                  if ((includesCredentials(url) || url.port !== null) && buffer === "file")
                    return url;
                  if (url.scheme === "file" && (url.host === "" || url.host === null))
                    return url;
                }
                url.scheme = buffer;
                if (stateOverride !== void 0) {
                  if (url.port === defaultPort(url.scheme)) {
                    url.port = null;
                  }
                  return url;
                }
                buffer = "";
                if (url.scheme === "file") {
                  if (!walker.remaining().startsWith("//")) {
                    validationError("Invalid file URL scheme, '//' expected.");
                  }
                  state = interfaces_1.ParserState.File;
                } else if (isSpecial(url) && baseURL !== null && baseURL.scheme === url.scheme) {
                  state = interfaces_1.ParserState.SpecialRelativeOrAuthority;
                } else if (isSpecial(url)) {
                  state = interfaces_1.ParserState.SpecialAuthoritySlashes;
                } else if (walker.remaining().startsWith("/")) {
                  state = interfaces_1.ParserState.PathOrAuthority;
                  walker.pointer++;
                } else {
                  url._cannotBeABaseURLFlag = true;
                  url.path.push("");
                  state = interfaces_1.ParserState.CannotBeABaseURLPath;
                }
              } else if (stateOverride === void 0) {
                buffer = "";
                state = interfaces_1.ParserState.NoScheme;
                walker.pointer = 0;
                continue;
              } else {
                validationError("Invalid input string.");
                return null;
              }
              break;
            case interfaces_1.ParserState.NoScheme:
              if (baseURL === null || baseURL._cannotBeABaseURLFlag && walker.c() !== "#") {
                validationError("Invalid input string.");
                return null;
              } else if (baseURL._cannotBeABaseURLFlag && walker.c() === "#") {
                url.scheme = baseURL.scheme;
                url.path = infra_1.list.clone(baseURL.path);
                url.query = baseURL.query;
                url.fragment = "";
                url._cannotBeABaseURLFlag = true;
                state = interfaces_1.ParserState.Fragment;
              } else if (baseURL.scheme !== "file") {
                state = interfaces_1.ParserState.Relative;
                walker.pointer--;
              } else {
                state = interfaces_1.ParserState.File;
                walker.pointer--;
              }
              break;
            case interfaces_1.ParserState.SpecialRelativeOrAuthority:
              if (walker.c() === "/" && walker.remaining().startsWith("/")) {
                state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                walker.pointer++;
              } else {
                validationError("Invalid input string.");
                state = interfaces_1.ParserState.Relative;
                walker.pointer--;
              }
              break;
            case interfaces_1.ParserState.PathOrAuthority:
              if (walker.c() === "/") {
                state = interfaces_1.ParserState.Authority;
              } else {
                state = interfaces_1.ParserState.Path;
                walker.pointer--;
              }
              break;
            case interfaces_1.ParserState.Relative:
              if (baseURL === null) {
                throw new Error("Invalid parser state. Base URL is null.");
              }
              url.scheme = baseURL.scheme;
              switch (walker.c()) {
                case EOF:
                  url.username = baseURL.username;
                  url.password = baseURL.password;
                  url.host = baseURL.host;
                  url.port = baseURL.port;
                  url.path = infra_1.list.clone(baseURL.path);
                  url.query = baseURL.query;
                  break;
                case "/":
                  state = interfaces_1.ParserState.RelativeSlash;
                  break;
                case "?":
                  url.username = baseURL.username;
                  url.password = baseURL.password;
                  url.host = baseURL.host;
                  url.port = baseURL.port;
                  url.path = infra_1.list.clone(baseURL.path);
                  url.query = "";
                  state = interfaces_1.ParserState.Query;
                  break;
                case "#":
                  url.username = baseURL.username;
                  url.password = baseURL.password;
                  url.host = baseURL.host;
                  url.port = baseURL.port;
                  url.path = infra_1.list.clone(baseURL.path);
                  url.query = baseURL.query;
                  url.fragment = "";
                  state = interfaces_1.ParserState.Fragment;
                  break;
                default:
                  if (isSpecial(url) && walker.c() === "\\") {
                    validationError("Invalid input string.");
                    state = interfaces_1.ParserState.RelativeSlash;
                  } else {
                    url.username = baseURL.username;
                    url.password = baseURL.password;
                    url.host = baseURL.host;
                    url.port = baseURL.port;
                    url.path = infra_1.list.clone(baseURL.path);
                    if (url.path.length !== 0)
                      url.path.splice(url.path.length - 1, 1);
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                  }
                  break;
              }
              break;
            case interfaces_1.ParserState.RelativeSlash:
              if (isSpecial(url) && (walker.c() === "/" || walker.c() === "\\")) {
                if (walker.c() === "\\") {
                  validationError("Invalid input string.");
                }
                state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
              } else if (walker.c() === "/") {
                state = interfaces_1.ParserState.Authority;
              } else {
                if (baseURL === null) {
                  throw new Error("Invalid parser state. Base URL is null.");
                }
                url.username = baseURL.username;
                url.password = baseURL.password;
                url.host = baseURL.host;
                url.port = baseURL.port;
                state = interfaces_1.ParserState.Path;
                walker.pointer--;
              }
              break;
            case interfaces_1.ParserState.SpecialAuthoritySlashes:
              if (walker.c() === "/" && walker.remaining().startsWith("/")) {
                state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                walker.pointer++;
              } else {
                validationError("Expected '//'.");
                state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                walker.pointer--;
              }
              break;
            case interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes:
              if (walker.c() !== "/" && walker.c() !== "\\") {
                state = interfaces_1.ParserState.Authority;
                walker.pointer--;
              } else {
                validationError("Unexpected '/' or '\\'.");
              }
              break;
            case interfaces_1.ParserState.Authority:
              if (walker.c() === "@") {
                validationError("Unexpected '@'.");
                if (atFlag)
                  buffer = "%40" + buffer;
                atFlag = true;
                for (const codePoint of buffer) {
                  if (codePoint === ":" && !passwordTokenSeenFlag) {
                    passwordTokenSeenFlag = true;
                    continue;
                  }
                  const encodedCodePoints = utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
                  if (passwordTokenSeenFlag) {
                    url.password += encodedCodePoints;
                  } else {
                    url.username += encodedCodePoints;
                  }
                }
                buffer = "";
              } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\") {
                if (atFlag && buffer === "") {
                  validationError("Invalid input string.");
                  return null;
                }
                walker.pointer -= buffer.length + 1;
                buffer = "";
                state = interfaces_1.ParserState.Host;
              } else {
                buffer += walker.c();
              }
              break;
            case interfaces_1.ParserState.Host:
            case interfaces_1.ParserState.Hostname:
              if (stateOverride !== void 0 && url.scheme === "file") {
                walker.pointer--;
                state = interfaces_1.ParserState.FileHost;
              } else if (walker.c() === ":" && !arrayFlag) {
                if (buffer === "") {
                  validationError("Invalid input string.");
                  return null;
                }
                const host = hostParser(buffer, !isSpecial(url));
                if (host === null)
                  return null;
                url.host = host;
                buffer = "";
                state = interfaces_1.ParserState.Port;
                if (stateOverride === interfaces_1.ParserState.Hostname)
                  return url;
              } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\") {
                walker.pointer--;
                if (isSpecial(url) && buffer === "") {
                  validationError("Invalid input string.");
                  return null;
                } else if (stateOverride !== void 0 && buffer === "" && (includesCredentials(url) || url.port !== null)) {
                  validationError("Invalid input string.");
                  return url;
                }
                const host = hostParser(buffer, !isSpecial(url));
                if (host === null)
                  return null;
                url.host = host;
                buffer = "";
                state = interfaces_1.ParserState.PathStart;
                if (stateOverride !== void 0)
                  return url;
              } else {
                if (walker.c() === "[")
                  arrayFlag = true;
                if (walker.c() === "]")
                  arrayFlag = false;
                buffer += walker.c();
              }
              break;
            case interfaces_1.ParserState.Port:
              if (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                buffer += walker.c();
              } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\" || stateOverride) {
                if (buffer !== "") {
                  if (buffer !== "") {
                    const port = parseInt(buffer, 10);
                    if (port > Math.pow(2, 16) - 1) {
                      validationError("Invalid port number.");
                      return null;
                    }
                    url.port = port === defaultPort(url.scheme) ? null : port;
                    buffer = "";
                  }
                }
                if (stateOverride !== void 0) {
                  return url;
                }
                state = interfaces_1.ParserState.PathStart;
                walker.pointer--;
              } else {
                validationError("Invalid input string.");
                return null;
              }
              break;
            case interfaces_1.ParserState.File:
              url.scheme = "file";
              if (walker.c() === "/" || walker.c() === "\\") {
                if (walker.c() === "\\") {
                  validationError("Invalid input string.");
                }
                state = interfaces_1.ParserState.FileSlash;
              } else if (baseURL !== null && baseURL.scheme === "file") {
                switch (walker.c()) {
                  case EOF:
                    url.host = baseURL.host;
                    url.path = infra_1.list.clone(baseURL.path);
                    url.query = baseURL.query;
                    break;
                  case "?":
                    url.host = baseURL.host;
                    url.path = infra_1.list.clone(baseURL.path);
                    url.query = "";
                    state = interfaces_1.ParserState.Query;
                    break;
                  case "#":
                    url.host = baseURL.host;
                    url.path = infra_1.list.clone(baseURL.path);
                    url.query = baseURL.query;
                    url.fragment = "";
                    state = interfaces_1.ParserState.Fragment;
                    break;
                  default:
                    if (!startsWithAWindowsDriveLetter(walker.substring())) {
                      url.host = baseURL.host;
                      url.path = infra_1.list.clone(baseURL.path);
                      shorten(url);
                    } else {
                      validationError("Unexpected windows drive letter in input string.");
                    }
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                    break;
                }
              } else {
                state = interfaces_1.ParserState.Path;
                walker.pointer--;
              }
              break;
            case interfaces_1.ParserState.FileSlash:
              if (walker.c() === "/" || walker.c() === "\\") {
                if (walker.c() === "\\") {
                  validationError("Invalid input string.");
                }
                state = interfaces_1.ParserState.FileHost;
              } else {
                if (baseURL !== null && baseURL.scheme === "file" && !startsWithAWindowsDriveLetter(walker.substring())) {
                  if (isNormalizedWindowsDriveLetter(baseURL.path[0])) {
                    url.path.push(baseURL.path[0]);
                  } else {
                    url.host = baseURL.host;
                  }
                }
                state = interfaces_1.ParserState.Path;
                walker.pointer--;
              }
              break;
            case interfaces_1.ParserState.FileHost:
              if (walker.c() === EOF || walker.c() === "/" || walker.c() === "\\" || walker.c() === "?" || walker.c() === "#") {
                walker.pointer--;
                if (stateOverride === void 0 && isWindowsDriveLetter(buffer)) {
                  validationError("Unexpected windows drive letter in input string.");
                  state = interfaces_1.ParserState.Path;
                } else if (buffer === "") {
                  url.host = "";
                  if (stateOverride !== void 0)
                    return url;
                  state = interfaces_1.ParserState.PathStart;
                } else {
                  let host = hostParser(buffer, !isSpecial(url));
                  if (host === null)
                    return null;
                  if (host === "localhost")
                    host = "";
                  url.host = host;
                  if (stateOverride !== void 0)
                    return url;
                  buffer = "";
                  state = interfaces_1.ParserState.PathStart;
                }
              } else {
                buffer += walker.c();
              }
              break;
            case interfaces_1.ParserState.PathStart:
              if (isSpecial(url)) {
                if (walker.c() === "\\") {
                  validationError("Invalid input string.");
                }
                state = interfaces_1.ParserState.Path;
                if (walker.c() !== "/" && walker.c() !== "\\")
                  walker.pointer--;
              } else if (stateOverride === void 0 && walker.c() === "?") {
                url.query = "";
                state = interfaces_1.ParserState.Query;
              } else if (stateOverride === void 0 && walker.c() === "#") {
                url.fragment = "";
                state = interfaces_1.ParserState.Fragment;
              } else if (walker.c() !== EOF) {
                state = interfaces_1.ParserState.Path;
                if (walker.c() !== "/")
                  walker.pointer--;
              }
              break;
            case interfaces_1.ParserState.Path:
              if (walker.c() === EOF || walker.c() === "/" || isSpecial(url) && walker.c() === "\\" || stateOverride === void 0 && (walker.c() === "?" || walker.c() === "#")) {
                if (isSpecial(url) && walker.c() === "\\") {
                  validationError("Invalid input string.");
                }
                if (isDoubleDotPathSegment(buffer)) {
                  shorten(url);
                  if (walker.c() !== "/" && !(isSpecial(url) && walker.c() === "\\")) {
                    url.path.push("");
                  }
                } else if (isSingleDotPathSegment(buffer) && walker.c() !== "/" && !(isSpecial(url) && walker.c() === "\\")) {
                  url.path.push("");
                } else if (!isSingleDotPathSegment(buffer)) {
                  if (url.scheme === "file" && url.path.length === 0 && isWindowsDriveLetter(buffer)) {
                    if (url.host !== null && url.host !== "") {
                      validationError("Invalid input string.");
                      url.host = "";
                    }
                    const bufferCodePoints = Array.from(buffer);
                    buffer = bufferCodePoints.slice(0, 1) + ":" + bufferCodePoints.slice(2);
                  }
                  url.path.push(buffer);
                }
                buffer = "";
                if (url.scheme === "file" && (walker.c() === EOF || walker.c() === "?" || walker.c() === "#")) {
                  while (url.path.length > 1 && url.path[0] === "") {
                    validationError("Invalid input string.");
                    url.path.splice(0, 1);
                  }
                }
                if (walker.c() === "?") {
                  url.query = "";
                  state = interfaces_1.ParserState.Query;
                }
                if (walker.c() === "#") {
                  url.fragment = "";
                  state = interfaces_1.ParserState.Fragment;
                }
              } else {
                if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
                  validationError("Character is not a URL code point or a percent encoded character.");
                }
                if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                  validationError("Percent encoded character must be followed by two hex digits.");
                }
                buffer += utf8PercentEncode(walker.c(), _pathPercentEncodeSet);
              }
              break;
            case interfaces_1.ParserState.CannotBeABaseURLPath:
              if (walker.c() === "?") {
                url.query = "";
                state = interfaces_1.ParserState.Query;
              } else if (walker.c() === "#") {
                url.fragment = "";
                state = interfaces_1.ParserState.Fragment;
              } else {
                if (walker.c() !== EOF && !_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
                  validationError("Character is not a URL code point or a percent encoded character.");
                }
                if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                  validationError("Percent encoded character must be followed by two hex digits.");
                }
                if (walker.c() !== EOF) {
                  url.path[0] += utf8PercentEncode(walker.c(), _c0ControlPercentEncodeSet);
                }
              }
              break;
            case interfaces_1.ParserState.Query:
              if (encoding !== "UTF-8" && (!isSpecial(url) || url.scheme === "ws" || url.scheme === "wss")) {
                encoding = "UTF-8";
              }
              if (stateOverride === void 0 && walker.c() === "#") {
                url.fragment = "";
                state = interfaces_1.ParserState.Fragment;
              } else if (walker.c() !== EOF) {
                if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
                  validationError("Character is not a URL code point or a percent encoded character.");
                }
                if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                  validationError("Percent encoded character must be followed by two hex digits.");
                }
                if (encoding.toUpperCase() !== "UTF-8") {
                  throw new Error("Only UTF-8 encoding is supported.");
                }
                let bytes = (0, util_1.utf8Encode)(walker.c());
                if (bytes.length >= 3 && bytes[0] === 38 && bytes[1] === 35 && bytes[bytes.length - 1] === 59) {
                  bytes = bytes.subarray(2, bytes.length - 1);
                  url.query += "%26%23" + infra_1.byteSequence.isomorphicDecode(bytes) + "%3B";
                } else {
                  for (const byte of bytes) {
                    if (byte < 33 || byte > 126 || byte === 34 || byte === 35 || byte === 60 || byte === 62 || byte === 39 && isSpecial(url)) {
                      url.query += percentEncode(byte);
                    } else {
                      url.query += String.fromCharCode(byte);
                    }
                  }
                }
              }
              break;
            case interfaces_1.ParserState.Fragment:
              if (walker.c() === EOF) {
              } else if (walker.c() === "\0") {
                validationError("NULL character in input string.");
              } else {
                if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
                  validationError("Unexpected character in fragment string.");
                }
                if (walker.c() === "%" && !/^[A-Za-z0-9][A-Za-z0-9]/.test(walker.remaining())) {
                  validationError("Unexpected character in fragment string.");
                }
                url.fragment += utf8PercentEncode(walker.c(), _fragmentPercentEncodeSet);
              }
              break;
          }
          if (walker.eof)
            break;
          else
            walker.pointer++;
        }
        return url;
      }
      function setTheUsername(url, username) {
        let result = "";
        for (const codePoint of username) {
          result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
        }
        url.username = result;
      }
      function setThePassword(url, password) {
        let result = "";
        for (const codePoint of password) {
          result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
        }
        url.password = result;
      }
      function isSingleDotPathSegment(str) {
        return str === "." || str.toLowerCase() === "%2e";
      }
      function isDoubleDotPathSegment(str) {
        const lowerStr = str.toLowerCase();
        return lowerStr === ".." || lowerStr === ".%2e" || lowerStr === "%2e." || lowerStr === "%2e%2e";
      }
      function shorten(url) {
        const path = url.path;
        if (path.length === 0)
          return;
        if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0]))
          return;
        url.path.splice(url.path.length - 1, 1);
      }
      function isNormalizedWindowsDriveLetter(str) {
        return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) && str[1] === ":";
      }
      function isWindowsDriveLetter(str) {
        return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) && (str[1] === ":" || str[1] === "|");
      }
      function startsWithAWindowsDriveLetter(str) {
        return str.length >= 2 && isWindowsDriveLetter(str) && (str.length === 2 || (str[2] === "/" || str[2] === "\\" || str[2] === "?" || str[2] === "#"));
      }
      function hostParser(input, isNotSpecial = false) {
        if (input.startsWith("[")) {
          if (!input.endsWith("]")) {
            validationError("Expected ']' after '['.");
            return null;
          }
          return iPv6Parser(input.substring(1, input.length - 1));
        }
        if (isNotSpecial) {
          return opaqueHostParser(input);
        }
        const domain = (0, util_1.utf8Decode)(stringPercentDecode(input));
        const asciiDomain = domainToASCII(domain);
        if (asciiDomain === null) {
          validationError("Invalid domain.");
          return null;
        }
        if (_forbiddenHostCodePoint.test(asciiDomain)) {
          validationError("Invalid domain.");
          return null;
        }
        const ipv4Host = iPv4Parser(asciiDomain);
        if (ipv4Host === null || (0, util_1.isNumber)(ipv4Host))
          return ipv4Host;
        return asciiDomain;
      }
      function iPv4NumberParser(input, validationErrorFlag = { value: false }) {
        let R = 10;
        if (input.startsWith("0x") || input.startsWith("0X")) {
          validationErrorFlag.value = true;
          input = input.substr(2);
          R = 16;
        } else if (input.length >= 2 && input[0] === "0") {
          validationErrorFlag.value = true;
          input = input.substr(1);
          R = 8;
        }
        if (input === "")
          return 0;
        const radixRDigits = R === 10 ? /^[0-9]+$/ : R === 16 ? /^[0-9A-Fa-f]+$/ : /^[0-7]+$/;
        if (!radixRDigits.test(input))
          return null;
        return parseInt(input, R);
      }
      function iPv4Parser(input) {
        const validationErrorFlag = { value: false };
        const parts = input.split(".");
        if (parts[parts.length - 1] === "") {
          validationErrorFlag.value = true;
          if (parts.length > 1)
            parts.pop();
        }
        if (parts.length > 4)
          return input;
        const numbers = [];
        for (const part of parts) {
          if (part === "")
            return input;
          const n = iPv4NumberParser(part, validationErrorFlag);
          if (n === null)
            return input;
          numbers.push(n);
        }
        if (validationErrorFlag.value)
          validationError("Invalid IP v4 address.");
        for (let i = 0; i < numbers.length; i++) {
          const item = numbers[i];
          if (item > 255) {
            validationError("Invalid IP v4 address.");
            if (i < numbers.length - 1)
              return null;
          }
        }
        if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
          validationError("Invalid IP v4 address.");
          return null;
        }
        let ipv4 = numbers[numbers.length - 1];
        numbers.pop();
        let counter = 0;
        for (const n of numbers) {
          ipv4 += n * Math.pow(256, 3 - counter);
          counter++;
        }
        return ipv4;
      }
      function iPv6Parser(input) {
        const EOF = "";
        const address = [0, 0, 0, 0, 0, 0, 0, 0];
        let pieceIndex = 0;
        let compress = null;
        const walker = new util_1.StringWalker(input);
        if (walker.c() === ":") {
          if (!walker.remaining().startsWith(":")) {
            validationError("Invalid IP v6 address.");
            return null;
          }
          walker.pointer += 2;
          pieceIndex += 1;
          compress = pieceIndex;
        }
        while (walker.c() !== EOF) {
          if (pieceIndex === 8) {
            validationError("Invalid IP v6 address.");
            return null;
          }
          if (walker.c() === ":") {
            if (compress !== null) {
              validationError("Invalid IP v6 address.");
              return null;
            }
            walker.pointer++;
            pieceIndex++;
            compress = pieceIndex;
            continue;
          }
          let value = 0;
          let length = 0;
          while (length < 4 && infra_1.codePoint.ASCIIHexDigit.test(walker.c())) {
            value = value * 16 + parseInt(walker.c(), 16);
            walker.pointer++;
            length++;
          }
          if (walker.c() === ".") {
            if (length === 0) {
              validationError("Invalid IP v6 address.");
              return null;
            }
            walker.pointer -= length;
            if (pieceIndex > 6) {
              validationError("Invalid IP v6 address.");
              return null;
            }
            let numbersSeen = 0;
            while (walker.c() !== EOF) {
              let ipv4Piece = null;
              if (numbersSeen > 0) {
                if (walker.c() === "." && numbersSeen < 4) {
                  walker.pointer++;
                } else {
                  validationError("Invalid IP v6 address.");
                  return null;
                }
              }
              if (!infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                validationError("Invalid IP v6 address.");
                return null;
              }
              while (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                const number = parseInt(walker.c(), 10);
                if (ipv4Piece === null) {
                  ipv4Piece = number;
                } else if (ipv4Piece === 0) {
                  validationError("Invalid IP v6 address.");
                  return null;
                } else {
                  ipv4Piece = ipv4Piece * 10 + number;
                }
                if (ipv4Piece > 255) {
                  validationError("Invalid IP v6 address.");
                  return null;
                }
                walker.pointer++;
              }
              if (ipv4Piece === null) {
                validationError("Invalid IP v6 address.");
                return null;
              }
              address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
              numbersSeen++;
              if (numbersSeen === 2 || numbersSeen === 4)
                pieceIndex++;
            }
            if (numbersSeen !== 4) {
              validationError("Invalid IP v6 address.");
              return null;
            }
            break;
          } else if (walker.c() === ":") {
            walker.pointer++;
            if (walker.c() === EOF) {
              validationError("Invalid IP v6 address.");
              return null;
            }
          } else if (walker.c() !== EOF) {
            validationError("Invalid IP v6 address.");
            return null;
          }
          address[pieceIndex] = value;
          pieceIndex++;
        }
        if (compress !== null) {
          let swaps = pieceIndex - compress;
          pieceIndex = 7;
          while (pieceIndex !== 0 && swaps > 0) {
            [address[pieceIndex], address[compress + swaps - 1]] = [address[compress + swaps - 1], address[pieceIndex]];
            pieceIndex--;
            swaps--;
          }
        } else if (compress === null && pieceIndex !== 8) {
          validationError("Invalid IP v6 address.");
          return null;
        }
        return address;
      }
      function opaqueHostParser(input) {
        const forbiddenChars = /[\x00\t\f\r #/:?@\[\\\]]/;
        if (forbiddenChars.test(input)) {
          validationError("Invalid host string.");
          return null;
        }
        let output = "";
        for (const codePoint of input) {
          output += utf8PercentEncode(codePoint, _c0ControlPercentEncodeSet);
        }
        return output;
      }
      function resolveABlobURL(url) {
        return null;
      }
      function percentEncode(value) {
        return "%" + ("00" + value.toString(16).toUpperCase()).slice(-2);
      }
      function percentDecode(input) {
        const isHexDigit = (byte) => {
          return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
        };
        const output = new Uint8Array(input.length);
        let n = 0;
        for (let i = 0; i < input.length; i++) {
          const byte = input[i];
          if (byte !== 37) {
            output[n] = byte;
            n++;
          } else if (byte === 37 && i >= input.length - 2) {
            output[n] = byte;
            n++;
          } else if (byte === 37 && (!isHexDigit(input[i + 1]) || !isHexDigit(input[i + 2]))) {
            output[n] = byte;
            n++;
          } else {
            const bytePoint = parseInt((0, util_1.utf8Decode)(Uint8Array.of(input[i + 1], input[i + 2])), 16);
            output[n] = bytePoint;
            n++;
            i += 2;
          }
        }
        return output.subarray(0, n);
      }
      function stringPercentDecode(input) {
        return percentDecode((0, util_1.utf8Encode)(input));
      }
      function utf8PercentEncode(codePoint, percentEncodeSet) {
        if (!percentEncodeSet.test(codePoint))
          return codePoint;
        const bytes = (0, util_1.utf8Encode)(codePoint);
        let result = "";
        for (const byte of bytes) {
          result += percentEncode(byte);
        }
        return result;
      }
      function hostEquals(hostA, hostB) {
        return hostA === hostB;
      }
      function urlEquals(urlA, urlB, excludeFragmentsFlag = false) {
        return urlSerializer(urlA, excludeFragmentsFlag) === urlSerializer(urlB, excludeFragmentsFlag);
      }
      function urlEncodedStringParser(input) {
        return urlEncodedParser((0, util_1.utf8Encode)(input));
      }
      function urlEncodedParser(input) {
        const sequences = [];
        let currentSequence = [];
        for (const byte of input) {
          if (byte === 38) {
            sequences.push(Uint8Array.from(currentSequence));
            currentSequence = [];
          } else {
            currentSequence.push(byte);
          }
        }
        if (currentSequence.length !== 0) {
          sequences.push(Uint8Array.from(currentSequence));
        }
        const output = [];
        for (const bytes of sequences) {
          if (bytes.length === 0)
            continue;
          const index = bytes.indexOf(61);
          const name = index !== -1 ? bytes.slice(0, index) : bytes;
          const value = index !== -1 ? bytes.slice(index + 1) : new Uint8Array();
          for (let i = 0; i < name.length; i++)
            if (name[i] === 43)
              name[i] = 32;
          for (let i = 0; i < value.length; i++)
            if (value[i] === 43)
              value[i] = 32;
          const nameString = (0, util_1.utf8Decode)(name);
          const valueString = (0, util_1.utf8Decode)(value);
          output.push([nameString, valueString]);
        }
        return output;
      }
      function urlEncodedByteSerializer(input) {
        let output = "";
        for (const byte of input) {
          if (byte === 32) {
            output += "+";
          } else if (byte === 42 || byte === 45 || byte === 46 || byte >= 48 && byte <= 57 || byte >= 65 && byte <= 90 || byte === 95 || byte >= 97 && byte <= 122) {
            output += String.fromCodePoint(byte);
          } else {
            output += percentEncode(byte);
          }
        }
        return output;
      }
      function urlEncodedSerializer(tuples, encodingOverride) {
        const encoding = encodingOverride === void 0 || encodingOverride === "replacement" || encodingOverride === "UTF-16BE" || encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride;
        if (encoding.toUpperCase() !== "UTF-8") {
          throw new Error("Only UTF-8 encoding is supported.");
        }
        let output = "";
        for (const tuple of tuples) {
          const name = urlEncodedByteSerializer((0, util_1.utf8Encode)(tuple[0]));
          let value = tuple[1];
          value = urlEncodedByteSerializer((0, util_1.utf8Encode)(value));
          if (output !== "")
            output += "&";
          output += name + "=" + value;
        }
        return output;
      }
      function origin(url) {
        switch (url.scheme) {
          case "blob":
            if (url._blobURLEntry !== null) {
            }
            const parsedURL = basicURLParser(url.path[0]);
            if (parsedURL === null)
              return interfaces_1.OpaqueOrigin;
            else
              return origin(parsedURL);
          case "ftp":
          case "http":
          case "https":
          case "ws":
          case "wss":
            return [url.scheme, url.host === null ? "" : url.host, url.port, null];
          case "file":
            return interfaces_1.OpaqueOrigin;
          default:
            return interfaces_1.OpaqueOrigin;
        }
      }
      function domainToASCII(domain, beStrict = false) {
        const result = (0, url_1.domainToASCII)(domain);
        if (result === "") {
          validationError("Invalid domain name.");
          return null;
        }
        return result;
      }
      function domainToUnicode(domain, beStrict = false) {
        const result = (0, url_1.domainToUnicode)(domain);
        if (result === "") {
          validationError("Invalid domain name.");
        }
        return result;
      }
      function asciiSerializationOfAnOrigin(origin2) {
        if (origin2[0] === "" && origin2[1] === "" && origin2[2] === null && origin2[3] === null) {
          return "null";
        }
        let result = origin2[0] + "://" + hostSerializer(origin2[1]);
        if (origin2[2] !== null)
          result += ":" + origin2[2].toString();
        return result;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NodeImpl.js
  var require_NodeImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NodeImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NodeImpl = void 0;
      var DOMImpl_1 = require_DOMImpl();
      var interfaces_1 = require_interfaces2();
      var EventTargetImpl_1 = require_EventTargetImpl();
      var util_1 = require_util2();
      var DOMException_1 = require_DOMException();
      var algorithm_1 = require_algorithm();
      var URLAlgorithm_1 = require_URLAlgorithm();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var NodeImpl = class extends EventTargetImpl_1.EventTargetImpl {
        /**
         * Initializes a new instance of `Node`.
         */
        constructor() {
          super();
          __publicField(this, "ELEMENT_NODE", 1);
          __publicField(this, "ATTRIBUTE_NODE", 2);
          __publicField(this, "TEXT_NODE", 3);
          __publicField(this, "CDATA_SECTION_NODE", 4);
          __publicField(this, "ENTITY_REFERENCE_NODE", 5);
          __publicField(this, "ENTITY_NODE", 6);
          __publicField(this, "PROCESSING_INSTRUCTION_NODE", 7);
          __publicField(this, "COMMENT_NODE", 8);
          __publicField(this, "DOCUMENT_NODE", 9);
          __publicField(this, "DOCUMENT_TYPE_NODE", 10);
          __publicField(this, "DOCUMENT_FRAGMENT_NODE", 11);
          __publicField(this, "NOTATION_NODE", 12);
          __publicField(this, "DOCUMENT_POSITION_DISCONNECTED", 1);
          __publicField(this, "DOCUMENT_POSITION_PRECEDING", 2);
          __publicField(this, "DOCUMENT_POSITION_FOLLOWING", 4);
          __publicField(this, "DOCUMENT_POSITION_CONTAINS", 8);
          __publicField(this, "DOCUMENT_POSITION_CONTAINED_BY", 16);
          __publicField(this, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 32);
          __publicField(this, "__childNodes");
          __publicField(this, "_nodeDocumentOverride");
          __publicField(this, "__registeredObserverList");
          __publicField(this, "_parent", null);
          __publicField(this, "_children", new util_1.EmptySet());
          __publicField(this, "_firstChild", null);
          __publicField(this, "_lastChild", null);
          __publicField(this, "_previousSibling", null);
          __publicField(this, "_nextSibling", null);
        }
        get _childNodes() {
          return this.__childNodes || (this.__childNodes = (0, algorithm_1.create_nodeList)(this));
        }
        get _nodeDocument() {
          return this._nodeDocumentOverride || DOMImpl_1.dom.window._associatedDocument;
        }
        set _nodeDocument(val) {
          this._nodeDocumentOverride = val;
        }
        get _registeredObserverList() {
          return this.__registeredObserverList || (this.__registeredObserverList = []);
        }
        /** @inheritdoc */
        get nodeType() {
          return this._nodeType;
        }
        /**
         * Returns a string appropriate for the type of node.
         */
        get nodeName() {
          if (util_1.Guard.isElementNode(this)) {
            return this._htmlUppercasedQualifiedName;
          } else if (util_1.Guard.isAttrNode(this)) {
            return this._qualifiedName;
          } else if (util_1.Guard.isExclusiveTextNode(this)) {
            return "#text";
          } else if (util_1.Guard.isCDATASectionNode(this)) {
            return "#cdata-section";
          } else if (util_1.Guard.isProcessingInstructionNode(this)) {
            return this._target;
          } else if (util_1.Guard.isCommentNode(this)) {
            return "#comment";
          } else if (util_1.Guard.isDocumentNode(this)) {
            return "#document";
          } else if (util_1.Guard.isDocumentTypeNode(this)) {
            return this._name;
          } else if (util_1.Guard.isDocumentFragmentNode(this)) {
            return "#document-fragment";
          } else {
            return "";
          }
        }
        /**
         * Gets the absolute base URL of the node.
         */
        get baseURI() {
          return (0, URLAlgorithm_1.urlSerializer)(this._nodeDocument._URL);
        }
        /**
         * Returns whether the node is rooted to a document node.
         */
        get isConnected() {
          return util_1.Guard.isElementNode(this) && (0, algorithm_1.shadowTree_isConnected)(this);
        }
        /**
         * Returns the parent document.
         */
        get ownerDocument() {
          if (this._nodeType === interfaces_1.NodeType.Document)
            return null;
          else
            return this._nodeDocument;
        }
        /**
         * Returns the root node.
         *
         * @param options - if options has `composed = true` this function
         * returns the node's shadow-including root, otherwise it returns
         * the node's root node.
         */
        getRootNode(options) {
          return (0, algorithm_1.tree_rootNode)(this, !!options && options.composed);
        }
        /**
         * Returns the parent node.
         */
        get parentNode() {
          if (this._nodeType === interfaces_1.NodeType.Attribute) {
            return null;
          } else {
            return this._parent;
          }
        }
        /**
         * Returns the parent element.
         */
        get parentElement() {
          if (this._parent && util_1.Guard.isElementNode(this._parent)) {
            return this._parent;
          } else {
            return null;
          }
        }
        /**
         * Determines whether a node has any children.
         */
        hasChildNodes() {
          return this._firstChild !== null;
        }
        /**
         * Returns a {@link NodeList} of child nodes.
         */
        get childNodes() {
          return this._childNodes;
        }
        /**
         * Returns the first child node.
         */
        get firstChild() {
          return this._firstChild;
        }
        /**
         * Returns the last child node.
         */
        get lastChild() {
          return this._lastChild;
        }
        /**
         * Returns the previous sibling node.
         */
        get previousSibling() {
          return this._previousSibling;
        }
        /**
         * Returns the next sibling node.
         */
        get nextSibling() {
          return this._nextSibling;
        }
        /**
         * Gets or sets the data associated with a {@link CharacterData} node or the
         * value of an {@link @Attr} node. For other node types returns `null`.
         */
        get nodeValue() {
          if (util_1.Guard.isAttrNode(this)) {
            return this._value;
          } else if (util_1.Guard.isCharacterDataNode(this)) {
            return this._data;
          } else {
            return null;
          }
        }
        set nodeValue(value) {
          if (value === null) {
            value = "";
          }
          if (util_1.Guard.isAttrNode(this)) {
            (0, algorithm_1.attr_setAnExistingAttributeValue)(this, value);
          } else if (util_1.Guard.isCharacterDataNode(this)) {
            (0, algorithm_1.characterData_replaceData)(this, 0, this._data.length, value);
          }
        }
        /**
         * Returns the concatenation of data of all the {@link Text}
         * node descendants in tree order. When set, replaces the text
         * contents of the node with the given value.
         */
        get textContent() {
          if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
            return (0, algorithm_1.text_descendantTextContent)(this);
          } else if (util_1.Guard.isAttrNode(this)) {
            return this._value;
          } else if (util_1.Guard.isCharacterDataNode(this)) {
            return this._data;
          } else {
            return null;
          }
        }
        set textContent(value) {
          if (value === null) {
            value = "";
          }
          if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
            (0, algorithm_1.node_stringReplaceAll)(value, this);
          } else if (util_1.Guard.isAttrNode(this)) {
            (0, algorithm_1.attr_setAnExistingAttributeValue)(this, value);
          } else if (util_1.Guard.isCharacterDataNode(this)) {
            (0, algorithm_1.characterData_replaceData)(this, 0, (0, algorithm_1.tree_nodeLength)(this), value);
          }
        }
        /**
         * Puts all {@link Text} nodes in the full depth of the sub-tree
         * underneath this node into a "normal" form where only markup
         * (e.g., tags, comments, processing instructions, CDATA sections,
         * and entity references) separates {@link Text} nodes, i.e., there
         * are no adjacent Text nodes.
         */
        normalize() {
          const descendantNodes = [];
          let node = (0, algorithm_1.tree_getFirstDescendantNode)(this, false, false, (e) => util_1.Guard.isExclusiveTextNode(e));
          while (node !== null) {
            descendantNodes.push(node);
            node = (0, algorithm_1.tree_getNextDescendantNode)(this, node, false, false, (e) => util_1.Guard.isExclusiveTextNode(e));
          }
          for (let i = 0; i < descendantNodes.length; i++) {
            const node2 = descendantNodes[i];
            if (node2._parent === null)
              continue;
            let length = (0, algorithm_1.tree_nodeLength)(node2);
            if (length === 0) {
              (0, algorithm_1.mutation_remove)(node2, node2._parent);
              continue;
            }
            const textSiblings = [];
            let data = "";
            for (const sibling of (0, algorithm_1.text_contiguousExclusiveTextNodes)(node2)) {
              textSiblings.push(sibling);
              data += sibling._data;
            }
            (0, algorithm_1.characterData_replaceData)(node2, length, 0, data);
            if (DOMImpl_1.dom.rangeList.size !== 0) {
              let currentNode = node2._nextSibling;
              while (currentNode !== null && util_1.Guard.isExclusiveTextNode(currentNode)) {
                const cn = currentNode;
                const index = (0, algorithm_1.tree_index)(cn);
                for (const range of DOMImpl_1.dom.rangeList) {
                  if (range._start[0] === cn) {
                    range._start[0] = node2;
                    range._start[1] += length;
                  }
                  if (range._end[0] === cn) {
                    range._end[0] = node2;
                    range._end[1] += length;
                  }
                  if (range._start[0] === cn._parent && range._start[1] === index) {
                    range._start[0] = node2;
                    range._start[1] = length;
                  }
                  if (range._end[0] === cn._parent && range._end[1] === index) {
                    range._end[0] = node2;
                    range._end[1] = length;
                  }
                }
                length += (0, algorithm_1.tree_nodeLength)(currentNode);
                currentNode = currentNode._nextSibling;
              }
            }
            for (let i2 = 0; i2 < textSiblings.length; i2++) {
              const sibling = textSiblings[i2];
              if (sibling._parent === null)
                continue;
              (0, algorithm_1.mutation_remove)(sibling, sibling._parent);
            }
          }
        }
        /**
         * Returns a duplicate of this node, i.e., serves as a generic copy
         * constructor for nodes. The duplicate node has no parent
         * ({@link parentNode} returns `null`).
         *
         * @param deep - if `true`, recursively clone the subtree under the
         * specified node. If `false`, clone only the node itself (and its
         * attributes, if it is an {@link Element}).
         */
        cloneNode(deep = false) {
          if (util_1.Guard.isShadowRoot(this))
            throw new DOMException_1.NotSupportedError();
          return (0, algorithm_1.node_clone)(this, null, deep);
        }
        /**
         * Determines if the given node is equal to this one.
         *
         * @param node - the node to compare with
         */
        isEqualNode(node = null) {
          return node !== null && (0, algorithm_1.node_equals)(this, node);
        }
        /**
         * Determines if the given node is reference equal to this one.
         *
         * @param node - the node to compare with
         */
        isSameNode(node = null) {
          return this === node;
        }
        /**
         * Returns a bitmask indicating the position of the given `node`
         * relative to this node.
         */
        compareDocumentPosition(other) {
          if (other === this)
            return interfaces_1.Position.SameNode;
          let node1 = other;
          let node2 = this;
          let attr1 = null;
          let attr2 = null;
          if (util_1.Guard.isAttrNode(node1)) {
            attr1 = node1;
            node1 = attr1._element;
          }
          if (util_1.Guard.isAttrNode(node2)) {
            attr2 = node2;
            node2 = attr2._element;
            if (attr1 && node1 && node1 === node2) {
              for (let i = 0; i < node2._attributeList.length; i++) {
                const attr = node2._attributeList[i];
                if ((0, algorithm_1.node_equals)(attr, attr1)) {
                  return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Preceding;
                } else if ((0, algorithm_1.node_equals)(attr, attr2)) {
                  return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Following;
                }
              }
            }
          }
          if (node1 === null || node2 === null || (0, algorithm_1.tree_rootNode)(node1) !== (0, algorithm_1.tree_rootNode)(node2)) {
            return interfaces_1.Position.Disconnected | interfaces_1.Position.ImplementationSpecific | (DOMImpl_1.dom.compareCache.check(this, other) ? interfaces_1.Position.Preceding : interfaces_1.Position.Following);
          }
          if (!attr1 && (0, algorithm_1.tree_isAncestorOf)(node2, node1) || attr2 && node1 === node2) {
            return interfaces_1.Position.Contains | interfaces_1.Position.Preceding;
          }
          if (!attr2 && (0, algorithm_1.tree_isDescendantOf)(node2, node1) || attr1 && node1 === node2) {
            return interfaces_1.Position.ContainedBy | interfaces_1.Position.Following;
          }
          if ((0, algorithm_1.tree_isPreceding)(node2, node1))
            return interfaces_1.Position.Preceding;
          return interfaces_1.Position.Following;
        }
        /**
         * Returns `true` if given node is an inclusive descendant of this
         * node, and `false` otherwise (including when other node is `null`).
         *
         * @param other - the node to check
         */
        contains(other) {
          if (other === null)
            return false;
          return (0, algorithm_1.tree_isDescendantOf)(this, other, true);
        }
        /**
         * Returns the prefix for a given namespace URI, if present, and
         * `null` if not.
         *
         * @param namespace - the namespace to search
         */
        lookupPrefix(namespace) {
          if (!namespace)
            return null;
          if (util_1.Guard.isElementNode(this)) {
            return (0, algorithm_1.node_locateANamespacePrefix)(this, namespace);
          } else if (util_1.Guard.isDocumentNode(this)) {
            if (this.documentElement === null) {
              return null;
            } else {
              return (0, algorithm_1.node_locateANamespacePrefix)(this.documentElement, namespace);
            }
          } else if (util_1.Guard.isDocumentTypeNode(this) || util_1.Guard.isDocumentFragmentNode(this)) {
            return null;
          } else if (util_1.Guard.isAttrNode(this)) {
            if (this._element === null) {
              return null;
            } else {
              return (0, algorithm_1.node_locateANamespacePrefix)(this._element, namespace);
            }
          } else {
            if (this._parent !== null && util_1.Guard.isElementNode(this._parent)) {
              return (0, algorithm_1.node_locateANamespacePrefix)(this._parent, namespace);
            } else {
              return null;
            }
          }
        }
        /**
         * Returns the namespace URI for a given prefix if present, and `null`
         * if not.
         *
         * @param prefix - the prefix to search
         */
        lookupNamespaceURI(prefix) {
          return (0, algorithm_1.node_locateANamespace)(this, prefix || null);
        }
        /**
         * Returns `true` if the namespace is the default namespace on this
         * node or `false` if not.
         *
         * @param namespace - the namespace to check
         */
        isDefaultNamespace(namespace) {
          if (!namespace)
            namespace = null;
          const defaultNamespace = (0, algorithm_1.node_locateANamespace)(this, null);
          return defaultNamespace === namespace;
        }
        /**
         * Inserts the node `newChild` before the existing child node
         * `refChild`. If `refChild` is `null`, inserts `newChild` at the end
         * of the list of children.
         *
         * If `newChild` is a {@link DocumentFragment} object, all of its
         * children are inserted, in the same order, before `refChild`.
         *
         * If `newChild` is already in the tree, it is first removed.
         *
         * @param newChild - the node to insert
         * @param refChild - the node before which the new node must be
         *   inserted
         *
         * @returns the newly inserted child node
         */
        insertBefore(newChild, refChild) {
          return (0, algorithm_1.mutation_preInsert)(newChild, this, refChild);
        }
        /**
         * Adds the node `newChild` to the end of the list of children of this
         * node, and returns it. If `newChild` is already in the tree, it is
         * first removed.
         *
         * If `newChild` is a {@link DocumentFragment} object, the entire
         * contents of the document fragment are moved into the child list of
         * this node.
         *
         * @param newChild - the node to add
         *
         * @returns the newly inserted child node
         */
        appendChild(newChild) {
          return (0, algorithm_1.mutation_append)(newChild, this);
        }
        /**
         * Replaces the child node `oldChild` with `newChild` in the list of
         * children, and returns the `oldChild` node. If `newChild` is already
         * in the tree, it is first removed.
         *
         * @param newChild - the new node to put in the child list
         * @param oldChild - the node being replaced in the list
         *
         * @returns the removed child node
         */
        replaceChild(newChild, oldChild) {
          return (0, algorithm_1.mutation_replace)(oldChild, newChild, this);
        }
        /**
        * Removes the child node indicated by `oldChild` from the list of
        * children, and returns it.
        *
        * @param oldChild - the node being removed from the list
        *
        * @returns the removed child node
        */
        removeChild(oldChild) {
          return (0, algorithm_1.mutation_preRemove)(oldChild, this);
        }
        /**
         * Gets the parent event target for the given event.
         *
         * @param event - an event
         */
        _getTheParent(event) {
          if (util_1.Guard.isSlotable(this) && (0, algorithm_1.shadowTree_isAssigned)(this)) {
            return this._assignedSlot;
          } else {
            return this._parent;
          }
        }
      };
      __publicField(NodeImpl, "ELEMENT_NODE", 1);
      __publicField(NodeImpl, "ATTRIBUTE_NODE", 2);
      __publicField(NodeImpl, "TEXT_NODE", 3);
      __publicField(NodeImpl, "CDATA_SECTION_NODE", 4);
      __publicField(NodeImpl, "ENTITY_REFERENCE_NODE", 5);
      __publicField(NodeImpl, "ENTITY_NODE", 6);
      __publicField(NodeImpl, "PROCESSING_INSTRUCTION_NODE", 7);
      __publicField(NodeImpl, "COMMENT_NODE", 8);
      __publicField(NodeImpl, "DOCUMENT_NODE", 9);
      __publicField(NodeImpl, "DOCUMENT_TYPE_NODE", 10);
      __publicField(NodeImpl, "DOCUMENT_FRAGMENT_NODE", 11);
      __publicField(NodeImpl, "NOTATION_NODE", 12);
      __publicField(NodeImpl, "DOCUMENT_POSITION_DISCONNECTED", 1);
      __publicField(NodeImpl, "DOCUMENT_POSITION_PRECEDING", 2);
      __publicField(NodeImpl, "DOCUMENT_POSITION_FOLLOWING", 4);
      __publicField(NodeImpl, "DOCUMENT_POSITION_CONTAINS", 8);
      __publicField(NodeImpl, "DOCUMENT_POSITION_CONTAINED_BY", 16);
      __publicField(NodeImpl, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 32);
      exports.NodeImpl = NodeImpl;
      NodeImpl.prototype._children = new util_1.EmptySet();
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "ELEMENT_NODE", 1);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "ATTRIBUTE_NODE", 2);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "TEXT_NODE", 3);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "CDATA_SECTION_NODE", 4);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "ENTITY_REFERENCE_NODE", 5);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "ENTITY_NODE", 6);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "PROCESSING_INSTRUCTION_NODE", 7);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "COMMENT_NODE", 8);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_NODE", 9);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_TYPE_NODE", 10);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_FRAGMENT_NODE", 11);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "NOTATION_NODE", 12);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_DISCONNECTED", 1);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_PRECEDING", 2);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_FOLLOWING", 4);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINS", 8);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINED_BY", 16);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeImpl.prototype, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 32);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DocumentImpl.js
  var require_DocumentImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DocumentImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DocumentImpl = void 0;
      var DOMImpl_1 = require_DOMImpl();
      var interfaces_1 = require_interfaces2();
      var DOMException_1 = require_DOMException();
      var NodeImpl_1 = require_NodeImpl();
      var util_1 = require_util2();
      var util_2 = require_lib4();
      var infra_1 = require_lib5();
      var URLAlgorithm_1 = require_URLAlgorithm();
      var algorithm_1 = require_algorithm();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var DocumentImpl = class extends NodeImpl_1.NodeImpl {
        /**
         * Initializes a new instance of `Document`.
         */
        constructor() {
          super();
          __publicField(this, "_nodeType", interfaces_1.NodeType.Document);
          __publicField(this, "_children", /* @__PURE__ */ new Set());
          __publicField(this, "_encoding", {
            name: "UTF-8",
            labels: ["unicode-1-1-utf-8", "utf-8", "utf8"]
          });
          __publicField(this, "_contentType", "application/xml");
          __publicField(this, "_URL", {
            scheme: "about",
            username: "",
            password: "",
            host: null,
            port: null,
            path: ["blank"],
            query: null,
            fragment: null,
            _cannotBeABaseURLFlag: true,
            _blobURLEntry: null
          });
          __publicField(this, "_origin", null);
          __publicField(this, "_type", "xml");
          __publicField(this, "_mode", "no-quirks");
          __publicField(this, "_implementation");
          __publicField(this, "_documentElement", null);
          __publicField(this, "_hasNamespaces", false);
          __publicField(this, "_nodeDocumentOverwrite", null);
        }
        get _nodeDocument() {
          return this._nodeDocumentOverwrite || this;
        }
        set _nodeDocument(val) {
          this._nodeDocumentOverwrite = val;
        }
        /** @inheritdoc */
        get implementation() {
          return this._implementation || (this._implementation = (0, algorithm_1.create_domImplementation)(this));
        }
        /** @inheritdoc */
        get URL() {
          return (0, URLAlgorithm_1.urlSerializer)(this._URL);
        }
        /** @inheritdoc */
        get documentURI() {
          return this.URL;
        }
        /** @inheritdoc */
        get origin() {
          return "null";
        }
        /** @inheritdoc */
        get compatMode() {
          return this._mode === "quirks" ? "BackCompat" : "CSS1Compat";
        }
        /** @inheritdoc */
        get characterSet() {
          return this._encoding.name;
        }
        /** @inheritdoc */
        get charset() {
          return this._encoding.name;
        }
        /** @inheritdoc */
        get inputEncoding() {
          return this._encoding.name;
        }
        /** @inheritdoc */
        get contentType() {
          return this._contentType;
        }
        /** @inheritdoc */
        get doctype() {
          for (const child of this._children) {
            if (util_1.Guard.isDocumentTypeNode(child))
              return child;
          }
          return null;
        }
        /** @inheritdoc */
        get documentElement() {
          return this._documentElement;
        }
        /** @inheritdoc */
        getElementsByTagName(qualifiedName) {
          return (0, algorithm_1.node_listOfElementsWithQualifiedName)(qualifiedName, this);
        }
        /** @inheritdoc */
        getElementsByTagNameNS(namespace, localName) {
          return (0, algorithm_1.node_listOfElementsWithNamespace)(namespace, localName, this);
        }
        /** @inheritdoc */
        getElementsByClassName(classNames) {
          return (0, algorithm_1.node_listOfElementsWithClassNames)(classNames, this);
        }
        /** @inheritdoc */
        createElement(localName, options) {
          if (!(0, algorithm_1.xml_isName)(localName))
            throw new DOMException_1.InvalidCharacterError();
          if (this._type === "html")
            localName = localName.toLowerCase();
          let is = null;
          if (options !== void 0) {
            if ((0, util_2.isString)(options)) {
              is = options;
            } else {
              is = options.is;
            }
          }
          const namespace = this._type === "html" || this._contentType === "application/xhtml+xml" ? infra_1.namespace.HTML : null;
          return (0, algorithm_1.element_createAnElement)(this, localName, namespace, null, is, true);
        }
        /** @inheritdoc */
        createElementNS(namespace, qualifiedName, options) {
          return (0, algorithm_1.document_internalCreateElementNS)(this, namespace, qualifiedName, options);
        }
        /** @inheritdoc */
        createDocumentFragment() {
          return (0, algorithm_1.create_documentFragment)(this);
        }
        /** @inheritdoc */
        createTextNode(data) {
          return (0, algorithm_1.create_text)(this, data);
        }
        /** @inheritdoc */
        createCDATASection(data) {
          if (this._type === "html")
            throw new DOMException_1.NotSupportedError();
          if (data.indexOf("]]>") !== -1)
            throw new DOMException_1.InvalidCharacterError();
          return (0, algorithm_1.create_cdataSection)(this, data);
        }
        /** @inheritdoc */
        createComment(data) {
          return (0, algorithm_1.create_comment)(this, data);
        }
        /** @inheritdoc */
        createProcessingInstruction(target, data) {
          if (!(0, algorithm_1.xml_isName)(target))
            throw new DOMException_1.InvalidCharacterError();
          if (data.indexOf("?>") !== -1)
            throw new DOMException_1.InvalidCharacterError();
          return (0, algorithm_1.create_processingInstruction)(this, target, data);
        }
        /** @inheritdoc */
        importNode(node, deep = false) {
          if (util_1.Guard.isDocumentNode(node) || util_1.Guard.isShadowRoot(node))
            throw new DOMException_1.NotSupportedError();
          return (0, algorithm_1.node_clone)(node, this, deep);
        }
        /** @inheritdoc */
        adoptNode(node) {
          if (util_1.Guard.isDocumentNode(node))
            throw new DOMException_1.NotSupportedError();
          if (util_1.Guard.isShadowRoot(node))
            throw new DOMException_1.HierarchyRequestError();
          (0, algorithm_1.document_adopt)(node, this);
          return node;
        }
        /** @inheritdoc */
        createAttribute(localName) {
          if (!(0, algorithm_1.xml_isName)(localName))
            throw new DOMException_1.InvalidCharacterError();
          if (this._type === "html") {
            localName = localName.toLowerCase();
          }
          const attr = (0, algorithm_1.create_attr)(this, localName);
          return attr;
        }
        /** @inheritdoc */
        createAttributeNS(namespace, qualifiedName) {
          const [ns, prefix, localName] = (0, algorithm_1.namespace_validateAndExtract)(namespace, qualifiedName);
          const attr = (0, algorithm_1.create_attr)(this, localName);
          attr._namespace = ns;
          attr._namespacePrefix = prefix;
          return attr;
        }
        /** @inheritdoc */
        createEvent(eventInterface) {
          return (0, algorithm_1.event_createLegacyEvent)(eventInterface);
        }
        /** @inheritdoc */
        createRange() {
          const range = (0, algorithm_1.create_range)();
          range._start = [this, 0];
          range._end = [this, 0];
          return range;
        }
        /** @inheritdoc */
        createNodeIterator(root, whatToShow = interfaces_1.WhatToShow.All, filter = null) {
          const iterator = (0, algorithm_1.create_nodeIterator)(root, root, true);
          iterator._whatToShow = whatToShow;
          iterator._iteratorCollection = (0, algorithm_1.create_nodeList)(root);
          if ((0, util_2.isFunction)(filter)) {
            iterator._filter = (0, algorithm_1.create_nodeFilter)();
            iterator._filter.acceptNode = filter;
          } else {
            iterator._filter = filter;
          }
          return iterator;
        }
        /** @inheritdoc */
        createTreeWalker(root, whatToShow = interfaces_1.WhatToShow.All, filter = null) {
          const walker = (0, algorithm_1.create_treeWalker)(root, root);
          walker._whatToShow = whatToShow;
          if ((0, util_2.isFunction)(filter)) {
            walker._filter = (0, algorithm_1.create_nodeFilter)();
            walker._filter.acceptNode = filter;
          } else {
            walker._filter = filter;
          }
          return walker;
        }
        /**
         * Gets the parent event target for the given event.
         *
         * @param event - an event
         */
        _getTheParent(event) {
          if (event._type === "load") {
            return null;
          } else {
            return DOMImpl_1.dom.window;
          }
        }
        // MIXIN: NonElementParentNode
        /* istanbul ignore next */
        getElementById(elementId) {
          throw new Error("Mixin: NonElementParentNode not implemented.");
        }
        // MIXIN: DocumentOrShadowRoot
        // No elements
        // MIXIN: ParentNode
        /* istanbul ignore next */
        get children() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        get firstElementChild() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        get lastElementChild() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        get childElementCount() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        prepend(...nodes) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        append(...nodes) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        querySelector(selectors) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        querySelectorAll(selectors) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
      };
      exports.DocumentImpl = DocumentImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(DocumentImpl.prototype, "_nodeType", interfaces_1.NodeType.Document);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/XMLDocumentImpl.js
  var require_XMLDocumentImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/XMLDocumentImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLDocumentImpl = void 0;
      var DocumentImpl_1 = require_DocumentImpl();
      var XMLDocumentImpl = class extends DocumentImpl_1.DocumentImpl {
        /**
         * Initializes a new instance of `XMLDocument`.
         */
        constructor() {
          super();
        }
      };
      exports.XMLDocumentImpl = XMLDocumentImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/AbortControllerImpl.js
  var require_AbortControllerImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/AbortControllerImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbortControllerImpl = void 0;
      var algorithm_1 = require_algorithm();
      var AbortControllerImpl = class {
        /**
         * Initializes a new instance of `AbortController`.
         */
        constructor() {
          __publicField(this, "_signal");
          this._signal = (0, algorithm_1.create_abortSignal)();
        }
        /** @inheritdoc */
        get signal() {
          return this._signal;
        }
        /** @inheritdoc */
        abort() {
          (0, algorithm_1.abort_signalAbort)(this._signal);
        }
      };
      exports.AbortControllerImpl = AbortControllerImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/AbortSignalImpl.js
  var require_AbortSignalImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/AbortSignalImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbortSignalImpl = void 0;
      var EventTargetImpl_1 = require_EventTargetImpl();
      var algorithm_1 = require_algorithm();
      var AbortSignalImpl = class _AbortSignalImpl extends EventTargetImpl_1.EventTargetImpl {
        /**
         * Initializes a new instance of `AbortSignal`.
         */
        constructor() {
          super();
          __publicField(this, "_abortedFlag", false);
          __publicField(this, "_abortAlgorithms", /* @__PURE__ */ new Set());
        }
        /** @inheritdoc */
        get aborted() {
          return this._abortedFlag;
        }
        /** @inheritdoc */
        get onabort() {
          return (0, algorithm_1.event_getterEventHandlerIDLAttribute)(this, "onabort");
        }
        set onabort(val) {
          (0, algorithm_1.event_setterEventHandlerIDLAttribute)(this, "onabort", val);
        }
        /**
         * Creates a new `AbortSignal`.
         */
        static _create() {
          return new _AbortSignalImpl();
        }
      };
      exports.AbortSignalImpl = AbortSignalImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DocumentTypeImpl.js
  var require_DocumentTypeImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DocumentTypeImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DocumentTypeImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var NodeImpl_1 = require_NodeImpl();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var DocumentTypeImpl = class _DocumentTypeImpl extends NodeImpl_1.NodeImpl {
        /**
         * Initializes a new instance of `DocumentType`.
         *
         * @param name - name of the node
         * @param publicId - `PUBLIC` identifier
         * @param systemId - `SYSTEM` identifier
         */
        constructor(name, publicId, systemId) {
          super();
          __publicField(this, "_nodeType", interfaces_1.NodeType.DocumentType);
          __publicField(this, "_name", "");
          __publicField(this, "_publicId", "");
          __publicField(this, "_systemId", "");
          this._name = name;
          this._publicId = publicId;
          this._systemId = systemId;
        }
        /** @inheritdoc */
        get name() {
          return this._name;
        }
        /** @inheritdoc */
        get publicId() {
          return this._publicId;
        }
        /** @inheritdoc */
        get systemId() {
          return this._systemId;
        }
        // MIXIN: ChildNode
        /* istanbul ignore next */
        before(...nodes) {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        /* istanbul ignore next */
        after(...nodes) {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        /* istanbul ignore next */
        replaceWith(...nodes) {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        /* istanbul ignore next */
        remove() {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        /**
         * Creates a new `DocumentType`.
         *
         * @param document - owner document
         * @param name - name of the node
         * @param publicId - `PUBLIC` identifier
         * @param systemId - `SYSTEM` identifier
         */
        static _create(document2, name, publicId = "", systemId = "") {
          const node = new _DocumentTypeImpl(name, publicId, systemId);
          node._nodeDocument = document2;
          return node;
        }
      };
      exports.DocumentTypeImpl = DocumentTypeImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(DocumentTypeImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentType);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/ElementImpl.js
  var require_ElementImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/ElementImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ElementImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var NodeImpl_1 = require_NodeImpl();
      var DOMException_1 = require_DOMException();
      var infra_1 = require_lib5();
      var algorithm_1 = require_algorithm();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var ElementImpl = class _ElementImpl extends NodeImpl_1.NodeImpl {
        /**
         * Initializes a new instance of `Element`.
         */
        constructor() {
          super();
          __publicField(this, "_nodeType", interfaces_1.NodeType.Element);
          __publicField(this, "_children", /* @__PURE__ */ new Set());
          __publicField(this, "_namespace", null);
          __publicField(this, "_namespacePrefix", null);
          __publicField(this, "_localName", "");
          __publicField(this, "_customElementState", "undefined");
          __publicField(this, "_customElementDefinition", null);
          __publicField(this, "_is", null);
          __publicField(this, "_shadowRoot", null);
          __publicField(this, "_attributeList", (0, algorithm_1.create_namedNodeMap)(this));
          __publicField(this, "_uniqueIdentifier");
          __publicField(this, "_attributeChangeSteps", []);
          __publicField(this, "_name", "");
          __publicField(this, "_assignedSlot", null);
        }
        /** @inheritdoc */
        get namespaceURI() {
          return this._namespace;
        }
        /** @inheritdoc */
        get prefix() {
          return this._namespacePrefix;
        }
        /** @inheritdoc */
        get localName() {
          return this._localName;
        }
        /** @inheritdoc */
        get tagName() {
          return this._htmlUppercasedQualifiedName;
        }
        /** @inheritdoc */
        get id() {
          return (0, algorithm_1.element_getAnAttributeValue)(this, "id");
        }
        set id(value) {
          (0, algorithm_1.element_setAnAttributeValue)(this, "id", value);
        }
        /** @inheritdoc */
        get className() {
          return (0, algorithm_1.element_getAnAttributeValue)(this, "class");
        }
        set className(value) {
          (0, algorithm_1.element_setAnAttributeValue)(this, "class", value);
        }
        /** @inheritdoc */
        get classList() {
          let attr = (0, algorithm_1.element_getAnAttributeByName)("class", this);
          if (attr === null) {
            attr = (0, algorithm_1.create_attr)(this._nodeDocument, "class");
          }
          return (0, algorithm_1.create_domTokenList)(this, attr);
        }
        /** @inheritdoc */
        get slot() {
          return (0, algorithm_1.element_getAnAttributeValue)(this, "slot");
        }
        set slot(value) {
          (0, algorithm_1.element_setAnAttributeValue)(this, "slot", value);
        }
        /** @inheritdoc */
        hasAttributes() {
          return this._attributeList.length !== 0;
        }
        /** @inheritdoc */
        get attributes() {
          return this._attributeList;
        }
        /** @inheritdoc */
        getAttributeNames() {
          const names = [];
          for (const attr of this._attributeList) {
            names.push(attr._qualifiedName);
          }
          return names;
        }
        /** @inheritdoc */
        getAttribute(qualifiedName) {
          const attr = (0, algorithm_1.element_getAnAttributeByName)(qualifiedName, this);
          return attr ? attr._value : null;
        }
        /** @inheritdoc */
        getAttributeNS(namespace, localName) {
          const attr = (0, algorithm_1.element_getAnAttributeByNamespaceAndLocalName)(namespace, localName, this);
          return attr ? attr._value : null;
        }
        /** @inheritdoc */
        setAttribute(qualifiedName, value) {
          if (!(0, algorithm_1.xml_isName)(qualifiedName))
            throw new DOMException_1.InvalidCharacterError();
          if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
          }
          let attribute = null;
          for (let i = 0; i < this._attributeList.length; i++) {
            const attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
              attribute = attr;
              break;
            }
          }
          if (attribute === null) {
            attribute = (0, algorithm_1.create_attr)(this._nodeDocument, qualifiedName);
            attribute._value = value;
            (0, algorithm_1.element_append)(attribute, this);
            return;
          }
          (0, algorithm_1.element_change)(attribute, this, value);
        }
        /** @inheritdoc */
        setAttributeNS(namespace, qualifiedName, value) {
          const [ns, prefix, localName] = (0, algorithm_1.namespace_validateAndExtract)(namespace, qualifiedName);
          (0, algorithm_1.element_setAnAttributeValue)(this, localName, value, prefix, ns);
        }
        /** @inheritdoc */
        removeAttribute(qualifiedName) {
          (0, algorithm_1.element_removeAnAttributeByName)(qualifiedName, this);
        }
        /** @inheritdoc */
        removeAttributeNS(namespace, localName) {
          (0, algorithm_1.element_removeAnAttributeByNamespaceAndLocalName)(namespace, localName, this);
        }
        /** @inheritdoc */
        hasAttribute(qualifiedName) {
          if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
          }
          for (let i = 0; i < this._attributeList.length; i++) {
            const attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
              return true;
            }
          }
          return false;
        }
        /** @inheritdoc */
        toggleAttribute(qualifiedName, force) {
          if (!(0, algorithm_1.xml_isName)(qualifiedName))
            throw new DOMException_1.InvalidCharacterError();
          if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
          }
          let attribute = null;
          for (let i = 0; i < this._attributeList.length; i++) {
            const attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
              attribute = attr;
              break;
            }
          }
          if (attribute === null) {
            if (force === void 0 || force === true) {
              attribute = (0, algorithm_1.create_attr)(this._nodeDocument, qualifiedName);
              attribute._value = "";
              (0, algorithm_1.element_append)(attribute, this);
              return true;
            }
            return false;
          } else if (force === void 0 || force === false) {
            (0, algorithm_1.element_removeAnAttributeByName)(qualifiedName, this);
            return false;
          }
          return true;
        }
        /** @inheritdoc */
        hasAttributeNS(namespace, localName) {
          const ns = namespace || null;
          for (let i = 0; i < this._attributeList.length; i++) {
            const attr = this._attributeList[i];
            if (attr._namespace === ns && attr._localName === localName) {
              return true;
            }
          }
          return false;
        }
        /** @inheritdoc */
        getAttributeNode(qualifiedName) {
          return (0, algorithm_1.element_getAnAttributeByName)(qualifiedName, this);
        }
        /** @inheritdoc */
        getAttributeNodeNS(namespace, localName) {
          return (0, algorithm_1.element_getAnAttributeByNamespaceAndLocalName)(namespace, localName, this);
        }
        /** @inheritdoc */
        setAttributeNode(attr) {
          return (0, algorithm_1.element_setAnAttribute)(attr, this);
        }
        /** @inheritdoc */
        setAttributeNodeNS(attr) {
          return (0, algorithm_1.element_setAnAttribute)(attr, this);
        }
        /** @inheritdoc */
        removeAttributeNode(attr) {
          let found = false;
          for (let i = 0; i < this._attributeList.length; i++) {
            const attribute = this._attributeList[i];
            if (attribute === attr) {
              found = true;
              break;
            }
          }
          if (!found)
            throw new DOMException_1.NotFoundError();
          (0, algorithm_1.element_remove)(attr, this);
          return attr;
        }
        /** @inheritdoc */
        attachShadow(init) {
          if (this._namespace !== infra_1.namespace.HTML)
            throw new DOMException_1.NotSupportedError();
          if (!(0, algorithm_1.customElement_isValidCustomElementName)(this._localName) && !(0, algorithm_1.customElement_isValidShadowHostName)(this._localName))
            throw new DOMException_1.NotSupportedError();
          if ((0, algorithm_1.customElement_isValidCustomElementName)(this._localName) || this._is !== null) {
            const definition = (0, algorithm_1.customElement_lookUpACustomElementDefinition)(this._nodeDocument, this._namespace, this._localName, this._is);
            if (definition !== null && definition.disableShadow === true) {
              throw new DOMException_1.NotSupportedError();
            }
          }
          if (this._shadowRoot !== null)
            throw new DOMException_1.NotSupportedError();
          const shadow = (0, algorithm_1.create_shadowRoot)(this._nodeDocument, this);
          shadow._mode = init.mode;
          this._shadowRoot = shadow;
          return shadow;
        }
        /** @inheritdoc */
        get shadowRoot() {
          const shadow = this._shadowRoot;
          if (shadow === null || shadow.mode === "closed")
            return null;
          else
            return shadow;
        }
        /** @inheritdoc */
        closest(selectors) {
          throw new DOMException_1.NotImplementedError();
        }
        /** @inheritdoc */
        matches(selectors) {
          throw new DOMException_1.NotImplementedError();
        }
        /** @inheritdoc */
        webkitMatchesSelector(selectors) {
          return this.matches(selectors);
        }
        /** @inheritdoc */
        getElementsByTagName(qualifiedName) {
          return (0, algorithm_1.node_listOfElementsWithQualifiedName)(qualifiedName, this);
        }
        /** @inheritdoc */
        getElementsByTagNameNS(namespace, localName) {
          return (0, algorithm_1.node_listOfElementsWithNamespace)(namespace, localName, this);
        }
        /** @inheritdoc */
        getElementsByClassName(classNames) {
          return (0, algorithm_1.node_listOfElementsWithClassNames)(classNames, this);
        }
        /** @inheritdoc */
        insertAdjacentElement(where, element) {
          return (0, algorithm_1.element_insertAdjacent)(this, where, element);
        }
        /** @inheritdoc */
        insertAdjacentText(where, data) {
          const text = (0, algorithm_1.create_text)(this._nodeDocument, data);
          (0, algorithm_1.element_insertAdjacent)(this, where, text);
        }
        /**
         * Returns the qualified name.
         */
        get _qualifiedName() {
          return this._namespacePrefix ? this._namespacePrefix + ":" + this._localName : this._localName;
        }
        /**
         * Returns the upper-cased qualified name for a html element.
         */
        get _htmlUppercasedQualifiedName() {
          let qualifiedName = this._qualifiedName;
          if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toUpperCase();
          }
          return qualifiedName;
        }
        // MIXIN: ParentNode
        /* istanbul ignore next */
        get children() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        get firstElementChild() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        get lastElementChild() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        get childElementCount() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        prepend(...nodes) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        append(...nodes) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        querySelector(selectors) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        querySelectorAll(selectors) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        // MIXIN: NonDocumentTypeChildNode
        /* istanbul ignore next */
        get previousElementSibling() {
          throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
        }
        /* istanbul ignore next */
        get nextElementSibling() {
          throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
        }
        // MIXIN: ChildNode
        /* istanbul ignore next */
        before(...nodes) {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        /* istanbul ignore next */
        after(...nodes) {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        /* istanbul ignore next */
        replaceWith(...nodes) {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        /* istanbul ignore next */
        remove() {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        // MIXIN: Slotable
        /* istanbul ignore next */
        get assignedSlot() {
          throw new Error("Mixin: Slotable not implemented.");
        }
        /**
         * Creates a new `Element`.
         *
         * @param document - owner document
         * @param localName - local name
         * @param namespace - namespace
         * @param prefix - namespace prefix
         */
        static _create(document2, localName, namespace = null, namespacePrefix = null) {
          const node = new _ElementImpl();
          node._localName = localName;
          node._namespace = namespace;
          node._namespacePrefix = namespacePrefix;
          node._nodeDocument = document2;
          return node;
        }
      };
      exports.ElementImpl = ElementImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(ElementImpl.prototype, "_nodeType", interfaces_1.NodeType.Element);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DocumentFragmentImpl.js
  var require_DocumentFragmentImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DocumentFragmentImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DocumentFragmentImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var NodeImpl_1 = require_NodeImpl();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var DocumentFragmentImpl = class _DocumentFragmentImpl extends NodeImpl_1.NodeImpl {
        /**
         * Initializes a new instance of `DocumentFragment`.
         *
         * @param host - shadow root's host element
         */
        constructor(host = null) {
          super();
          __publicField(this, "_nodeType", interfaces_1.NodeType.DocumentFragment);
          __publicField(this, "_children", /* @__PURE__ */ new Set());
          __publicField(this, "_host");
          this._host = host;
        }
        // MIXIN: NonElementParentNode
        /* istanbul ignore next */
        getElementById(elementId) {
          throw new Error("Mixin: NonElementParentNode not implemented.");
        }
        // MIXIN: ParentNode
        /* istanbul ignore next */
        get children() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        get firstElementChild() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        get lastElementChild() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        get childElementCount() {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        prepend(...nodes) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        append(...nodes) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        querySelector(selectors) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /* istanbul ignore next */
        querySelectorAll(selectors) {
          throw new Error("Mixin: ParentNode not implemented.");
        }
        /**
         * Creates a new `DocumentFragment`.
         *
         * @param document - owner document
         * @param host - shadow root's host element
         */
        static _create(document2, host = null) {
          const node = new _DocumentFragmentImpl(host);
          node._nodeDocument = document2;
          return node;
        }
      };
      exports.DocumentFragmentImpl = DocumentFragmentImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(DocumentFragmentImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentFragment);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/ShadowRootImpl.js
  var require_ShadowRootImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/ShadowRootImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ShadowRootImpl = void 0;
      var DocumentFragmentImpl_1 = require_DocumentFragmentImpl();
      var util_1 = require_lib4();
      var algorithm_1 = require_algorithm();
      var ShadowRootImpl = class _ShadowRootImpl extends DocumentFragmentImpl_1.DocumentFragmentImpl {
        /**
         * Initializes a new instance of `ShadowRoot`.
         *
         * @param host - shadow root's host element
         * @param mode - shadow root's mode
         */
        constructor(host, mode) {
          super();
          __publicField(this, "_host");
          __publicField(this, "_mode");
          this._host = host;
          this._mode = mode;
        }
        /** @inheritdoc */
        get mode() {
          return this._mode;
        }
        /** @inheritdoc */
        get host() {
          return this._host;
        }
        /**
         * Gets the parent event target for the given event.
         *
         * @param event - an event
         */
        _getTheParent(event) {
          if (!event._composedFlag && !(0, util_1.isEmpty)(event._path) && (0, algorithm_1.tree_rootNode)(event._path[0].invocationTarget) === this) {
            return null;
          } else {
            return this._host;
          }
        }
        // MIXIN: DocumentOrShadowRoot
        // No elements
        /**
         * Creates a new `ShadowRoot`.
         *
         * @param document - owner document
         * @param host - shadow root's host element
         */
        static _create(document2, host) {
          return new _ShadowRootImpl(host, "closed");
        }
      };
      exports.ShadowRootImpl = ShadowRootImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/AttrImpl.js
  var require_AttrImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/AttrImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AttrImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var NodeImpl_1 = require_NodeImpl();
      var algorithm_1 = require_algorithm();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var AttrImpl = class _AttrImpl extends NodeImpl_1.NodeImpl {
        /**
         * Initializes a new instance of `Attr`.
         *
         * @param localName - local name
         */
        constructor(localName) {
          super();
          __publicField(this, "_nodeType", interfaces_1.NodeType.Attribute);
          __publicField(this, "_localName");
          __publicField(this, "_namespace", null);
          __publicField(this, "_namespacePrefix", null);
          __publicField(this, "_element", null);
          __publicField(this, "_value", "");
          /** @inheritdoc */
          __publicField(this, "specified");
          this._localName = localName;
        }
        /** @inheritdoc */
        get ownerElement() {
          return this._element;
        }
        /** @inheritdoc */
        get namespaceURI() {
          return this._namespace;
        }
        /** @inheritdoc */
        get prefix() {
          return this._namespacePrefix;
        }
        /** @inheritdoc */
        get localName() {
          return this._localName;
        }
        /** @inheritdoc */
        get name() {
          return this._qualifiedName;
        }
        /** @inheritdoc */
        get value() {
          return this._value;
        }
        set value(value) {
          (0, algorithm_1.attr_setAnExistingAttributeValue)(this, value);
        }
        /**
         * Returns the qualified name.
         */
        get _qualifiedName() {
          return this._namespacePrefix !== null ? this._namespacePrefix + ":" + this._localName : this._localName;
        }
        /**
         * Creates an `Attr`.
         *
         * @param document - owner document
         * @param localName - local name
         */
        static _create(document2, localName) {
          const node = new _AttrImpl(localName);
          node._nodeDocument = document2;
          return node;
        }
      };
      exports.AttrImpl = AttrImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(AttrImpl.prototype, "_nodeType", interfaces_1.NodeType.Attribute);
      (0, WebIDLAlgorithm_1.idl_defineConst)(AttrImpl.prototype, "specified", true);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/CharacterDataImpl.js
  var require_CharacterDataImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/CharacterDataImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CharacterDataImpl = void 0;
      var NodeImpl_1 = require_NodeImpl();
      var algorithm_1 = require_algorithm();
      var CharacterDataImpl = class extends NodeImpl_1.NodeImpl {
        /**
         * Initializes a new instance of `CharacterData`.
         *
         * @param data - the text content
         */
        constructor(data) {
          super();
          __publicField(this, "_data");
          this._data = data;
        }
        /** @inheritdoc */
        get data() {
          return this._data;
        }
        set data(value) {
          (0, algorithm_1.characterData_replaceData)(this, 0, this._data.length, value);
        }
        /** @inheritdoc */
        get length() {
          return this._data.length;
        }
        /** @inheritdoc */
        substringData(offset, count) {
          return (0, algorithm_1.characterData_substringData)(this, offset, count);
        }
        /** @inheritdoc */
        appendData(data) {
          return (0, algorithm_1.characterData_replaceData)(this, this._data.length, 0, data);
        }
        /** @inheritdoc */
        insertData(offset, data) {
          (0, algorithm_1.characterData_replaceData)(this, offset, 0, data);
        }
        /** @inheritdoc */
        deleteData(offset, count) {
          (0, algorithm_1.characterData_replaceData)(this, offset, count, "");
        }
        /** @inheritdoc */
        replaceData(offset, count, data) {
          (0, algorithm_1.characterData_replaceData)(this, offset, count, data);
        }
        // MIXIN: NonDocumentTypeChildNode
        /* istanbul ignore next */
        get previousElementSibling() {
          throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
        }
        /* istanbul ignore next */
        get nextElementSibling() {
          throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
        }
        // MIXIN: ChildNode
        /* istanbul ignore next */
        before(...nodes) {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        /* istanbul ignore next */
        after(...nodes) {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        /* istanbul ignore next */
        replaceWith(...nodes) {
          throw new Error("Mixin: ChildNode not implemented.");
        }
        /* istanbul ignore next */
        remove() {
          throw new Error("Mixin: ChildNode not implemented.");
        }
      };
      exports.CharacterDataImpl = CharacterDataImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/TextImpl.js
  var require_TextImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/TextImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TextImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var CharacterDataImpl_1 = require_CharacterDataImpl();
      var algorithm_1 = require_algorithm();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var TextImpl = class _TextImpl extends CharacterDataImpl_1.CharacterDataImpl {
        /**
         * Initializes a new instance of `Text`.
         *
         * @param data - the text content
         */
        constructor(data = "") {
          super(data);
          __publicField(this, "_nodeType", interfaces_1.NodeType.Text);
          __publicField(this, "_name", "");
          __publicField(this, "_assignedSlot", null);
        }
        /** @inheritdoc */
        get wholeText() {
          let text = "";
          for (const node of (0, algorithm_1.text_contiguousTextNodes)(this, true)) {
            text = text + node._data;
          }
          return text;
        }
        /** @inheritdoc */
        splitText(offset) {
          return (0, algorithm_1.text_split)(this, offset);
        }
        // MIXIN: Slotable
        /* istanbul ignore next */
        get assignedSlot() {
          throw new Error("Mixin: Slotable not implemented.");
        }
        /**
         * Creates a `Text`.
         *
         * @param document - owner document
         * @param data - the text content
         */
        static _create(document2, data = "") {
          const node = new _TextImpl(data);
          node._nodeDocument = document2;
          return node;
        }
      };
      exports.TextImpl = TextImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(TextImpl.prototype, "_nodeType", interfaces_1.NodeType.Text);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/CDATASectionImpl.js
  var require_CDATASectionImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/CDATASectionImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CDATASectionImpl = void 0;
      var TextImpl_1 = require_TextImpl();
      var interfaces_1 = require_interfaces2();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var CDATASectionImpl = class _CDATASectionImpl extends TextImpl_1.TextImpl {
        /**
         * Initializes a new instance of `CDATASection`.
         *
         * @param data - node contents
         */
        constructor(data) {
          super(data);
          __publicField(this, "_nodeType", interfaces_1.NodeType.CData);
        }
        /**
         * Creates a new `CDATASection`.
         *
         * @param document - owner document
         * @param data - node contents
         */
        static _create(document2, data = "") {
          const node = new _CDATASectionImpl(data);
          node._nodeDocument = document2;
          return node;
        }
      };
      exports.CDATASectionImpl = CDATASectionImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(CDATASectionImpl.prototype, "_nodeType", interfaces_1.NodeType.CData);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/CommentImpl.js
  var require_CommentImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/CommentImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CommentImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var CharacterDataImpl_1 = require_CharacterDataImpl();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var CommentImpl = class _CommentImpl extends CharacterDataImpl_1.CharacterDataImpl {
        /**
         * Initializes a new instance of `Comment`.
         *
         * @param data - the text content
         */
        constructor(data = "") {
          super(data);
          __publicField(this, "_nodeType", interfaces_1.NodeType.Comment);
        }
        /**
         * Creates a new `Comment`.
         *
         * @param document - owner document
         * @param data - node contents
         */
        static _create(document2, data = "") {
          const node = new _CommentImpl(data);
          node._nodeDocument = document2;
          return node;
        }
      };
      exports.CommentImpl = CommentImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(CommentImpl.prototype, "_nodeType", interfaces_1.NodeType.Comment);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/ProcessingInstructionImpl.js
  var require_ProcessingInstructionImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/ProcessingInstructionImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProcessingInstructionImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var CharacterDataImpl_1 = require_CharacterDataImpl();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var ProcessingInstructionImpl = class _ProcessingInstructionImpl extends CharacterDataImpl_1.CharacterDataImpl {
        /**
         * Initializes a new instance of `ProcessingInstruction`.
         */
        constructor(target, data) {
          super(data);
          __publicField(this, "_nodeType", interfaces_1.NodeType.ProcessingInstruction);
          __publicField(this, "_target");
          this._target = target;
        }
        /**
         * Gets the target of the {@link ProcessingInstruction} node.
         */
        get target() {
          return this._target;
        }
        /**
         * Creates a new `ProcessingInstruction`.
         *
         * @param document - owner document
         * @param target - instruction target
         * @param data - node contents
         */
        static _create(document2, target, data) {
          const node = new _ProcessingInstructionImpl(target, data);
          node._nodeDocument = document2;
          return node;
        }
      };
      exports.ProcessingInstructionImpl = ProcessingInstructionImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(ProcessingInstructionImpl.prototype, "_nodeType", interfaces_1.NodeType.ProcessingInstruction);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/HTMLCollectionImpl.js
  var require_HTMLCollectionImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/HTMLCollectionImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HTMLCollectionImpl = void 0;
      var infra_1 = require_lib5();
      var algorithm_1 = require_algorithm();
      var util_1 = require_util2();
      var util_2 = require_lib4();
      var _HTMLCollectionImpl = class _HTMLCollectionImpl {
        /**
         * Initializes a new instance of `HTMLCollection`.
         *
         * @param root - root node
         * @param filter - node filter
         */
        constructor(root, filter) {
          __publicField(this, "_live", true);
          __publicField(this, "_root");
          __publicField(this, "_filter");
          this._root = root;
          this._filter = filter;
          return new Proxy(this, this);
        }
        /** @inheritdoc */
        get length() {
          let count = 0;
          let node = (0, algorithm_1.tree_getFirstDescendantNode)(this._root, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
          while (node !== null) {
            count++;
            node = (0, algorithm_1.tree_getNextDescendantNode)(this._root, node, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
          }
          return count;
        }
        /** @inheritdoc */
        item(index) {
          let i = 0;
          let node = (0, algorithm_1.tree_getFirstDescendantNode)(this._root, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
          while (node !== null) {
            if (i === index)
              return node;
            else
              i++;
            node = (0, algorithm_1.tree_getNextDescendantNode)(this._root, node, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
          }
          return null;
        }
        /** @inheritdoc */
        namedItem(key) {
          if (key === "")
            return null;
          let ele = (0, algorithm_1.tree_getFirstDescendantNode)(this._root, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
          while (ele != null) {
            if (ele._uniqueIdentifier === key) {
              return ele;
            } else if (ele._namespace === infra_1.namespace.HTML) {
              for (let i = 0; i < ele._attributeList.length; i++) {
                const attr = ele._attributeList[i];
                if (attr._localName === "name" && attr._namespace === null && attr._namespacePrefix === null && attr._value === key)
                  return ele;
              }
            }
            ele = (0, algorithm_1.tree_getNextDescendantNode)(this._root, ele, false, false, (e) => util_1.Guard.isElementNode(e) && this._filter(e));
          }
          return null;
        }
        /** @inheritdoc */
        [Symbol.iterator]() {
          const root = this._root;
          const filter = this._filter;
          let currentNode = (0, algorithm_1.tree_getFirstDescendantNode)(root, false, false, (e) => util_1.Guard.isElementNode(e) && filter(e));
          return {
            next() {
              if (currentNode === null) {
                return { done: true, value: null };
              } else {
                const result = { done: false, value: currentNode };
                currentNode = (0, algorithm_1.tree_getNextDescendantNode)(root, currentNode, false, false, (e) => util_1.Guard.isElementNode(e) && filter(e));
                return result;
              }
            }
          };
        }
        /**
         * Implements a proxy get trap to provide array-like access.
         */
        get(target, key, receiver) {
          if (!(0, util_2.isString)(key) || _HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {
            return Reflect.get(target, key, receiver);
          }
          const index = Number(key);
          if (isNaN(index)) {
            return target.namedItem(key) || void 0;
          } else {
            return target.item(index) || void 0;
          }
        }
        /**
         * Implements a proxy set trap to provide array-like access.
         */
        set(target, key, value, receiver) {
          if (!(0, util_2.isString)(key) || _HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {
            return Reflect.set(target, key, value, receiver);
          }
          const index = Number(key);
          const node = isNaN(index) ? target.namedItem(key) || void 0 : target.item(index) || void 0;
          if (node && node._parent) {
            (0, algorithm_1.mutation_replace)(node, value, node._parent);
            return true;
          } else {
            return false;
          }
        }
        /**
         * Creates a new `HTMLCollection`.
         *
         * @param root - root node
         * @param filter - node filter
         */
        static _create(root, filter = (() => true)) {
          return new _HTMLCollectionImpl(root, filter);
        }
      };
      __publicField(_HTMLCollectionImpl, "reservedNames", [
        "_root",
        "_live",
        "_filter",
        "length",
        "item",
        "namedItem",
        "get",
        "set"
      ]);
      var HTMLCollectionImpl = _HTMLCollectionImpl;
      exports.HTMLCollectionImpl = HTMLCollectionImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NodeListImpl.js
  var require_NodeListImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NodeListImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NodeListImpl = void 0;
      var DOMImpl_1 = require_DOMImpl();
      var util_1 = require_lib4();
      var algorithm_1 = require_algorithm();
      var NodeListImpl = class _NodeListImpl {
        /**
         * Initializes a new instance of `NodeList`.
         *
         * @param root - root node
         */
        constructor(root) {
          __publicField(this, "_live", true);
          __publicField(this, "_root");
          __publicField(this, "_filter", null);
          __publicField(this, "_length", 0);
          this._root = root;
          return new Proxy(this, this);
        }
        /** @inheritdoc */
        get length() {
          return this._root._children.size;
        }
        /** @inheritdoc */
        item(index) {
          if (index < 0 || index > this.length - 1)
            return null;
          if (index < this.length / 2) {
            let i = 0;
            let node = this._root._firstChild;
            while (node !== null && i !== index) {
              node = node._nextSibling;
              i++;
            }
            return node;
          } else {
            let i = this.length - 1;
            let node = this._root._lastChild;
            while (node !== null && i !== index) {
              node = node._previousSibling;
              i--;
            }
            return node;
          }
        }
        /** @inheritdoc */
        keys() {
          return {
            [Symbol.iterator]: function() {
              let index = 0;
              return {
                next: function() {
                  if (index === this.length) {
                    return { done: true, value: null };
                  } else {
                    return { done: false, value: index++ };
                  }
                }.bind(this)
              };
            }.bind(this)
          };
        }
        /** @inheritdoc */
        values() {
          return {
            [Symbol.iterator]: function() {
              const it = this[Symbol.iterator]();
              return {
                next() {
                  return it.next();
                }
              };
            }.bind(this)
          };
        }
        /** @inheritdoc */
        entries() {
          return {
            [Symbol.iterator]: function() {
              const it = this[Symbol.iterator]();
              let index = 0;
              return {
                next() {
                  const itResult = it.next();
                  if (itResult.done) {
                    return { done: true, value: null };
                  } else {
                    return { done: false, value: [index++, itResult.value] };
                  }
                }
              };
            }.bind(this)
          };
        }
        /** @inheritdoc */
        [Symbol.iterator]() {
          return this._root._children[Symbol.iterator]();
        }
        /** @inheritdoc */
        forEach(callback, thisArg) {
          if (thisArg === void 0) {
            thisArg = DOMImpl_1.dom.window;
          }
          let index = 0;
          for (const node of this._root._children) {
            callback.call(thisArg, node, index++, this);
          }
        }
        /**
         * Implements a proxy get trap to provide array-like access.
         */
        get(target, key, receiver) {
          if (!(0, util_1.isString)(key)) {
            return Reflect.get(target, key, receiver);
          }
          const index = Number(key);
          if (isNaN(index)) {
            return Reflect.get(target, key, receiver);
          }
          return target.item(index) || void 0;
        }
        /**
         * Implements a proxy set trap to provide array-like access.
         */
        set(target, key, value, receiver) {
          if (!(0, util_1.isString)(key)) {
            return Reflect.set(target, key, value, receiver);
          }
          const index = Number(key);
          if (isNaN(index)) {
            return Reflect.set(target, key, value, receiver);
          }
          const node = target.item(index) || void 0;
          if (!node)
            return false;
          if (node._parent) {
            (0, algorithm_1.mutation_replace)(node, value, node._parent);
            return true;
          } else {
            return false;
          }
        }
        /**
         * Creates a new `NodeList`.
         *
         * @param root - root node
         */
        static _create(root) {
          return new _NodeListImpl(root);
        }
      };
      exports.NodeListImpl = NodeListImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NodeListStaticImpl.js
  var require_NodeListStaticImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NodeListStaticImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NodeListStaticImpl = void 0;
      var DOMImpl_1 = require_DOMImpl();
      var util_1 = require_lib4();
      var NodeListStaticImpl = class _NodeListStaticImpl {
        /**
         * Initializes a new instance of `NodeList`.
         *
         * @param root - root node
         */
        constructor(root) {
          __publicField(this, "_live", false);
          __publicField(this, "_root");
          __publicField(this, "_filter");
          __publicField(this, "_items", []);
          __publicField(this, "_length", 0);
          this._root = root;
          this._items = [];
          this._filter = function(node) {
            return true;
          };
          return new Proxy(this, this);
        }
        /** @inheritdoc */
        get length() {
          return this._items.length;
        }
        /** @inheritdoc */
        item(index) {
          if (index < 0 || index > this.length - 1)
            return null;
          return this._items[index];
        }
        /** @inheritdoc */
        keys() {
          return {
            [Symbol.iterator]: function() {
              let index = 0;
              return {
                next: function() {
                  if (index === this.length) {
                    return { done: true, value: null };
                  } else {
                    return { done: false, value: index++ };
                  }
                }.bind(this)
              };
            }.bind(this)
          };
        }
        /** @inheritdoc */
        values() {
          return {
            [Symbol.iterator]: function() {
              const it = this[Symbol.iterator]();
              return {
                next() {
                  return it.next();
                }
              };
            }.bind(this)
          };
        }
        /** @inheritdoc */
        entries() {
          return {
            [Symbol.iterator]: function() {
              const it = this[Symbol.iterator]();
              let index = 0;
              return {
                next() {
                  const itResult = it.next();
                  if (itResult.done) {
                    return { done: true, value: null };
                  } else {
                    return { done: false, value: [index++, itResult.value] };
                  }
                }
              };
            }.bind(this)
          };
        }
        /** @inheritdoc */
        [Symbol.iterator]() {
          const it = this._items[Symbol.iterator]();
          return {
            next() {
              return it.next();
            }
          };
        }
        /** @inheritdoc */
        forEach(callback, thisArg) {
          if (thisArg === void 0) {
            thisArg = DOMImpl_1.dom.window;
          }
          let index = 0;
          for (const node of this._items) {
            callback.call(thisArg, node, index++, this);
          }
        }
        /**
         * Implements a proxy get trap to provide array-like access.
         */
        get(target, key, receiver) {
          if (!(0, util_1.isString)(key)) {
            return Reflect.get(target, key, receiver);
          }
          const index = Number(key);
          if (isNaN(index)) {
            return Reflect.get(target, key, receiver);
          }
          return target._items[index] || void 0;
        }
        /**
         * Implements a proxy set trap to provide array-like access.
         */
        set(target, key, value, receiver) {
          if (!(0, util_1.isString)(key)) {
            return Reflect.set(target, key, value, receiver);
          }
          const index = Number(key);
          if (isNaN(index)) {
            return Reflect.set(target, key, value, receiver);
          }
          if (index >= 0 && index < target._items.length) {
            target._items[index] = value;
            return true;
          } else {
            return false;
          }
        }
        /**
         * Creates a new `NodeList`.
         *
         * @param root - root node
         * @param items - a list of items to initialize the list
         */
        static _create(root, items) {
          const list = new _NodeListStaticImpl(root);
          list._items = items;
          return list;
        }
      };
      exports.NodeListStaticImpl = NodeListStaticImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NamedNodeMapImpl.js
  var require_NamedNodeMapImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NamedNodeMapImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NamedNodeMapImpl = void 0;
      var DOMException_1 = require_DOMException();
      var algorithm_1 = require_algorithm();
      var NamedNodeMapImpl = class _NamedNodeMapImpl extends Array {
        /**
         * Initializes a new instance of `NamedNodeMap`.
         *
         * @param element - parent element
         */
        constructor(element) {
          super();
          __publicField(this, "_element");
          this._element = element;
          Object.setPrototypeOf(this, _NamedNodeMapImpl.prototype);
        }
        _asArray() {
          return this;
        }
        /** @inheritdoc */
        item(index) {
          return this[index] || null;
        }
        /** @inheritdoc */
        getNamedItem(qualifiedName) {
          return (0, algorithm_1.element_getAnAttributeByName)(qualifiedName, this._element);
        }
        /** @inheritdoc */
        getNamedItemNS(namespace, localName) {
          return (0, algorithm_1.element_getAnAttributeByNamespaceAndLocalName)(namespace || "", localName, this._element);
        }
        /** @inheritdoc */
        setNamedItem(attr) {
          return (0, algorithm_1.element_setAnAttribute)(attr, this._element);
        }
        /** @inheritdoc */
        setNamedItemNS(attr) {
          return (0, algorithm_1.element_setAnAttribute)(attr, this._element);
        }
        /** @inheritdoc */
        removeNamedItem(qualifiedName) {
          const attr = (0, algorithm_1.element_removeAnAttributeByName)(qualifiedName, this._element);
          if (attr === null)
            throw new DOMException_1.NotFoundError();
          return attr;
        }
        /** @inheritdoc */
        removeNamedItemNS(namespace, localName) {
          const attr = (0, algorithm_1.element_removeAnAttributeByNamespaceAndLocalName)(namespace || "", localName, this._element);
          if (attr === null)
            throw new DOMException_1.NotFoundError();
          return attr;
        }
        /**
         * Creates a new `NamedNodeMap`.
         *
         * @param element - parent element
         */
        static _create(element) {
          return new _NamedNodeMapImpl(element);
        }
      };
      exports.NamedNodeMapImpl = NamedNodeMapImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/AbstractRangeImpl.js
  var require_AbstractRangeImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/AbstractRangeImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AbstractRangeImpl = void 0;
      var AbstractRangeImpl = class {
        get _startNode() {
          return this._start[0];
        }
        get _startOffset() {
          return this._start[1];
        }
        get _endNode() {
          return this._end[0];
        }
        get _endOffset() {
          return this._end[1];
        }
        get _collapsed() {
          return this._start[0] === this._end[0] && this._start[1] === this._end[1];
        }
        /** @inheritdoc */
        get startContainer() {
          return this._startNode;
        }
        /** @inheritdoc */
        get startOffset() {
          return this._startOffset;
        }
        /** @inheritdoc */
        get endContainer() {
          return this._endNode;
        }
        /** @inheritdoc */
        get endOffset() {
          return this._endOffset;
        }
        /** @inheritdoc */
        get collapsed() {
          return this._collapsed;
        }
      };
      exports.AbstractRangeImpl = AbstractRangeImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/RangeImpl.js
  var require_RangeImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/RangeImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RangeImpl = void 0;
      var DOMImpl_1 = require_DOMImpl();
      var interfaces_1 = require_interfaces2();
      var AbstractRangeImpl_1 = require_AbstractRangeImpl();
      var DOMException_1 = require_DOMException();
      var algorithm_1 = require_algorithm();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var util_1 = require_util2();
      var _RangeImpl = class _RangeImpl extends AbstractRangeImpl_1.AbstractRangeImpl {
        /**
         * Initializes a new instance of `Range`.
         */
        constructor() {
          super();
          __publicField(this, "START_TO_START", 0);
          __publicField(this, "START_TO_END", 1);
          __publicField(this, "END_TO_END", 2);
          __publicField(this, "END_TO_START", 3);
          __publicField(this, "_start");
          __publicField(this, "_end");
          const doc = DOMImpl_1.dom.window._associatedDocument;
          this._start = [doc, 0];
          this._end = [doc, 0];
          DOMImpl_1.dom.rangeList.add(this);
        }
        /** @inheritdoc */
        get commonAncestorContainer() {
          let container = this._start[0];
          while (!(0, algorithm_1.tree_isAncestorOf)(this._end[0], container, true)) {
            if (container._parent === null) {
              throw new Error("Parent node  is null.");
            }
            container = container._parent;
          }
          return container;
        }
        /** @inheritdoc */
        setStart(node, offset) {
          (0, algorithm_1.range_setTheStart)(this, node, offset);
        }
        /** @inheritdoc */
        setEnd(node, offset) {
          (0, algorithm_1.range_setTheEnd)(this, node, offset);
        }
        /** @inheritdoc */
        setStartBefore(node) {
          let parent = node._parent;
          if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
          (0, algorithm_1.range_setTheStart)(this, parent, (0, algorithm_1.tree_index)(node));
        }
        /** @inheritdoc */
        setStartAfter(node) {
          let parent = node._parent;
          if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
          (0, algorithm_1.range_setTheStart)(this, parent, (0, algorithm_1.tree_index)(node) + 1);
        }
        /** @inheritdoc */
        setEndBefore(node) {
          let parent = node._parent;
          if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
          (0, algorithm_1.range_setTheEnd)(this, parent, (0, algorithm_1.tree_index)(node));
        }
        /** @inheritdoc */
        setEndAfter(node) {
          let parent = node._parent;
          if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
          (0, algorithm_1.range_setTheEnd)(this, parent, (0, algorithm_1.tree_index)(node) + 1);
        }
        /** @inheritdoc */
        collapse(toStart) {
          if (toStart) {
            this._end = this._start;
          } else {
            this._start = this._end;
          }
        }
        /** @inheritdoc */
        selectNode(node) {
          (0, algorithm_1.range_select)(node, this);
        }
        /** @inheritdoc */
        selectNodeContents(node) {
          if (util_1.Guard.isDocumentTypeNode(node))
            throw new DOMException_1.InvalidNodeTypeError();
          const length = (0, algorithm_1.tree_nodeLength)(node);
          this._start = [node, 0];
          this._end = [node, length];
        }
        /** @inheritdoc */
        compareBoundaryPoints(how, sourceRange) {
          if (how !== interfaces_1.HowToCompare.StartToStart && how !== interfaces_1.HowToCompare.StartToEnd && how !== interfaces_1.HowToCompare.EndToEnd && how !== interfaces_1.HowToCompare.EndToStart)
            throw new DOMException_1.NotSupportedError();
          if ((0, algorithm_1.range_root)(this) !== (0, algorithm_1.range_root)(sourceRange))
            throw new DOMException_1.WrongDocumentError();
          let thisPoint;
          let otherPoint;
          switch (how) {
            case interfaces_1.HowToCompare.StartToStart:
              thisPoint = this._start;
              otherPoint = sourceRange._start;
              break;
            case interfaces_1.HowToCompare.StartToEnd:
              thisPoint = this._end;
              otherPoint = sourceRange._start;
              break;
            case interfaces_1.HowToCompare.EndToEnd:
              thisPoint = this._end;
              otherPoint = sourceRange._end;
              break;
            case interfaces_1.HowToCompare.EndToStart:
              thisPoint = this._start;
              otherPoint = sourceRange._end;
              break;
            /* istanbul ignore next */
            default:
              throw new DOMException_1.NotSupportedError();
          }
          const position = (0, algorithm_1.boundaryPoint_position)(thisPoint, otherPoint);
          if (position === interfaces_1.BoundaryPosition.Before) {
            return -1;
          } else if (position === interfaces_1.BoundaryPosition.After) {
            return 1;
          } else {
            return 0;
          }
        }
        /** @inheritdoc */
        deleteContents() {
          if ((0, algorithm_1.range_collapsed)(this))
            return;
          const originalStartNode = this._startNode;
          const originalStartOffset = this._startOffset;
          const originalEndNode = this._endNode;
          const originalEndOffset = this._endOffset;
          if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
            (0, algorithm_1.characterData_replaceData)(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, "");
            return;
          }
          const nodesToRemove = [];
          for (const node of (0, algorithm_1.range_getContainedNodes)(this)) {
            const parent = node._parent;
            if (parent !== null && (0, algorithm_1.range_isContained)(parent, this)) {
              continue;
            }
            nodesToRemove.push(node);
          }
          let newNode;
          let newOffset;
          if ((0, algorithm_1.tree_isAncestorOf)(originalEndNode, originalStartNode, true)) {
            newNode = originalStartNode;
            newOffset = originalStartOffset;
          } else {
            let referenceNode = originalStartNode;
            while (referenceNode._parent !== null && !(0, algorithm_1.tree_isAncestorOf)(originalEndNode, referenceNode._parent, true)) {
              referenceNode = referenceNode._parent;
            }
            if (referenceNode._parent === null) {
              throw new Error("Parent node is null.");
            }
            newNode = referenceNode._parent;
            newOffset = (0, algorithm_1.tree_index)(referenceNode) + 1;
          }
          if (util_1.Guard.isCharacterDataNode(originalStartNode)) {
            (0, algorithm_1.characterData_replaceData)(originalStartNode, originalStartOffset, (0, algorithm_1.tree_nodeLength)(originalStartNode) - originalStartOffset, "");
          }
          for (const node of nodesToRemove) {
            if (node._parent) {
              (0, algorithm_1.mutation_remove)(node, node._parent);
            }
          }
          if (util_1.Guard.isCharacterDataNode(originalEndNode)) {
            (0, algorithm_1.characterData_replaceData)(originalEndNode, 0, originalEndOffset, "");
          }
          this._start = [newNode, newOffset];
          this._end = [newNode, newOffset];
        }
        /** @inheritdoc */
        extractContents() {
          return (0, algorithm_1.range_extract)(this);
        }
        /** @inheritdoc */
        cloneContents() {
          return (0, algorithm_1.range_cloneTheContents)(this);
        }
        /** @inheritdoc */
        insertNode(node) {
          return (0, algorithm_1.range_insert)(node, this);
        }
        /** @inheritdoc */
        surroundContents(newParent) {
          for (const node of (0, algorithm_1.range_getPartiallyContainedNodes)(this)) {
            if (!util_1.Guard.isTextNode(node)) {
              throw new DOMException_1.InvalidStateError();
            }
          }
          if (util_1.Guard.isDocumentNode(newParent) || util_1.Guard.isDocumentTypeNode(newParent) || util_1.Guard.isDocumentFragmentNode(newParent)) {
            throw new DOMException_1.InvalidNodeTypeError();
          }
          const fragment3 = (0, algorithm_1.range_extract)(this);
          if (newParent._children.size !== 0) {
            (0, algorithm_1.mutation_replaceAll)(null, newParent);
          }
          (0, algorithm_1.range_insert)(newParent, this);
          (0, algorithm_1.mutation_append)(fragment3, newParent);
          (0, algorithm_1.range_select)(newParent, this);
        }
        /** @inheritdoc */
        cloneRange() {
          return (0, algorithm_1.create_range)(this._start, this._end);
        }
        /** @inheritdoc */
        detach() {
          DOMImpl_1.dom.rangeList.delete(this);
        }
        /** @inheritdoc */
        isPointInRange(node, offset) {
          if ((0, algorithm_1.tree_rootNode)(node) !== (0, algorithm_1.range_root)(this)) {
            return false;
          }
          if (util_1.Guard.isDocumentTypeNode(node))
            throw new DOMException_1.InvalidNodeTypeError();
          if (offset > (0, algorithm_1.tree_nodeLength)(node))
            throw new DOMException_1.IndexSizeError();
          const bp = [node, offset];
          if ((0, algorithm_1.boundaryPoint_position)(bp, this._start) === interfaces_1.BoundaryPosition.Before || (0, algorithm_1.boundaryPoint_position)(bp, this._end) === interfaces_1.BoundaryPosition.After) {
            return false;
          }
          return true;
        }
        /** @inheritdoc */
        comparePoint(node, offset) {
          if ((0, algorithm_1.tree_rootNode)(node) !== (0, algorithm_1.range_root)(this))
            throw new DOMException_1.WrongDocumentError();
          if (util_1.Guard.isDocumentTypeNode(node))
            throw new DOMException_1.InvalidNodeTypeError();
          if (offset > (0, algorithm_1.tree_nodeLength)(node))
            throw new DOMException_1.IndexSizeError();
          const bp = [node, offset];
          if ((0, algorithm_1.boundaryPoint_position)(bp, this._start) === interfaces_1.BoundaryPosition.Before) {
            return -1;
          } else if ((0, algorithm_1.boundaryPoint_position)(bp, this._end) === interfaces_1.BoundaryPosition.After) {
            return 1;
          } else {
            return 0;
          }
        }
        /** @inheritdoc */
        intersectsNode(node) {
          if ((0, algorithm_1.tree_rootNode)(node) !== (0, algorithm_1.range_root)(this)) {
            return false;
          }
          const parent = node._parent;
          if (parent === null)
            return true;
          const offset = (0, algorithm_1.tree_index)(node);
          if ((0, algorithm_1.boundaryPoint_position)([parent, offset], this._end) === interfaces_1.BoundaryPosition.Before && (0, algorithm_1.boundaryPoint_position)([parent, offset + 1], this._start) === interfaces_1.BoundaryPosition.After) {
            return true;
          }
          return false;
        }
        toString() {
          let s = "";
          if (this._startNode === this._endNode && util_1.Guard.isTextNode(this._startNode)) {
            return this._startNode._data.substring(this._startOffset, this._endOffset);
          }
          if (util_1.Guard.isTextNode(this._startNode)) {
            s += this._startNode._data.substring(this._startOffset);
          }
          for (const child of (0, algorithm_1.range_getContainedNodes)(this)) {
            if (util_1.Guard.isTextNode(child)) {
              s += child._data;
            }
          }
          if (util_1.Guard.isTextNode(this._endNode)) {
            s += this._endNode._data.substring(0, this._endOffset);
          }
          return s;
        }
        /**
         * Creates a new `Range`.
         *
         * @param start - start point
         * @param end - end point
         */
        static _create(start, end) {
          const range = new _RangeImpl();
          if (start)
            range._start = start;
          if (end)
            range._end = end;
          return range;
        }
      };
      __publicField(_RangeImpl, "START_TO_START", 0);
      __publicField(_RangeImpl, "START_TO_END", 1);
      __publicField(_RangeImpl, "END_TO_END", 2);
      __publicField(_RangeImpl, "END_TO_START", 3);
      var RangeImpl = _RangeImpl;
      exports.RangeImpl = RangeImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(RangeImpl.prototype, "START_TO_START", 0);
      (0, WebIDLAlgorithm_1.idl_defineConst)(RangeImpl.prototype, "START_TO_END", 1);
      (0, WebIDLAlgorithm_1.idl_defineConst)(RangeImpl.prototype, "END_TO_END", 2);
      (0, WebIDLAlgorithm_1.idl_defineConst)(RangeImpl.prototype, "END_TO_START", 3);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/TraverserImpl.js
  var require_TraverserImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/TraverserImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TraverserImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var TraverserImpl = class {
        /**
         * Initializes a new instance of `Traverser`.
         *
         * @param root - root node
         */
        constructor(root) {
          __publicField(this, "_activeFlag");
          __publicField(this, "_root");
          __publicField(this, "_whatToShow");
          __publicField(this, "_filter");
          this._activeFlag = false;
          this._root = root;
          this._whatToShow = interfaces_1.WhatToShow.All;
          this._filter = null;
        }
        /** @inheritdoc */
        get root() {
          return this._root;
        }
        /** @inheritdoc */
        get whatToShow() {
          return this._whatToShow;
        }
        /** @inheritdoc */
        get filter() {
          return this._filter;
        }
      };
      exports.TraverserImpl = TraverserImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NodeIteratorImpl.js
  var require_NodeIteratorImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NodeIteratorImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NodeIteratorImpl = void 0;
      var TraverserImpl_1 = require_TraverserImpl();
      var algorithm_1 = require_algorithm();
      var NodeIteratorImpl = class _NodeIteratorImpl extends TraverserImpl_1.TraverserImpl {
        /**
         * Initializes a new instance of `NodeIterator`.
         */
        constructor(root, reference, pointerBeforeReference) {
          super(root);
          __publicField(this, "_iteratorCollection");
          __publicField(this, "_reference");
          __publicField(this, "_pointerBeforeReference");
          this._iteratorCollection = void 0;
          this._reference = reference;
          this._pointerBeforeReference = pointerBeforeReference;
          (0, algorithm_1.nodeIterator_iteratorList)().add(this);
        }
        /** @inheritdoc */
        get referenceNode() {
          return this._reference;
        }
        /** @inheritdoc */
        get pointerBeforeReferenceNode() {
          return this._pointerBeforeReference;
        }
        /** @inheritdoc */
        nextNode() {
          return (0, algorithm_1.nodeIterator_traverse)(this, true);
        }
        /** @inheritdoc */
        previousNode() {
          return (0, algorithm_1.nodeIterator_traverse)(this, false);
        }
        /** @inheritdoc */
        detach() {
          (0, algorithm_1.nodeIterator_iteratorList)().delete(this);
        }
        /**
         * Creates a new `NodeIterator`.
         *
         * @param root - iterator's root node
         * @param reference - reference node
         * @param pointerBeforeReference - whether the iterator is before or after the
         * reference node
         */
        static _create(root, reference, pointerBeforeReference) {
          return new _NodeIteratorImpl(root, reference, pointerBeforeReference);
        }
      };
      exports.NodeIteratorImpl = NodeIteratorImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/TreeWalkerImpl.js
  var require_TreeWalkerImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/TreeWalkerImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TreeWalkerImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var TraverserImpl_1 = require_TraverserImpl();
      var algorithm_1 = require_algorithm();
      var TreeWalkerImpl = class _TreeWalkerImpl extends TraverserImpl_1.TraverserImpl {
        /**
         * Initializes a new instance of `TreeWalker`.
         */
        constructor(root, current) {
          super(root);
          __publicField(this, "_current");
          this._current = current;
        }
        /** @inheritdoc */
        get currentNode() {
          return this._current;
        }
        set currentNode(value) {
          this._current = value;
        }
        /** @inheritdoc */
        parentNode() {
          let node = this._current;
          while (node !== null && node !== this._root) {
            node = node._parent;
            if (node !== null && (0, algorithm_1.traversal_filter)(this, node) === interfaces_1.FilterResult.Accept) {
              this._current = node;
              return node;
            }
          }
          return null;
        }
        /** @inheritdoc */
        firstChild() {
          return (0, algorithm_1.treeWalker_traverseChildren)(this, true);
        }
        /** @inheritdoc */
        lastChild() {
          return (0, algorithm_1.treeWalker_traverseChildren)(this, false);
        }
        /** @inheritdoc */
        nextSibling() {
          return (0, algorithm_1.treeWalker_traverseSiblings)(this, true);
        }
        /** @inheritdoc */
        previousNode() {
          let node = this._current;
          while (node !== this._root) {
            let sibling = node._previousSibling;
            while (sibling) {
              node = sibling;
              let result = (0, algorithm_1.traversal_filter)(this, node);
              while (result !== interfaces_1.FilterResult.Reject && node._lastChild) {
                node = node._lastChild;
                result = (0, algorithm_1.traversal_filter)(this, node);
              }
              if (result === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
              }
              sibling = node._previousSibling;
            }
            if (node === this._root || node._parent === null) {
              return null;
            }
            node = node._parent;
            if ((0, algorithm_1.traversal_filter)(this, node) === interfaces_1.FilterResult.Accept) {
              this._current = node;
              return node;
            }
          }
          return null;
        }
        /** @inheritdoc */
        previousSibling() {
          return (0, algorithm_1.treeWalker_traverseSiblings)(this, false);
        }
        /** @inheritdoc */
        nextNode() {
          let node = this._current;
          let result = interfaces_1.FilterResult.Accept;
          while (true) {
            while (result !== interfaces_1.FilterResult.Reject && node._firstChild) {
              node = node._firstChild;
              result = (0, algorithm_1.traversal_filter)(this, node);
              if (result === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
              }
            }
            let sibling = null;
            let temporary = node;
            while (temporary !== null) {
              if (temporary === this._root) {
                return null;
              }
              sibling = temporary._nextSibling;
              if (sibling !== null) {
                node = sibling;
                break;
              }
              temporary = temporary._parent;
            }
            result = (0, algorithm_1.traversal_filter)(this, node);
            if (result === interfaces_1.FilterResult.Accept) {
              this._current = node;
              return node;
            }
          }
        }
        /**
         * Creates a new `TreeWalker`.
         *
         * @param root - iterator's root node
         * @param current - current node
         */
        static _create(root, current) {
          return new _TreeWalkerImpl(root, current);
        }
      };
      exports.TreeWalkerImpl = TreeWalkerImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NodeFilterImpl.js
  var require_NodeFilterImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NodeFilterImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NodeFilterImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var _NodeFilterImpl = class _NodeFilterImpl {
        /**
         * Initializes a new instance of `NodeFilter`.
         */
        constructor() {
          __publicField(this, "FILTER_ACCEPT", 1);
          __publicField(this, "FILTER_REJECT", 2);
          __publicField(this, "FILTER_SKIP", 3);
          __publicField(this, "SHOW_ALL", 4294967295);
          __publicField(this, "SHOW_ELEMENT", 1);
          __publicField(this, "SHOW_ATTRIBUTE", 2);
          __publicField(this, "SHOW_TEXT", 4);
          __publicField(this, "SHOW_CDATA_SECTION", 8);
          __publicField(this, "SHOW_ENTITY_REFERENCE", 16);
          __publicField(this, "SHOW_ENTITY", 32);
          __publicField(this, "SHOW_PROCESSING_INSTRUCTION", 64);
          __publicField(this, "SHOW_COMMENT", 128);
          __publicField(this, "SHOW_DOCUMENT", 256);
          __publicField(this, "SHOW_DOCUMENT_TYPE", 512);
          __publicField(this, "SHOW_DOCUMENT_FRAGMENT", 1024);
          __publicField(this, "SHOW_NOTATION", 2048);
        }
        /**
         * Callback function.
         */
        acceptNode(node) {
          return interfaces_1.FilterResult.Accept;
        }
        /**
         * Creates a new `NodeFilter`.
         */
        static _create() {
          return new _NodeFilterImpl();
        }
      };
      __publicField(_NodeFilterImpl, "FILTER_ACCEPT", 1);
      __publicField(_NodeFilterImpl, "FILTER_REJECT", 2);
      __publicField(_NodeFilterImpl, "FILTER_SKIP", 3);
      __publicField(_NodeFilterImpl, "SHOW_ALL", 4294967295);
      __publicField(_NodeFilterImpl, "SHOW_ELEMENT", 1);
      __publicField(_NodeFilterImpl, "SHOW_ATTRIBUTE", 2);
      __publicField(_NodeFilterImpl, "SHOW_TEXT", 4);
      __publicField(_NodeFilterImpl, "SHOW_CDATA_SECTION", 8);
      __publicField(_NodeFilterImpl, "SHOW_ENTITY_REFERENCE", 16);
      __publicField(_NodeFilterImpl, "SHOW_ENTITY", 32);
      __publicField(_NodeFilterImpl, "SHOW_PROCESSING_INSTRUCTION", 64);
      __publicField(_NodeFilterImpl, "SHOW_COMMENT", 128);
      __publicField(_NodeFilterImpl, "SHOW_DOCUMENT", 256);
      __publicField(_NodeFilterImpl, "SHOW_DOCUMENT_TYPE", 512);
      __publicField(_NodeFilterImpl, "SHOW_DOCUMENT_FRAGMENT", 1024);
      __publicField(_NodeFilterImpl, "SHOW_NOTATION", 2048);
      var NodeFilterImpl = _NodeFilterImpl;
      exports.NodeFilterImpl = NodeFilterImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "FILTER_ACCEPT", 1);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "FILTER_REJECT", 2);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "FILTER_SKIP", 3);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_ALL", 4294967295);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_ELEMENT", 1);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_ATTRIBUTE", 2);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_TEXT", 4);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_CDATA_SECTION", 8);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_ENTITY_REFERENCE", 16);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_ENTITY", 32);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_PROCESSING_INSTRUCTION", 64);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_COMMENT", 128);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_DOCUMENT", 256);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_DOCUMENT_TYPE", 512);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_DOCUMENT_FRAGMENT", 1024);
      (0, WebIDLAlgorithm_1.idl_defineConst)(NodeFilterImpl.prototype, "SHOW_NOTATION", 2048);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/MutationRecordImpl.js
  var require_MutationRecordImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/MutationRecordImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MutationRecordImpl = void 0;
      var MutationRecordImpl = class _MutationRecordImpl {
        /**
         * Initializes a new instance of `MutationRecord`.
         *
         * @param type - type of mutation: `"attributes"` for an attribute
         * mutation, `"characterData"` for a mutation to a CharacterData node
         * and `"childList"` for a mutation to the tree of nodes.
         * @param target - node affected by the mutation.
         * @param addedNodes - list of added nodes.
         * @param removedNodes - list of removed nodes.
         * @param previousSibling - previous sibling of added or removed nodes.
         * @param nextSibling - next sibling of added or removed nodes.
         * @param attributeName - local name of the changed attribute,
         * and `null` otherwise.
         * @param attributeNamespace - namespace of the changed attribute,
         * and `null` otherwise.
         * @param oldValue - value before mutation: attribute value for an attribute
         * mutation, node `data` for a mutation to a CharacterData node and `null`
         * for a mutation to the tree of nodes.
         */
        constructor(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
          __publicField(this, "_type");
          __publicField(this, "_target");
          __publicField(this, "_addedNodes");
          __publicField(this, "_removedNodes");
          __publicField(this, "_previousSibling");
          __publicField(this, "_nextSibling");
          __publicField(this, "_attributeName");
          __publicField(this, "_attributeNamespace");
          __publicField(this, "_oldValue");
          this._type = type;
          this._target = target;
          this._addedNodes = addedNodes;
          this._removedNodes = removedNodes;
          this._previousSibling = previousSibling;
          this._nextSibling = nextSibling;
          this._attributeName = attributeName;
          this._attributeNamespace = attributeNamespace;
          this._oldValue = oldValue;
        }
        /** @inheritdoc */
        get type() {
          return this._type;
        }
        /** @inheritdoc */
        get target() {
          return this._target;
        }
        /** @inheritdoc */
        get addedNodes() {
          return this._addedNodes;
        }
        /** @inheritdoc */
        get removedNodes() {
          return this._removedNodes;
        }
        /** @inheritdoc */
        get previousSibling() {
          return this._previousSibling;
        }
        /** @inheritdoc */
        get nextSibling() {
          return this._nextSibling;
        }
        /** @inheritdoc */
        get attributeName() {
          return this._attributeName;
        }
        /** @inheritdoc */
        get attributeNamespace() {
          return this._attributeNamespace;
        }
        /** @inheritdoc */
        get oldValue() {
          return this._oldValue;
        }
        /**
         * Creates a new `MutationRecord`.
         *
         * @param type - type of mutation: `"attributes"` for an attribute
         * mutation, `"characterData"` for a mutation to a CharacterData node
         * and `"childList"` for a mutation to the tree of nodes.
         * @param target - node affected by the mutation.
         * @param addedNodes - list of added nodes.
         * @param removedNodes - list of removed nodes.
         * @param previousSibling - previous sibling of added or removed nodes.
         * @param nextSibling - next sibling of added or removed nodes.
         * @param attributeName - local name of the changed attribute,
         * and `null` otherwise.
         * @param attributeNamespace - namespace of the changed attribute,
         * and `null` otherwise.
         * @param oldValue - value before mutation: attribute value for an attribute
         * mutation, node `data` for a mutation to a CharacterData node and `null`
         * for a mutation to the tree of nodes.
         */
        static _create(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
          return new _MutationRecordImpl(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
        }
      };
      exports.MutationRecordImpl = MutationRecordImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DOMTokenListImpl.js
  var require_DOMTokenListImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DOMTokenListImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DOMTokenListImpl = void 0;
      var DOMImpl_1 = require_DOMImpl();
      var DOMException_1 = require_DOMException();
      var infra_1 = require_lib5();
      var algorithm_1 = require_algorithm();
      var DOMTokenListImpl = class _DOMTokenListImpl {
        /**
         * Initializes a new instance of `DOMTokenList`.
         *
         * @param element - associated element
         * @param attribute - associated attribute
         */
        constructor(element, attribute) {
          __publicField(this, "_element");
          __publicField(this, "_attribute");
          __publicField(this, "_tokenSet");
          this._element = element;
          this._attribute = attribute;
          this._tokenSet = /* @__PURE__ */ new Set();
          const localName = attribute._localName;
          const value = (0, algorithm_1.element_getAnAttributeValue)(element, localName);
          const thisObj = this;
          function updateTokenSet(element2, localName2, oldValue, value2, namespace) {
            if (localName2 === thisObj._attribute._localName && namespace === null) {
              if (!value2)
                thisObj._tokenSet.clear();
              else
                thisObj._tokenSet = (0, algorithm_1.orderedSet_parse)(value2);
            }
          }
          this._element._attributeChangeSteps.push(updateTokenSet);
          if (DOMImpl_1.dom.features.steps) {
            (0, algorithm_1.dom_runAttributeChangeSteps)(element, localName, value, value, null);
          }
        }
        /** @inheritdoc */
        get length() {
          return this._tokenSet.size;
        }
        /** @inheritdoc */
        item(index) {
          let i = 0;
          for (const token of this._tokenSet) {
            if (i === index)
              return token;
            i++;
          }
          return null;
        }
        /** @inheritdoc */
        contains(token) {
          return this._tokenSet.has(token);
        }
        /** @inheritdoc */
        add(...tokens) {
          for (const token of tokens) {
            if (token === "") {
              throw new DOMException_1.SyntaxError("Cannot add an empty token.");
            } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
              throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
            } else {
              this._tokenSet.add(token);
            }
          }
          (0, algorithm_1.tokenList_updateSteps)(this);
        }
        /** @inheritdoc */
        remove(...tokens) {
          for (const token of tokens) {
            if (token === "") {
              throw new DOMException_1.SyntaxError("Cannot remove an empty token.");
            } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
              throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
            } else {
              this._tokenSet.delete(token);
            }
          }
          (0, algorithm_1.tokenList_updateSteps)(this);
        }
        /** @inheritdoc */
        toggle(token, force = void 0) {
          if (token === "") {
            throw new DOMException_1.SyntaxError("Cannot toggle an empty token.");
          } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
            throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
          }
          if (this._tokenSet.has(token)) {
            if (force === void 0 || force === false) {
              this._tokenSet.delete(token);
              (0, algorithm_1.tokenList_updateSteps)(this);
              return false;
            }
            return true;
          }
          if (force === void 0 || force === true) {
            this._tokenSet.add(token);
            (0, algorithm_1.tokenList_updateSteps)(this);
            return true;
          }
          return false;
        }
        /** @inheritdoc */
        replace(token, newToken) {
          if (token === "" || newToken === "") {
            throw new DOMException_1.SyntaxError("Cannot replace an empty token.");
          } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token) || infra_1.codePoint.ASCIIWhiteSpace.test(newToken)) {
            throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
          }
          if (!this._tokenSet.has(token))
            return false;
          infra_1.set.replace(this._tokenSet, token, newToken);
          (0, algorithm_1.tokenList_updateSteps)(this);
          return true;
        }
        /** @inheritdoc */
        supports(token) {
          return (0, algorithm_1.tokenList_validationSteps)(this, token);
        }
        /** @inheritdoc */
        get value() {
          return (0, algorithm_1.tokenList_serializeSteps)(this);
        }
        set value(value) {
          (0, algorithm_1.element_setAnAttributeValue)(this._element, this._attribute._localName, value);
        }
        /**
         * Returns an iterator for the token set.
         */
        [Symbol.iterator]() {
          const it = this._tokenSet[Symbol.iterator]();
          return {
            next() {
              return it.next();
            }
          };
        }
        /**
         * Creates a new `DOMTokenList`.
         *
         * @param element - associated element
         * @param attribute - associated attribute
         */
        static _create(element, attribute) {
          return new _DOMTokenListImpl(element, attribute);
        }
      };
      exports.DOMTokenListImpl = DOMTokenListImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/CreateAlgorithm.js
  var require_CreateAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/CreateAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.create_domImplementation = create_domImplementation;
      exports.create_window = create_window;
      exports.create_xmlDocument = create_xmlDocument;
      exports.create_document = create_document;
      exports.create_abortController = create_abortController;
      exports.create_abortSignal = create_abortSignal;
      exports.create_documentType = create_documentType;
      exports.create_element = create_element;
      exports.create_htmlElement = create_htmlElement;
      exports.create_htmlUnknownElement = create_htmlUnknownElement;
      exports.create_documentFragment = create_documentFragment;
      exports.create_shadowRoot = create_shadowRoot;
      exports.create_attr = create_attr;
      exports.create_text = create_text;
      exports.create_cdataSection = create_cdataSection;
      exports.create_comment = create_comment;
      exports.create_processingInstruction = create_processingInstruction;
      exports.create_htmlCollection = create_htmlCollection;
      exports.create_nodeList = create_nodeList;
      exports.create_nodeListStatic = create_nodeListStatic;
      exports.create_namedNodeMap = create_namedNodeMap;
      exports.create_range = create_range;
      exports.create_nodeIterator = create_nodeIterator;
      exports.create_treeWalker = create_treeWalker;
      exports.create_nodeFilter = create_nodeFilter;
      exports.create_mutationRecord = create_mutationRecord;
      exports.create_domTokenList = create_domTokenList;
      var DOMImplementationImpl_1 = require_DOMImplementationImpl();
      var WindowImpl_1 = require_WindowImpl();
      var XMLDocumentImpl_1 = require_XMLDocumentImpl();
      var DocumentImpl_1 = require_DocumentImpl();
      var AbortControllerImpl_1 = require_AbortControllerImpl();
      var AbortSignalImpl_1 = require_AbortSignalImpl();
      var DocumentTypeImpl_1 = require_DocumentTypeImpl();
      var ElementImpl_1 = require_ElementImpl();
      var DocumentFragmentImpl_1 = require_DocumentFragmentImpl();
      var ShadowRootImpl_1 = require_ShadowRootImpl();
      var AttrImpl_1 = require_AttrImpl();
      var TextImpl_1 = require_TextImpl();
      var CDATASectionImpl_1 = require_CDATASectionImpl();
      var CommentImpl_1 = require_CommentImpl();
      var ProcessingInstructionImpl_1 = require_ProcessingInstructionImpl();
      var HTMLCollectionImpl_1 = require_HTMLCollectionImpl();
      var NodeListImpl_1 = require_NodeListImpl();
      var NodeListStaticImpl_1 = require_NodeListStaticImpl();
      var NamedNodeMapImpl_1 = require_NamedNodeMapImpl();
      var RangeImpl_1 = require_RangeImpl();
      var NodeIteratorImpl_1 = require_NodeIteratorImpl();
      var TreeWalkerImpl_1 = require_TreeWalkerImpl();
      var NodeFilterImpl_1 = require_NodeFilterImpl();
      var MutationRecordImpl_1 = require_MutationRecordImpl();
      var DOMTokenListImpl_1 = require_DOMTokenListImpl();
      function create_domImplementation(document2) {
        return DOMImplementationImpl_1.DOMImplementationImpl._create(document2);
      }
      function create_window() {
        return WindowImpl_1.WindowImpl._create();
      }
      function create_xmlDocument() {
        return new XMLDocumentImpl_1.XMLDocumentImpl();
      }
      function create_document() {
        return new DocumentImpl_1.DocumentImpl();
      }
      function create_abortController() {
        return new AbortControllerImpl_1.AbortControllerImpl();
      }
      function create_abortSignal() {
        return AbortSignalImpl_1.AbortSignalImpl._create();
      }
      function create_documentType(document2, name, publicId, systemId) {
        return DocumentTypeImpl_1.DocumentTypeImpl._create(document2, name, publicId, systemId);
      }
      function create_element(document2, localName, namespace, prefix) {
        return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
      }
      function create_htmlElement(document2, localName, namespace, prefix) {
        return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
      }
      function create_htmlUnknownElement(document2, localName, namespace, prefix) {
        return ElementImpl_1.ElementImpl._create(document2, localName, namespace, prefix);
      }
      function create_documentFragment(document2) {
        return DocumentFragmentImpl_1.DocumentFragmentImpl._create(document2);
      }
      function create_shadowRoot(document2, host) {
        return ShadowRootImpl_1.ShadowRootImpl._create(document2, host);
      }
      function create_attr(document2, localName) {
        return AttrImpl_1.AttrImpl._create(document2, localName);
      }
      function create_text(document2, data) {
        return TextImpl_1.TextImpl._create(document2, data);
      }
      function create_cdataSection(document2, data) {
        return CDATASectionImpl_1.CDATASectionImpl._create(document2, data);
      }
      function create_comment(document2, data) {
        return CommentImpl_1.CommentImpl._create(document2, data);
      }
      function create_processingInstruction(document2, target, data) {
        return ProcessingInstructionImpl_1.ProcessingInstructionImpl._create(document2, target, data);
      }
      function create_htmlCollection(root, filter = (() => true)) {
        return HTMLCollectionImpl_1.HTMLCollectionImpl._create(root, filter);
      }
      function create_nodeList(root) {
        return NodeListImpl_1.NodeListImpl._create(root);
      }
      function create_nodeListStatic(root, items) {
        return NodeListStaticImpl_1.NodeListStaticImpl._create(root, items);
      }
      function create_namedNodeMap(element) {
        return NamedNodeMapImpl_1.NamedNodeMapImpl._create(element);
      }
      function create_range(start, end) {
        return RangeImpl_1.RangeImpl._create(start, end);
      }
      function create_nodeIterator(root, reference, pointerBeforeReference) {
        return NodeIteratorImpl_1.NodeIteratorImpl._create(root, reference, pointerBeforeReference);
      }
      function create_treeWalker(root, current) {
        return TreeWalkerImpl_1.TreeWalkerImpl._create(root, current);
      }
      function create_nodeFilter() {
        return NodeFilterImpl_1.NodeFilterImpl._create();
      }
      function create_mutationRecord(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
        return MutationRecordImpl_1.MutationRecordImpl._create(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
      }
      function create_domTokenList(element, attribute) {
        return DOMTokenListImpl_1.DOMTokenListImpl._create(element, attribute);
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DOMImpl.js
  var require_DOMImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DOMImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.dom = void 0;
      var util_1 = require_lib4();
      var CreateAlgorithm_1 = require_CreateAlgorithm();
      var _DOMImpl = class _DOMImpl {
        /**
         * Initializes a new instance of `DOM`.
         */
        constructor() {
          __publicField(this, "_features", {
            mutationObservers: true,
            customElements: true,
            slots: true,
            steps: true
          });
          __publicField(this, "_window", null);
          __publicField(this, "_compareCache");
          __publicField(this, "_rangeList");
          this._compareCache = new util_1.CompareCache();
          this._rangeList = new util_1.FixedSizeSet();
        }
        /**
         * Sets DOM algorithm features.
         *
         * @param features - DOM features supported by algorithms. All features are
         * enabled by default unless explicity disabled.
         */
        setFeatures(features) {
          if (features === void 0)
            features = true;
          if ((0, util_1.isObject)(features)) {
            for (const key in features) {
              this._features[key] = features[key] || false;
            }
          } else {
            for (const key in this._features) {
              this._features[key] = features;
            }
          }
        }
        /**
         * Gets DOM algorithm features.
         */
        get features() {
          return this._features;
        }
        /**
         * Gets the DOM window.
         */
        get window() {
          if (this._window === null) {
            this._window = (0, CreateAlgorithm_1.create_window)();
          }
          return this._window;
        }
        /**
         * Gets the global node compare cache.
         */
        get compareCache() {
          return this._compareCache;
        }
        /**
         * Gets the global range list.
         */
        get rangeList() {
          return this._rangeList;
        }
        /**
         * Returns the instance of `DOM`.
         */
        static get instance() {
          if (!_DOMImpl._instance) {
            _DOMImpl._instance = new _DOMImpl();
          }
          return _DOMImpl._instance;
        }
      };
      __publicField(_DOMImpl, "_instance");
      var DOMImpl = _DOMImpl;
      exports.dom = DOMImpl.instance;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/EventImpl.js
  var require_EventImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/EventImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EventImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var algorithm_1 = require_algorithm();
      var WebIDLAlgorithm_1 = require_WebIDLAlgorithm();
      var EventImpl = class {
        /**
         * Initializes a new instance of `Event`.
         */
        constructor(type, eventInit) {
          __publicField(this, "NONE", 0);
          __publicField(this, "CAPTURING_PHASE", 1);
          __publicField(this, "AT_TARGET", 2);
          __publicField(this, "BUBBLING_PHASE", 3);
          __publicField(this, "_target", null);
          __publicField(this, "_relatedTarget", null);
          __publicField(this, "_touchTargetList", []);
          __publicField(this, "_path", []);
          __publicField(this, "_currentTarget", null);
          __publicField(this, "_eventPhase", interfaces_1.EventPhase.None);
          __publicField(this, "_stopPropagationFlag", false);
          __publicField(this, "_stopImmediatePropagationFlag", false);
          __publicField(this, "_canceledFlag", false);
          __publicField(this, "_inPassiveListenerFlag", false);
          __publicField(this, "_composedFlag", false);
          __publicField(this, "_initializedFlag", false);
          __publicField(this, "_dispatchFlag", false);
          __publicField(this, "_isTrusted", false);
          __publicField(this, "_type");
          __publicField(this, "_bubbles", false);
          __publicField(this, "_cancelable", false);
          __publicField(this, "_timeStamp");
          this._type = type;
          if (eventInit) {
            this._bubbles = eventInit.bubbles || false;
            this._cancelable = eventInit.cancelable || false;
            this._composedFlag = eventInit.composed || false;
          }
          this._initializedFlag = true;
          this._timeStamp = (/* @__PURE__ */ new Date()).getTime();
        }
        /** @inheritdoc */
        get type() {
          return this._type;
        }
        /** @inheritdoc */
        get target() {
          return this._target;
        }
        /** @inheritdoc */
        get srcElement() {
          return this._target;
        }
        /** @inheritdoc */
        get currentTarget() {
          return this._currentTarget;
        }
        /** @inheritdoc */
        composedPath() {
          const composedPath = [];
          const path = this._path;
          if (path.length === 0)
            return composedPath;
          const currentTarget = this._currentTarget;
          if (currentTarget === null) {
            throw new Error("Event currentTarget is null.");
          }
          composedPath.push(currentTarget);
          let currentTargetIndex = 0;
          let currentTargetHiddenSubtreeLevel = 0;
          let index = path.length - 1;
          while (index >= 0) {
            if (path[index].rootOfClosedTree) {
              currentTargetHiddenSubtreeLevel++;
            }
            if (path[index].invocationTarget === currentTarget) {
              currentTargetIndex = index;
              break;
            }
            if (path[index].slotInClosedTree) {
              currentTargetHiddenSubtreeLevel--;
            }
            index--;
          }
          let currentHiddenLevel = currentTargetHiddenSubtreeLevel;
          let maxHiddenLevel = currentTargetHiddenSubtreeLevel;
          index = currentTargetIndex - 1;
          while (index >= 0) {
            if (path[index].rootOfClosedTree) {
              currentHiddenLevel++;
            }
            if (currentHiddenLevel <= maxHiddenLevel) {
              composedPath.unshift(path[index].invocationTarget);
            }
            if (path[index].slotInClosedTree) {
              currentHiddenLevel--;
              if (currentHiddenLevel < maxHiddenLevel) {
                maxHiddenLevel = currentHiddenLevel;
              }
            }
            index--;
          }
          currentHiddenLevel = currentTargetHiddenSubtreeLevel;
          maxHiddenLevel = currentTargetHiddenSubtreeLevel;
          index = currentTargetIndex + 1;
          while (index < path.length) {
            if (path[index].slotInClosedTree) {
              currentHiddenLevel++;
            }
            if (currentHiddenLevel <= maxHiddenLevel) {
              composedPath.push(path[index].invocationTarget);
            }
            if (path[index].rootOfClosedTree) {
              currentHiddenLevel--;
              if (currentHiddenLevel < maxHiddenLevel) {
                maxHiddenLevel = currentHiddenLevel;
              }
            }
            index++;
          }
          return composedPath;
        }
        /** @inheritdoc */
        get eventPhase() {
          return this._eventPhase;
        }
        /** @inheritdoc */
        stopPropagation() {
          this._stopPropagationFlag = true;
        }
        /** @inheritdoc */
        get cancelBubble() {
          return this._stopPropagationFlag;
        }
        set cancelBubble(value) {
          if (value)
            this.stopPropagation();
        }
        /** @inheritdoc */
        stopImmediatePropagation() {
          this._stopPropagationFlag = true;
          this._stopImmediatePropagationFlag = true;
        }
        /** @inheritdoc */
        get bubbles() {
          return this._bubbles;
        }
        /** @inheritdoc */
        get cancelable() {
          return this._cancelable;
        }
        /** @inheritdoc */
        get returnValue() {
          return !this._canceledFlag;
        }
        set returnValue(value) {
          if (!value) {
            (0, algorithm_1.event_setTheCanceledFlag)(this);
          }
        }
        /** @inheritdoc */
        preventDefault() {
          (0, algorithm_1.event_setTheCanceledFlag)(this);
        }
        /** @inheritdoc */
        get defaultPrevented() {
          return this._canceledFlag;
        }
        /** @inheritdoc */
        get composed() {
          return this._composedFlag;
        }
        /** @inheritdoc */
        get isTrusted() {
          return this._isTrusted;
        }
        /** @inheritdoc */
        get timeStamp() {
          return this._timeStamp;
        }
        /** @inheritdoc */
        initEvent(type, bubbles = false, cancelable = false) {
          if (this._dispatchFlag)
            return;
          (0, algorithm_1.event_initialize)(this, type, bubbles, cancelable);
        }
      };
      __publicField(EventImpl, "NONE", 0);
      __publicField(EventImpl, "CAPTURING_PHASE", 1);
      __publicField(EventImpl, "AT_TARGET", 2);
      __publicField(EventImpl, "BUBBLING_PHASE", 3);
      exports.EventImpl = EventImpl;
      (0, WebIDLAlgorithm_1.idl_defineConst)(EventImpl.prototype, "NONE", 0);
      (0, WebIDLAlgorithm_1.idl_defineConst)(EventImpl.prototype, "CAPTURING_PHASE", 1);
      (0, WebIDLAlgorithm_1.idl_defineConst)(EventImpl.prototype, "AT_TARGET", 2);
      (0, WebIDLAlgorithm_1.idl_defineConst)(EventImpl.prototype, "BUBBLING_PHASE", 3);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/CustomEventImpl.js
  var require_CustomEventImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/CustomEventImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CustomEventImpl = void 0;
      var EventImpl_1 = require_EventImpl();
      var algorithm_1 = require_algorithm();
      var CustomEventImpl = class extends EventImpl_1.EventImpl {
        /**
         * Initializes a new instance of `CustomEvent`.
         */
        constructor(type, eventInit) {
          super(type, eventInit);
          __publicField(this, "_detail", null);
          this._detail = eventInit && eventInit.detail || null;
        }
        /** @inheritdoc */
        get detail() {
          return this._detail;
        }
        /** @inheritdoc */
        initCustomEvent(type, bubbles = false, cancelable = false, detail = null) {
          if (this._dispatchFlag)
            return;
          (0, algorithm_1.event_initialize)(this, type, bubbles, cancelable);
          this._detail = detail;
        }
      };
      exports.CustomEventImpl = CustomEventImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/TreeAlgorithm.js
  var require_TreeAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/TreeAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tree_getFirstDescendantNode = tree_getFirstDescendantNode;
      exports.tree_getNextDescendantNode = tree_getNextDescendantNode;
      exports.tree_getDescendantNodes = tree_getDescendantNodes;
      exports.tree_getDescendantElements = tree_getDescendantElements;
      exports.tree_getSiblingNodes = tree_getSiblingNodes;
      exports.tree_getFirstAncestorNode = tree_getFirstAncestorNode;
      exports.tree_getNextAncestorNode = tree_getNextAncestorNode;
      exports.tree_getAncestorNodes = tree_getAncestorNodes;
      exports.tree_getCommonAncestor = tree_getCommonAncestor;
      exports.tree_getFollowingNode = tree_getFollowingNode;
      exports.tree_getPrecedingNode = tree_getPrecedingNode;
      exports.tree_isConstrained = tree_isConstrained;
      exports.tree_nodeLength = tree_nodeLength;
      exports.tree_isEmpty = tree_isEmpty;
      exports.tree_rootNode = tree_rootNode;
      exports.tree_isDescendantOf = tree_isDescendantOf;
      exports.tree_isAncestorOf = tree_isAncestorOf;
      exports.tree_isHostIncludingAncestorOf = tree_isHostIncludingAncestorOf;
      exports.tree_isSiblingOf = tree_isSiblingOf;
      exports.tree_isPreceding = tree_isPreceding;
      exports.tree_isFollowing = tree_isFollowing;
      exports.tree_isParentOf = tree_isParentOf;
      exports.tree_isChildOf = tree_isChildOf;
      exports.tree_previousSibling = tree_previousSibling;
      exports.tree_nextSibling = tree_nextSibling;
      exports.tree_firstChild = tree_firstChild;
      exports.tree_lastChild = tree_lastChild;
      exports.tree_treePosition = tree_treePosition;
      exports.tree_index = tree_index;
      exports.tree_retarget = tree_retarget;
      var util_1 = require_util2();
      var interfaces_1 = require_interfaces2();
      function _getNextDescendantNode(root, node, shadow = false) {
        if (shadow && util_1.Guard.isElementNode(node) && util_1.Guard.isShadowRoot(node.shadowRoot)) {
          if (node.shadowRoot._firstChild)
            return node.shadowRoot._firstChild;
        }
        if (node._firstChild)
          return node._firstChild;
        if (node === root)
          return null;
        if (node._nextSibling)
          return node._nextSibling;
        let parent = node._parent;
        while (parent && parent !== root) {
          if (parent._nextSibling)
            return parent._nextSibling;
          parent = parent._parent;
        }
        return null;
      }
      function _emptyIterator() {
        return {
          [Symbol.iterator]: () => {
            return {
              next: () => {
                return { done: true, value: null };
              }
            };
          }
        };
      }
      function tree_getFirstDescendantNode(node, self2 = false, shadow = false, filter) {
        let firstNode = self2 ? node : _getNextDescendantNode(node, node, shadow);
        while (firstNode && filter && !filter(firstNode)) {
          firstNode = _getNextDescendantNode(node, firstNode, shadow);
        }
        return firstNode;
      }
      function tree_getNextDescendantNode(node, currentNode, self2 = false, shadow = false, filter) {
        let nextNode = _getNextDescendantNode(node, currentNode, shadow);
        while (nextNode && filter && !filter(nextNode)) {
          nextNode = _getNextDescendantNode(node, nextNode, shadow);
        }
        return nextNode;
      }
      function tree_getDescendantNodes(node, self2 = false, shadow = false, filter) {
        if (!self2 && node._children.size === 0) {
          return _emptyIterator();
        }
        return {
          [Symbol.iterator]: () => {
            let currentNode = self2 ? node : _getNextDescendantNode(node, node, shadow);
            return {
              next: () => {
                while (currentNode && filter && !filter(currentNode)) {
                  currentNode = _getNextDescendantNode(node, currentNode, shadow);
                }
                if (currentNode === null) {
                  return { done: true, value: null };
                } else {
                  const result = { done: false, value: currentNode };
                  currentNode = _getNextDescendantNode(node, currentNode, shadow);
                  return result;
                }
              }
            };
          }
        };
      }
      function tree_getDescendantElements(node, self2 = false, shadow = false, filter) {
        if (!self2 && node._children.size === 0) {
          return _emptyIterator();
        }
        return {
          [Symbol.iterator]: () => {
            const it = tree_getDescendantNodes(node, self2, shadow, (e) => util_1.Guard.isElementNode(e))[Symbol.iterator]();
            let currentNode = it.next().value;
            return {
              next() {
                while (currentNode && filter && !filter(currentNode)) {
                  currentNode = it.next().value;
                }
                if (currentNode === null) {
                  return { done: true, value: null };
                } else {
                  const result = { done: false, value: currentNode };
                  currentNode = it.next().value;
                  return result;
                }
              }
            };
          }
        };
      }
      function tree_getSiblingNodes(node, self2 = false, filter) {
        if (!node._parent || node._parent._children.size === 0) {
          return _emptyIterator();
        }
        return {
          [Symbol.iterator]() {
            let currentNode = node._parent ? node._parent._firstChild : null;
            return {
              next() {
                while (currentNode && (filter && !filter(currentNode) || !self2 && currentNode === node)) {
                  currentNode = currentNode._nextSibling;
                }
                if (currentNode === null) {
                  return { done: true, value: null };
                } else {
                  const result = { done: false, value: currentNode };
                  currentNode = currentNode._nextSibling;
                  return result;
                }
              }
            };
          }
        };
      }
      function tree_getFirstAncestorNode(node, self2 = false, filter) {
        let firstNode = self2 ? node : node._parent;
        while (firstNode && filter && !filter(firstNode)) {
          firstNode = firstNode._parent;
        }
        return firstNode;
      }
      function tree_getNextAncestorNode(node, currentNode, self2 = false, filter) {
        let nextNode = currentNode._parent;
        while (nextNode && filter && !filter(nextNode)) {
          nextNode = nextNode._parent;
        }
        return nextNode;
      }
      function tree_getAncestorNodes(node, self2 = false, filter) {
        if (!self2 && !node._parent) {
          return _emptyIterator();
        }
        return {
          [Symbol.iterator]() {
            let currentNode = tree_getFirstAncestorNode(node, self2, filter);
            return {
              next() {
                if (currentNode === null) {
                  return { done: true, value: null };
                } else {
                  const result = { done: false, value: currentNode };
                  currentNode = tree_getNextAncestorNode(node, currentNode, self2, filter);
                  return result;
                }
              }
            };
          }
        };
      }
      function tree_getCommonAncestor(nodeA, nodeB) {
        if (nodeA === nodeB) {
          return nodeA._parent;
        }
        const parentsA = [];
        const parentsB = [];
        let pA = tree_getFirstAncestorNode(nodeA, true);
        while (pA !== null) {
          parentsA.push(pA);
          pA = tree_getNextAncestorNode(nodeA, pA, true);
        }
        let pB = tree_getFirstAncestorNode(nodeB, true);
        while (pB !== null) {
          parentsB.push(pB);
          pB = tree_getNextAncestorNode(nodeB, pB, true);
        }
        let pos1 = parentsA.length;
        let pos2 = parentsB.length;
        let parent = null;
        for (let i = Math.min(pos1, pos2); i > 0; i--) {
          const parent1 = parentsA[--pos1];
          const parent2 = parentsB[--pos2];
          if (parent1 !== parent2) {
            break;
          }
          parent = parent1;
        }
        return parent;
      }
      function tree_getFollowingNode(root, node) {
        if (node._firstChild) {
          return node._firstChild;
        } else if (node._nextSibling) {
          return node._nextSibling;
        } else {
          while (true) {
            const parent = node._parent;
            if (parent === null || parent === root) {
              return null;
            } else if (parent._nextSibling) {
              return parent._nextSibling;
            } else {
              node = parent;
            }
          }
        }
      }
      function tree_getPrecedingNode(root, node) {
        if (node === root) {
          return null;
        }
        if (node._previousSibling) {
          node = node._previousSibling;
          if (node._lastChild) {
            return node._lastChild;
          } else {
            return node;
          }
        } else {
          return node._parent;
        }
      }
      function tree_isConstrained(node) {
        switch (node._nodeType) {
          case interfaces_1.NodeType.Document:
            let hasDocType = false;
            let hasElement = false;
            for (const childNode of node._children) {
              switch (childNode._nodeType) {
                case interfaces_1.NodeType.ProcessingInstruction:
                case interfaces_1.NodeType.Comment:
                  break;
                case interfaces_1.NodeType.DocumentType:
                  if (hasDocType || hasElement)
                    return false;
                  hasDocType = true;
                  break;
                case interfaces_1.NodeType.Element:
                  if (hasElement)
                    return false;
                  hasElement = true;
                  break;
                default:
                  return false;
              }
            }
            break;
          case interfaces_1.NodeType.DocumentFragment:
          case interfaces_1.NodeType.Element:
            for (const childNode of node._children) {
              switch (childNode._nodeType) {
                case interfaces_1.NodeType.Element:
                case interfaces_1.NodeType.Text:
                case interfaces_1.NodeType.ProcessingInstruction:
                case interfaces_1.NodeType.CData:
                case interfaces_1.NodeType.Comment:
                  break;
                default:
                  return false;
              }
            }
            break;
          case interfaces_1.NodeType.DocumentType:
          case interfaces_1.NodeType.Text:
          case interfaces_1.NodeType.ProcessingInstruction:
          case interfaces_1.NodeType.CData:
          case interfaces_1.NodeType.Comment:
            return !node.hasChildNodes();
        }
        for (const childNode of node._children) {
          if (!tree_isConstrained(childNode))
            return false;
        }
        return true;
      }
      function tree_nodeLength(node) {
        if (util_1.Guard.isDocumentTypeNode(node)) {
          return 0;
        } else if (util_1.Guard.isCharacterDataNode(node)) {
          return node._data.length;
        } else {
          return node._children.size;
        }
      }
      function tree_isEmpty(node) {
        return tree_nodeLength(node) === 0;
      }
      function tree_rootNode(node, shadow = false) {
        if (shadow) {
          const root = tree_rootNode(node, false);
          if (util_1.Guard.isShadowRoot(root))
            return tree_rootNode(root._host, true);
          else
            return root;
        } else {
          if (!node._parent)
            return node;
          else
            return tree_rootNode(node._parent);
        }
      }
      function tree_isDescendantOf(node, other, self2 = false, shadow = false) {
        let child = tree_getFirstDescendantNode(node, self2, shadow);
        while (child !== null) {
          if (child === other) {
            return true;
          }
          child = tree_getNextDescendantNode(node, child, self2, shadow);
        }
        return false;
      }
      function tree_isAncestorOf(node, other, self2 = false, shadow = false) {
        let ancestor = self2 ? node : shadow && util_1.Guard.isShadowRoot(node) ? node._host : node._parent;
        while (ancestor !== null) {
          if (ancestor === other)
            return true;
          ancestor = shadow && util_1.Guard.isShadowRoot(ancestor) ? ancestor._host : ancestor._parent;
        }
        return false;
      }
      function tree_isHostIncludingAncestorOf(node, other, self2 = false) {
        if (tree_isAncestorOf(node, other, self2))
          return true;
        const root = tree_rootNode(node);
        if (util_1.Guard.isDocumentFragmentNode(root) && root._host !== null && tree_isHostIncludingAncestorOf(root._host, other, self2))
          return true;
        return false;
      }
      function tree_isSiblingOf(node, other, self2 = false) {
        if (node === other) {
          if (self2)
            return true;
        } else {
          return node._parent !== null && node._parent === other._parent;
        }
        return false;
      }
      function tree_isPreceding(node, other) {
        const nodePos = tree_treePosition(node);
        const otherPos = tree_treePosition(other);
        if (nodePos === -1 || otherPos === -1)
          return false;
        else if (tree_rootNode(node) !== tree_rootNode(other))
          return false;
        else
          return otherPos < nodePos;
      }
      function tree_isFollowing(node, other) {
        const nodePos = tree_treePosition(node);
        const otherPos = tree_treePosition(other);
        if (nodePos === -1 || otherPos === -1)
          return false;
        else if (tree_rootNode(node) !== tree_rootNode(other))
          return false;
        else
          return otherPos > nodePos;
      }
      function tree_isParentOf(node, other) {
        return node._parent === other;
      }
      function tree_isChildOf(node, other) {
        return other._parent === node;
      }
      function tree_previousSibling(node) {
        return node._previousSibling;
      }
      function tree_nextSibling(node) {
        return node._nextSibling;
      }
      function tree_firstChild(node) {
        return node._firstChild;
      }
      function tree_lastChild(node) {
        return node._lastChild;
      }
      function tree_treePosition(node) {
        const root = tree_rootNode(node);
        let pos = 0;
        let childNode = tree_getFirstDescendantNode(root);
        while (childNode !== null) {
          pos++;
          if (childNode === node)
            return pos;
          childNode = tree_getNextDescendantNode(root, childNode);
        }
        return -1;
      }
      function tree_index(node) {
        let n = 0;
        while (node._previousSibling !== null) {
          n++;
          node = node._previousSibling;
        }
        return n;
      }
      function tree_retarget(a, b) {
        while (true) {
          if (!a || !util_1.Guard.isNode(a)) {
            return a;
          }
          const rootOfA = tree_rootNode(a);
          if (!util_1.Guard.isShadowRoot(rootOfA)) {
            return a;
          }
          if (b && util_1.Guard.isNode(b) && tree_isAncestorOf(rootOfA, b, true, true)) {
            return a;
          }
          a = rootOfA.host;
        }
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/MutationObserverAlgorithm.js
  var require_MutationObserverAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/MutationObserverAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.observer_queueAMutationObserverMicrotask = observer_queueAMutationObserverMicrotask;
      exports.observer_notifyMutationObservers = observer_notifyMutationObservers;
      exports.observer_queueMutationRecord = observer_queueMutationRecord;
      exports.observer_queueTreeMutationRecord = observer_queueTreeMutationRecord;
      exports.observer_queueAttributeMutationRecord = observer_queueAttributeMutationRecord;
      var DOMImpl_1 = require_DOMImpl();
      var util_1 = require_util2();
      var infra_1 = require_lib5();
      var CreateAlgorithm_1 = require_CreateAlgorithm();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      var EventAlgorithm_1 = require_EventAlgorithm();
      function observer_queueAMutationObserverMicrotask() {
        const window2 = DOMImpl_1.dom.window;
        if (window2._mutationObserverMicrotaskQueued)
          return;
        window2._mutationObserverMicrotaskQueued = true;
        Promise.resolve().then(() => {
          observer_notifyMutationObservers();
        });
      }
      function observer_notifyMutationObservers() {
        const window2 = DOMImpl_1.dom.window;
        window2._mutationObserverMicrotaskQueued = false;
        const notifySet = infra_1.set.clone(window2._mutationObservers);
        const signalSet = infra_1.set.clone(window2._signalSlots);
        infra_1.set.empty(window2._signalSlots);
        for (const mo of notifySet) {
          const records = infra_1.list.clone(mo._recordQueue);
          infra_1.list.empty(mo._recordQueue);
          for (let i = 0; i < mo._nodeList.length; i++) {
            const node = mo._nodeList[i];
            infra_1.list.remove(node._registeredObserverList, (observer) => {
              return util_1.Guard.isTransientRegisteredObserver(observer) && observer.observer === mo;
            });
          }
          if (!infra_1.list.isEmpty(records)) {
            try {
              mo._callback.call(mo, records, mo);
            } catch (err) {
            }
          }
        }
        if (DOMImpl_1.dom.features.slots) {
          for (const slot of signalSet) {
            (0, EventAlgorithm_1.event_fireAnEvent)("slotchange", slot, void 0, { bubbles: true });
          }
        }
      }
      function observer_queueMutationRecord(type, target, name, namespace, oldValue, addedNodes, removedNodes, previousSibling, nextSibling) {
        const interestedObservers = /* @__PURE__ */ new Map();
        let node = (0, TreeAlgorithm_1.tree_getFirstAncestorNode)(target, true);
        while (node !== null) {
          for (let i = 0; i < node._registeredObserverList.length; i++) {
            const registered = node._registeredObserverList[i];
            const options = registered.options;
            if (node !== target && !options.subtree)
              continue;
            if (type === "attributes" && !options.attributes)
              continue;
            if (type === "attributes" && options.attributeFilter && (!options.attributeFilter.indexOf(name || "") || namespace !== null))
              continue;
            if (type === "characterData" && !options.characterData)
              continue;
            if (type === "childList" && !options.childList)
              continue;
            const mo = registered.observer;
            if (!interestedObservers.has(mo)) {
              interestedObservers.set(mo, null);
            }
            if (type === "attributes" && options.attributeOldValue || type === "characterData" && options.characterDataOldValue) {
              interestedObservers.set(mo, oldValue);
            }
          }
          node = (0, TreeAlgorithm_1.tree_getNextAncestorNode)(target, node, true);
        }
        for (const [observer, mappedOldValue] of interestedObservers) {
          const record = (0, CreateAlgorithm_1.create_mutationRecord)(type, target, (0, CreateAlgorithm_1.create_nodeListStatic)(target, addedNodes), (0, CreateAlgorithm_1.create_nodeListStatic)(target, removedNodes), previousSibling, nextSibling, name, namespace, mappedOldValue);
          const queue = observer._recordQueue;
          queue.push(record);
        }
        observer_queueAMutationObserverMicrotask();
      }
      function observer_queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {
        observer_queueMutationRecord("childList", target, null, null, null, addedNodes, removedNodes, previousSibling, nextSibling);
      }
      function observer_queueAttributeMutationRecord(target, name, namespace, oldValue) {
        observer_queueMutationRecord("attributes", target, name, namespace, oldValue, [], [], null, null);
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/ShadowTreeAlgorithm.js
  var require_ShadowTreeAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/ShadowTreeAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.shadowTree_signalASlotChange = shadowTree_signalASlotChange;
      exports.shadowTree_isConnected = shadowTree_isConnected;
      exports.shadowTree_isAssigned = shadowTree_isAssigned;
      exports.shadowTree_findASlot = shadowTree_findASlot;
      exports.shadowTree_findSlotables = shadowTree_findSlotables;
      exports.shadowTree_findFlattenedSlotables = shadowTree_findFlattenedSlotables;
      exports.shadowTree_assignSlotables = shadowTree_assignSlotables;
      exports.shadowTree_assignSlotablesForATree = shadowTree_assignSlotablesForATree;
      exports.shadowTree_assignASlot = shadowTree_assignASlot;
      var DOMImpl_1 = require_DOMImpl();
      var util_1 = require_util2();
      var util_2 = require_lib4();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
      function shadowTree_signalASlotChange(slot) {
        const window2 = DOMImpl_1.dom.window;
        window2._signalSlots.add(slot);
        (0, MutationObserverAlgorithm_1.observer_queueAMutationObserverMicrotask)();
      }
      function shadowTree_isConnected(element) {
        return util_1.Guard.isDocumentNode((0, TreeAlgorithm_1.tree_rootNode)(element, true));
      }
      function shadowTree_isAssigned(slotable) {
        return slotable._assignedSlot !== null;
      }
      function shadowTree_findASlot(slotable, openFlag = false) {
        const node = util_1.Cast.asNode(slotable);
        const parent = node._parent;
        if (parent === null)
          return null;
        const shadow = parent._shadowRoot || null;
        if (shadow === null)
          return null;
        if (openFlag && shadow._mode !== "open")
          return null;
        let child = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(shadow, false, true, (e) => util_1.Guard.isSlot(e));
        while (child !== null) {
          if (child._name === slotable._name)
            return child;
          child = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(shadow, child, false, true, (e) => util_1.Guard.isSlot(e));
        }
        return null;
      }
      function shadowTree_findSlotables(slot) {
        const result = [];
        const root = (0, TreeAlgorithm_1.tree_rootNode)(slot);
        if (!util_1.Guard.isShadowRoot(root))
          return result;
        const host = root._host;
        for (const slotable of host._children) {
          if (util_1.Guard.isSlotable(slotable)) {
            const foundSlot = shadowTree_findASlot(slotable);
            if (foundSlot === slot) {
              result.push(slotable);
            }
          }
        }
        return result;
      }
      function shadowTree_findFlattenedSlotables(slot) {
        const result = [];
        const root = (0, TreeAlgorithm_1.tree_rootNode)(slot);
        if (!util_1.Guard.isShadowRoot(root))
          return result;
        const slotables = shadowTree_findSlotables(slot);
        if ((0, util_2.isEmpty)(slotables)) {
          for (const slotable of slot._children) {
            if (util_1.Guard.isSlotable(slotable)) {
              slotables.push(slotable);
            }
          }
        }
        for (const node of slotables) {
          if (util_1.Guard.isSlot(node) && util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(node))) {
            const temporaryResult = shadowTree_findFlattenedSlotables(node);
            result.push(...temporaryResult);
          } else {
            result.push(node);
          }
        }
        return result;
      }
      function shadowTree_assignSlotables(slot) {
        const slotables = shadowTree_findSlotables(slot);
        if (slotables.length === slot._assignedNodes.length) {
          let nodesIdentical = true;
          for (let i = 0; i < slotables.length; i++) {
            if (slotables[i] !== slot._assignedNodes[i]) {
              nodesIdentical = false;
              break;
            }
          }
          if (!nodesIdentical) {
            shadowTree_signalASlotChange(slot);
          }
        }
        slot._assignedNodes = slotables;
        for (const slotable of slotables) {
          slotable._assignedSlot = slot;
        }
      }
      function shadowTree_assignSlotablesForATree(root) {
        let descendant = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(root, true, false, (e) => util_1.Guard.isSlot(e));
        while (descendant !== null) {
          shadowTree_assignSlotables(descendant);
          descendant = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(root, descendant, true, false, (e) => util_1.Guard.isSlot(e));
        }
      }
      function shadowTree_assignASlot(slotable) {
        const slot = shadowTree_findASlot(slotable);
        if (slot !== null) {
          shadowTree_assignSlotables(slot);
        }
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/DOMAlgorithm.js
  var require_DOMAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/DOMAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.dom_runRemovingSteps = dom_runRemovingSteps;
      exports.dom_runCloningSteps = dom_runCloningSteps;
      exports.dom_runAdoptingSteps = dom_runAdoptingSteps;
      exports.dom_runAttributeChangeSteps = dom_runAttributeChangeSteps;
      exports.dom_runInsertionSteps = dom_runInsertionSteps;
      exports.dom_runNodeIteratorPreRemovingSteps = dom_runNodeIteratorPreRemovingSteps;
      exports.dom_hasSupportedTokens = dom_hasSupportedTokens;
      exports.dom_getSupportedTokens = dom_getSupportedTokens;
      exports.dom_runEventConstructingSteps = dom_runEventConstructingSteps;
      exports.dom_runChildTextContentChangeSteps = dom_runChildTextContentChangeSteps;
      var DOMImpl_1 = require_DOMImpl();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      var util_1 = require_util2();
      var ShadowTreeAlgorithm_1 = require_ShadowTreeAlgorithm();
      var supportedTokens = /* @__PURE__ */ new Map();
      function dom_runRemovingSteps(removedNode, oldParent) {
      }
      function dom_runCloningSteps(copy, node, document2, cloneChildrenFlag) {
      }
      function dom_runAdoptingSteps(node, oldDocument) {
      }
      function dom_runAttributeChangeSteps(element, localName, oldValue, value, namespace) {
        if (DOMImpl_1.dom.features.slots) {
          updateASlotablesName.call(element, element, localName, oldValue, value, namespace);
          updateASlotsName.call(element, element, localName, oldValue, value, namespace);
        }
        updateAnElementID.call(element, element, localName, value, namespace);
        for (const step of element._attributeChangeSteps) {
          step.call(element, element, localName, oldValue, value, namespace);
        }
      }
      function dom_runInsertionSteps(insertedNode) {
      }
      function dom_runNodeIteratorPreRemovingSteps(nodeIterator, toBeRemoved) {
        removeNodeIterator.call(nodeIterator, nodeIterator, toBeRemoved);
      }
      function dom_hasSupportedTokens(attributeName) {
        return supportedTokens.has(attributeName);
      }
      function dom_getSupportedTokens(attributeName) {
        return supportedTokens.get(attributeName) || /* @__PURE__ */ new Set();
      }
      function dom_runEventConstructingSteps(event) {
      }
      function dom_runChildTextContentChangeSteps(parent) {
      }
      function removeNodeIterator(nodeIterator, toBeRemovedNode) {
        if (toBeRemovedNode === nodeIterator._root || !(0, TreeAlgorithm_1.tree_isAncestorOf)(nodeIterator._reference, toBeRemovedNode, true)) {
          return;
        }
        if (nodeIterator._pointerBeforeReference) {
          while (true) {
            const nextNode = (0, TreeAlgorithm_1.tree_getFollowingNode)(nodeIterator._root, toBeRemovedNode);
            if (nextNode !== null && (0, TreeAlgorithm_1.tree_isDescendantOf)(nodeIterator._root, nextNode, true) && !(0, TreeAlgorithm_1.tree_isDescendantOf)(toBeRemovedNode, nextNode, true)) {
              nodeIterator._reference = nextNode;
              return;
            } else if (nextNode === null) {
              nodeIterator._pointerBeforeReference = false;
              return;
            }
          }
        }
        if (toBeRemovedNode._previousSibling === null) {
          if (toBeRemovedNode._parent !== null) {
            nodeIterator._reference = toBeRemovedNode._parent;
          }
        } else {
          let referenceNode = toBeRemovedNode._previousSibling;
          let childNode = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(toBeRemovedNode._previousSibling, true, false);
          while (childNode !== null) {
            if (childNode !== null) {
              referenceNode = childNode;
            }
            childNode = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(toBeRemovedNode._previousSibling, childNode, true, false);
          }
          nodeIterator._reference = referenceNode;
        }
      }
      function updateASlotsName(element, localName, oldValue, value, namespace) {
        if (util_1.Guard.isSlot(element) && localName === "name" && namespace === null) {
          if (value === oldValue)
            return;
          if (value === null && oldValue === "")
            return;
          if (value === "" && oldValue === null)
            return;
          if (value === null || value === "") {
            element._name = "";
          } else {
            element._name = value;
          }
          (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree)((0, TreeAlgorithm_1.tree_rootNode)(element));
        }
      }
      function updateASlotablesName(element, localName, oldValue, value, namespace) {
        if (util_1.Guard.isSlotable(element) && localName === "slot" && namespace === null) {
          if (value === oldValue)
            return;
          if (value === null && oldValue === "")
            return;
          if (value === "" && oldValue === null)
            return;
          if (value === null || value === "") {
            element._name = "";
          } else {
            element._name = value;
          }
          if ((0, ShadowTreeAlgorithm_1.shadowTree_isAssigned)(element)) {
            (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotables)(element._assignedSlot);
          }
          (0, ShadowTreeAlgorithm_1.shadowTree_assignASlot)(element);
        }
      }
      function updateAnElementID(element, localName, value, namespace) {
        if (localName === "id" && namespace === null) {
          if (!value)
            element._uniqueIdentifier = void 0;
          else
            element._uniqueIdentifier = value;
        }
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/EventAlgorithm.js
  var require_EventAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/EventAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.event_setTheCanceledFlag = event_setTheCanceledFlag;
      exports.event_initialize = event_initialize;
      exports.event_createAnEvent = event_createAnEvent;
      exports.event_innerEventCreationSteps = event_innerEventCreationSteps;
      exports.event_dispatch = event_dispatch;
      exports.event_appendToAnEventPath = event_appendToAnEventPath;
      exports.event_invoke = event_invoke;
      exports.event_innerInvoke = event_innerInvoke;
      exports.event_fireAnEvent = event_fireAnEvent;
      exports.event_createLegacyEvent = event_createLegacyEvent;
      exports.event_getterEventHandlerIDLAttribute = event_getterEventHandlerIDLAttribute;
      exports.event_setterEventHandlerIDLAttribute = event_setterEventHandlerIDLAttribute;
      exports.event_determineTheTargetOfAnEventHandler = event_determineTheTargetOfAnEventHandler;
      exports.event_getTheCurrentValueOfAnEventHandler = event_getTheCurrentValueOfAnEventHandler;
      exports.event_activateAnEventHandler = event_activateAnEventHandler;
      exports.event_deactivateAnEventHandler = event_deactivateAnEventHandler;
      var DOMImpl_1 = require_DOMImpl();
      var interfaces_1 = require_interfaces2();
      var util_1 = require_util2();
      var CustomEventImpl_1 = require_CustomEventImpl();
      var EventImpl_1 = require_EventImpl();
      var DOMException_1 = require_DOMException();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      var ShadowTreeAlgorithm_1 = require_ShadowTreeAlgorithm();
      var DOMAlgorithm_1 = require_DOMAlgorithm();
      function event_setTheCanceledFlag(event) {
        if (event._cancelable && !event._inPassiveListenerFlag) {
          event._canceledFlag = true;
        }
      }
      function event_initialize(event, type, bubbles, cancelable) {
        event._initializedFlag = true;
        event._stopPropagationFlag = false;
        event._stopImmediatePropagationFlag = false;
        event._canceledFlag = false;
        event._isTrusted = false;
        event._target = null;
        event._type = type;
        event._bubbles = bubbles;
        event._cancelable = cancelable;
      }
      function event_createAnEvent(eventInterface, realm = void 0) {
        if (realm === void 0)
          realm = null;
        const dictionary = {};
        const event = event_innerEventCreationSteps(eventInterface, realm, /* @__PURE__ */ new Date(), dictionary);
        event._isTrusted = true;
        return event;
      }
      function event_innerEventCreationSteps(eventInterface, realm, time, dictionary) {
        const event = new eventInterface("");
        event._initializedFlag = true;
        event._timeStamp = time.getTime();
        Object.assign(event, dictionary);
        if (DOMImpl_1.dom.features.steps) {
          (0, DOMAlgorithm_1.dom_runEventConstructingSteps)(event);
        }
        return event;
      }
      function event_dispatch(event, target, legacyTargetOverrideFlag = false, legacyOutputDidListenersThrowFlag = { value: false }) {
        let clearTargets = false;
        event._dispatchFlag = true;
        let targetOverride = target;
        if (legacyTargetOverrideFlag) {
          const doc = target._associatedDocument;
          if (util_1.Guard.isDocumentNode(doc)) {
            targetOverride = doc;
          }
        }
        let activationTarget = null;
        let relatedTarget = (0, TreeAlgorithm_1.tree_retarget)(event._relatedTarget, target);
        if (target !== relatedTarget || target === event._relatedTarget) {
          let touchTargets = [];
          for (const touchTarget of event._touchTargetList) {
            touchTargets.push((0, TreeAlgorithm_1.tree_retarget)(touchTarget, target));
          }
          event_appendToAnEventPath(event, target, targetOverride, relatedTarget, touchTargets, false);
          const isActivationEvent = util_1.Guard.isMouseEvent(event) && event._type === "click";
          if (isActivationEvent && target._activationBehavior !== void 0) {
            activationTarget = target;
          }
          let slotable = util_1.Guard.isSlotable(target) && (0, ShadowTreeAlgorithm_1.shadowTree_isAssigned)(target) ? target : null;
          let slotInClosedTree = false;
          let parent = target._getTheParent(event);
          while (parent !== null && util_1.Guard.isNode(parent)) {
            if (slotable !== null) {
              if (!util_1.Guard.isSlot(parent)) {
                throw new Error("Parent node of a slotable should be a slot.");
              }
              slotable = null;
              const root = (0, TreeAlgorithm_1.tree_rootNode)(parent, true);
              if (util_1.Guard.isShadowRoot(root) && root._mode === "closed") {
                slotInClosedTree = true;
              }
            }
            if (util_1.Guard.isSlotable(parent) && (0, ShadowTreeAlgorithm_1.shadowTree_isAssigned)(parent)) {
              slotable = parent;
            }
            relatedTarget = (0, TreeAlgorithm_1.tree_retarget)(event._relatedTarget, parent);
            touchTargets = [];
            for (const touchTarget of event._touchTargetList) {
              touchTargets.push((0, TreeAlgorithm_1.tree_retarget)(touchTarget, parent));
            }
            if (util_1.Guard.isWindow(parent) || util_1.Guard.isNode(parent) && util_1.Guard.isNode(target) && (0, TreeAlgorithm_1.tree_isAncestorOf)((0, TreeAlgorithm_1.tree_rootNode)(target, true), parent, true, true)) {
              if (isActivationEvent && event._bubbles && activationTarget === null && parent._activationBehavior) {
                activationTarget = parent;
              }
              event_appendToAnEventPath(event, parent, null, relatedTarget, touchTargets, slotInClosedTree);
            } else if (parent === relatedTarget) {
              parent = null;
            } else {
              target = parent;
              if (isActivationEvent && activationTarget === null && target._activationBehavior) {
                activationTarget = target;
              }
              event_appendToAnEventPath(event, parent, target, relatedTarget, touchTargets, slotInClosedTree);
            }
            if (parent !== null) {
              parent = parent._getTheParent(event);
            }
            slotInClosedTree = false;
          }
          let clearTargetsStruct = null;
          const path = event._path;
          for (let i = path.length - 1; i >= 0; i--) {
            const struct = path[i];
            if (struct.shadowAdjustedTarget !== null) {
              clearTargetsStruct = struct;
              break;
            }
          }
          if (clearTargetsStruct !== null) {
            if (util_1.Guard.isNode(clearTargetsStruct.shadowAdjustedTarget) && util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(clearTargetsStruct.shadowAdjustedTarget, true))) {
              clearTargets = true;
            } else if (util_1.Guard.isNode(clearTargetsStruct.relatedTarget) && util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(clearTargetsStruct.relatedTarget, true))) {
              clearTargets = true;
            } else {
              for (let j = 0; j < clearTargetsStruct.touchTargetList.length; j++) {
                const struct = clearTargetsStruct.touchTargetList[j];
                if (util_1.Guard.isNode(struct) && util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(struct, true))) {
                  clearTargets = true;
                  break;
                }
              }
            }
          }
          if (activationTarget !== null && activationTarget._legacyPreActivationBehavior !== void 0) {
            activationTarget._legacyPreActivationBehavior(event);
          }
          for (let i = path.length - 1; i >= 0; i--) {
            const struct = path[i];
            if (struct.shadowAdjustedTarget !== null) {
              event._eventPhase = interfaces_1.EventPhase.AtTarget;
            } else {
              event._eventPhase = interfaces_1.EventPhase.Capturing;
            }
            event_invoke(struct, event, "capturing", legacyOutputDidListenersThrowFlag);
          }
          for (let i = 0; i < path.length; i++) {
            const struct = path[i];
            if (struct.shadowAdjustedTarget !== null) {
              event._eventPhase = interfaces_1.EventPhase.AtTarget;
            } else {
              if (!event._bubbles)
                continue;
              event._eventPhase = interfaces_1.EventPhase.Bubbling;
            }
            event_invoke(struct, event, "bubbling", legacyOutputDidListenersThrowFlag);
          }
        }
        event._eventPhase = interfaces_1.EventPhase.None;
        event._currentTarget = null;
        event._path = [];
        event._dispatchFlag = false;
        event._stopPropagationFlag = false;
        event._stopImmediatePropagationFlag = false;
        if (clearTargets) {
          event._target = null;
          event._relatedTarget = null;
          event._touchTargetList = [];
        }
        if (activationTarget !== null) {
          if (!event._canceledFlag && activationTarget._activationBehavior !== void 0) {
            activationTarget._activationBehavior(event);
          } else if (activationTarget._legacyCanceledActivationBehavior !== void 0) {
            activationTarget._legacyCanceledActivationBehavior(event);
          }
        }
        return !event._canceledFlag;
      }
      function event_appendToAnEventPath(event, invocationTarget, shadowAdjustedTarget, relatedTarget, touchTargets, slotInClosedTree) {
        let invocationTargetInShadowTree = false;
        if (util_1.Guard.isNode(invocationTarget) && util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(invocationTarget))) {
          invocationTargetInShadowTree = true;
        }
        let rootOfClosedTree = false;
        if (util_1.Guard.isShadowRoot(invocationTarget) && invocationTarget._mode === "closed") {
          rootOfClosedTree = true;
        }
        event._path.push({
          invocationTarget,
          invocationTargetInShadowTree,
          shadowAdjustedTarget,
          relatedTarget,
          touchTargetList: touchTargets,
          rootOfClosedTree,
          slotInClosedTree
        });
      }
      function event_invoke(struct, event, phase, legacyOutputDidListenersThrowFlag = { value: false }) {
        const path = event._path;
        let index = -1;
        for (let i = 0; i < path.length; i++) {
          if (path[i] === struct) {
            index = i;
            break;
          }
        }
        if (index !== -1) {
          let item = path[index];
          if (item.shadowAdjustedTarget !== null) {
            event._target = item.shadowAdjustedTarget;
          } else if (index > 0) {
            item = path[index - 1];
            if (item.shadowAdjustedTarget !== null) {
              event._target = item.shadowAdjustedTarget;
            }
          }
        }
        event._relatedTarget = struct.relatedTarget;
        event._touchTargetList = struct.touchTargetList;
        if (event._stopPropagationFlag)
          return;
        event._currentTarget = struct.invocationTarget;
        const currentTarget = event._currentTarget;
        const targetListeners = currentTarget._eventListenerList;
        let listeners = new Array(...targetListeners);
        const found = event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
        if (!found && event._isTrusted) {
          const originalEventType = event._type;
          if (originalEventType === "animationend") {
            event._type = "webkitAnimationEnd";
          } else if (originalEventType === "animationiteration") {
            event._type = "webkitAnimationIteration";
          } else if (originalEventType === "animationstart") {
            event._type = "webkitAnimationStart";
          } else if (originalEventType === "transitionend") {
            event._type = "webkitTransitionEnd";
          }
          event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
          event._type = originalEventType;
        }
      }
      function event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag = { value: false }) {
        let found = false;
        for (let i = 0; i < listeners.length; i++) {
          const listener = listeners[i];
          if (!listener.removed) {
            if (event._type !== listener.type)
              continue;
            found = true;
            if (phase === "capturing" && !listener.capture)
              continue;
            if (phase === "bubbling" && listener.capture)
              continue;
            if (listener.once && event._currentTarget !== null) {
              const impl = event._currentTarget;
              let index = -1;
              for (let i2 = 0; i2 < impl._eventListenerList.length; i2++) {
                if (impl._eventListenerList[i2] === listener) {
                  index = i2;
                  break;
                }
              }
              if (index !== -1) {
                impl._eventListenerList.splice(index, 1);
              }
            }
            const globalObject = void 0;
            let currentEvent = void 0;
            if (util_1.Guard.isWindow(globalObject)) {
              currentEvent = globalObject._currentEvent;
              if (struct.invocationTargetInShadowTree === false) {
                globalObject._currentEvent = event;
              }
            }
            if (listener.passive)
              event._inPassiveListenerFlag = true;
            try {
              listener.callback.handleEvent.call(event._currentTarget, event);
            } catch (err) {
              legacyOutputDidListenersThrowFlag.value = true;
            }
            if (listener.passive)
              event._inPassiveListenerFlag = false;
            if (util_1.Guard.isWindow(globalObject)) {
              globalObject._currentEvent = currentEvent;
            }
            if (event._stopImmediatePropagationFlag)
              return found;
          }
        }
        return found;
      }
      function event_fireAnEvent(e, target, eventConstructor, idlAttributes, legacyTargetOverrideFlag) {
        if (eventConstructor === void 0) {
          eventConstructor = EventImpl_1.EventImpl;
        }
        const event = event_createAnEvent(eventConstructor);
        event._type = e;
        if (idlAttributes) {
          for (const key in idlAttributes) {
            const idlObj = event;
            idlObj[key] = idlAttributes[key];
          }
        }
        return event_dispatch(event, target, legacyTargetOverrideFlag);
      }
      function event_createLegacyEvent(eventInterface) {
        let constructor = null;
        switch (eventInterface.toLowerCase()) {
          case "beforeunloadevent":
            break;
          case "compositionevent":
            break;
          case "customevent":
            constructor = CustomEventImpl_1.CustomEventImpl;
            break;
          case "devicemotionevent":
            break;
          case "deviceorientationevent":
            break;
          case "dragevent":
            break;
          case "event":
          case "events":
            constructor = EventImpl_1.EventImpl;
            break;
          case "focusevent":
            break;
          case "hashchangeevent":
            break;
          case "htmlevents":
            break;
          case "keyboardevent":
            break;
          case "messageevent":
            break;
          case "mouseevent":
            break;
          case "mouseevents":
            break;
          case "storageevent":
            break;
          case "svgevents":
            break;
          case "textevent":
            break;
          case "touchevent":
            break;
          case "uievent":
            break;
          case "uievents":
            break;
        }
        if (constructor === null) {
          throw new DOMException_1.NotSupportedError(`Event constructor not found for interface ${eventInterface}.`);
        }
        const event = new constructor("");
        event._type = "";
        event._timeStamp = (/* @__PURE__ */ new Date()).getTime();
        event._isTrusted = false;
        event._initializedFlag = false;
        return event;
      }
      function event_getterEventHandlerIDLAttribute(thisObj, name) {
        const eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
        if (eventTarget === null)
          return null;
        return event_getTheCurrentValueOfAnEventHandler(eventTarget, name);
      }
      function event_setterEventHandlerIDLAttribute(thisObj, name, value) {
        const eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
        if (eventTarget === null)
          return;
        if (value === null) {
          event_deactivateAnEventHandler(eventTarget, name);
        } else {
          const handlerMap = eventTarget._eventHandlerMap;
          const eventHandler = handlerMap["onabort"];
          if (eventHandler !== void 0) {
            eventHandler.value = value;
          }
          event_activateAnEventHandler(eventTarget, name);
        }
      }
      function event_determineTheTargetOfAnEventHandler(eventTarget, name) {
        return null;
      }
      function event_getTheCurrentValueOfAnEventHandler(eventTarget, name) {
        return null;
      }
      function event_activateAnEventHandler(eventTarget, name) {
      }
      function event_deactivateAnEventHandler(eventTarget, name) {
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/AbortAlgorithm.js
  var require_AbortAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/AbortAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.abort_add = abort_add;
      exports.abort_remove = abort_remove;
      exports.abort_signalAbort = abort_signalAbort;
      var EventAlgorithm_1 = require_EventAlgorithm();
      function abort_add(algorithm, signal) {
        if (signal._abortedFlag)
          return;
        signal._abortAlgorithms.add(algorithm);
      }
      function abort_remove(algorithm, signal) {
        signal._abortAlgorithms.delete(algorithm);
      }
      function abort_signalAbort(signal) {
        if (signal._abortedFlag)
          return;
        signal._abortedFlag = true;
        for (const algorithm of signal._abortAlgorithms) {
          algorithm.call(signal);
        }
        signal._abortAlgorithms.clear();
        (0, EventAlgorithm_1.event_fireAnEvent)("abort", signal);
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/CustomElementAlgorithm.js
  var require_CustomElementAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/CustomElementAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.customElement_isValidCustomElementName = customElement_isValidCustomElementName;
      exports.customElement_isValidElementName = customElement_isValidElementName;
      exports.customElement_isVoidElementName = customElement_isVoidElementName;
      exports.customElement_isValidShadowHostName = customElement_isValidShadowHostName;
      exports.customElement_enqueueACustomElementUpgradeReaction = customElement_enqueueACustomElementUpgradeReaction;
      exports.customElement_enqueueACustomElementCallbackReaction = customElement_enqueueACustomElementCallbackReaction;
      exports.customElement_upgrade = customElement_upgrade;
      exports.customElement_tryToUpgrade = customElement_tryToUpgrade;
      exports.customElement_lookUpACustomElementDefinition = customElement_lookUpACustomElementDefinition;
      var PotentialCustomElementName = /[a-z]([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*/;
      var NamesWithHyphen = /* @__PURE__ */ new Set([
        "annotation-xml",
        "color-profile",
        "font-face",
        "font-face-src",
        "font-face-uri",
        "font-face-format",
        "font-face-name",
        "missing-glyph"
      ]);
      var ElementNames = /* @__PURE__ */ new Set([
        "article",
        "aside",
        "blockquote",
        "body",
        "div",
        "footer",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "main",
        "nav",
        "p",
        "section",
        "span"
      ]);
      var VoidElementNames = /* @__PURE__ */ new Set([
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "menuitem",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]);
      var ShadowHostNames = /* @__PURE__ */ new Set([
        "article",
        "aside",
        "blockquote",
        "body",
        "div",
        "footer",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "header",
        "main",
        "nav",
        "p",
        "section",
        "span"
      ]);
      function customElement_isValidCustomElementName(name) {
        if (!PotentialCustomElementName.test(name))
          return false;
        if (NamesWithHyphen.has(name))
          return false;
        return true;
      }
      function customElement_isValidElementName(name) {
        return ElementNames.has(name);
      }
      function customElement_isVoidElementName(name) {
        return VoidElementNames.has(name);
      }
      function customElement_isValidShadowHostName(name) {
        return ShadowHostNames.has(name);
      }
      function customElement_enqueueACustomElementUpgradeReaction(element, definition) {
      }
      function customElement_enqueueACustomElementCallbackReaction(element, callbackName, args) {
      }
      function customElement_upgrade(definition, element) {
      }
      function customElement_tryToUpgrade(element) {
      }
      function customElement_lookUpACustomElementDefinition(document2, namespace, localName, is) {
        return null;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/TraversalAlgorithm.js
  var require_TraversalAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/TraversalAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.traversal_filter = traversal_filter;
      var interfaces_1 = require_interfaces2();
      var DOMException_1 = require_DOMException();
      function traversal_filter(traverser, node) {
        if (traverser._activeFlag) {
          throw new DOMException_1.InvalidStateError();
        }
        const n = node._nodeType - 1;
        const mask = 1 << n;
        if ((traverser.whatToShow & mask) === 0) {
          return interfaces_1.FilterResult.Skip;
        }
        if (!traverser.filter) {
          return interfaces_1.FilterResult.Accept;
        }
        traverser._activeFlag = true;
        let result = interfaces_1.FilterResult.Reject;
        try {
          result = traverser.filter.acceptNode(node);
        } catch (err) {
          traverser._activeFlag = false;
          throw err;
        }
        traverser._activeFlag = false;
        return result;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/NodeIteratorAlgorithm.js
  var require_NodeIteratorAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/NodeIteratorAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.nodeIterator_traverse = nodeIterator_traverse;
      exports.nodeIterator_iteratorList = nodeIterator_iteratorList;
      var DOMImpl_1 = require_DOMImpl();
      var interfaces_1 = require_interfaces2();
      var TraversalAlgorithm_1 = require_TraversalAlgorithm();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      function nodeIterator_traverse(iterator, forward) {
        let node = iterator._reference;
        let beforeNode = iterator._pointerBeforeReference;
        while (true) {
          if (forward) {
            if (!beforeNode) {
              const nextNode = (0, TreeAlgorithm_1.tree_getFollowingNode)(iterator._root, node);
              if (nextNode) {
                node = nextNode;
              } else {
                return null;
              }
            } else {
              beforeNode = false;
            }
          } else {
            if (beforeNode) {
              const prevNode = (0, TreeAlgorithm_1.tree_getPrecedingNode)(iterator.root, node);
              if (prevNode) {
                node = prevNode;
              } else {
                return null;
              }
            } else {
              beforeNode = true;
            }
          }
          const result = (0, TraversalAlgorithm_1.traversal_filter)(iterator, node);
          if (result === interfaces_1.FilterResult.Accept) {
            break;
          }
        }
        iterator._reference = node;
        iterator._pointerBeforeReference = beforeNode;
        return node;
      }
      function nodeIterator_iteratorList() {
        return DOMImpl_1.dom.window._iteratorList;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/XMLAlgorithm.js
  var require_XMLAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/XMLAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.xml_isName = xml_isName;
      exports.xml_isQName = xml_isQName;
      exports.xml_isLegalChar = xml_isLegalChar;
      exports.xml_isPubidChar = xml_isPubidChar;
      function xml_isName(name) {
        for (let i = 0; i < name.length; i++) {
          let n = name.charCodeAt(i);
          if (n >= 97 && n <= 122 || // [a-z]
          n >= 65 && n <= 90 || // [A-Z]
          n === 58 || n === 95 || // ':' or '_'
          n >= 192 && n <= 214 || n >= 216 && n <= 246 || n >= 248 && n <= 767 || n >= 880 && n <= 893 || n >= 895 && n <= 8191 || n >= 8204 && n <= 8205 || n >= 8304 && n <= 8591 || n >= 11264 && n <= 12271 || n >= 12289 && n <= 55295 || n >= 63744 && n <= 64975 || n >= 65008 && n <= 65533) {
            continue;
          } else if (i !== 0 && (n === 45 || n === 46 || // '-' or '.'
          n >= 48 && n <= 57 || // [0-9]
          n === 183 || n >= 768 && n <= 879 || n >= 8255 && n <= 8256)) {
            continue;
          }
          if (n >= 55296 && n <= 56319 && i < name.length - 1) {
            const n2 = name.charCodeAt(i + 1);
            if (n2 >= 56320 && n2 <= 57343) {
              n = (n - 55296) * 1024 + n2 - 56320 + 65536;
              i++;
              if (n >= 65536 && n <= 983039) {
                continue;
              }
            }
          }
          return false;
        }
        return true;
      }
      function xml_isQName(name) {
        let colonFound = false;
        for (let i = 0; i < name.length; i++) {
          let n = name.charCodeAt(i);
          if (n >= 97 && n <= 122 || // [a-z]
          n >= 65 && n <= 90 || // [A-Z]
          n === 95 || // '_'
          n >= 192 && n <= 214 || n >= 216 && n <= 246 || n >= 248 && n <= 767 || n >= 880 && n <= 893 || n >= 895 && n <= 8191 || n >= 8204 && n <= 8205 || n >= 8304 && n <= 8591 || n >= 11264 && n <= 12271 || n >= 12289 && n <= 55295 || n >= 63744 && n <= 64975 || n >= 65008 && n <= 65533) {
            continue;
          } else if (i !== 0 && (n === 45 || n === 46 || // '-' or '.'
          n >= 48 && n <= 57 || // [0-9]
          n === 183 || n >= 768 && n <= 879 || n >= 8255 && n <= 8256)) {
            continue;
          } else if (i !== 0 && n === 58) {
            if (colonFound)
              return false;
            if (i === name.length - 1)
              return false;
            colonFound = true;
            continue;
          }
          if (n >= 55296 && n <= 56319 && i < name.length - 1) {
            const n2 = name.charCodeAt(i + 1);
            if (n2 >= 56320 && n2 <= 57343) {
              n = (n - 55296) * 1024 + n2 - 56320 + 65536;
              i++;
              if (n >= 65536 && n <= 983039) {
                continue;
              }
            }
          }
          return false;
        }
        return true;
      }
      function xml_isLegalChar(chars) {
        for (let i = 0; i < chars.length; i++) {
          let n = chars.charCodeAt(i);
          if (n === 9 || n === 10 || n === 13 || n >= 32 && n <= 55295 || n >= 57344 && n <= 65533) {
            continue;
          }
          if (n >= 55296 && n <= 56319 && i < chars.length - 1) {
            const n2 = chars.charCodeAt(i + 1);
            if (n2 >= 56320 && n2 <= 57343) {
              n = (n - 55296) * 1024 + n2 - 56320 + 65536;
              i++;
              if (n >= 65536 && n <= 1114111) {
                continue;
              }
            }
          }
          return false;
        }
        return true;
      }
      function xml_isPubidChar(chars) {
        for (let i = 0; i < chars.length; i++) {
          const n = chars.charCodeAt(i);
          if (n >= 97 && n <= 122 || // [a-z]
          n >= 65 && n <= 90 || // [A-Z]
          n >= 39 && n <= 59 || // ['()*+,-./] | [0-9] | [:;]
          n === 32 || n === 13 || n === 10 || // #x20 | #xD | #xA
          n >= 35 && n <= 37 || // [#$%]
          n === 33 || // !
          n === 61 || n === 63 || n === 64 || n === 95) {
            continue;
          } else {
            return false;
          }
        }
        return true;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/NamespaceAlgorithm.js
  var require_NamespaceAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/NamespaceAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.namespace_validate = namespace_validate;
      exports.namespace_validateAndExtract = namespace_validateAndExtract;
      exports.namespace_extractQName = namespace_extractQName;
      var DOMException_1 = require_DOMException();
      var infra_1 = require_lib5();
      var XMLAlgorithm_1 = require_XMLAlgorithm();
      function namespace_validate(qualifiedName) {
        if (!(0, XMLAlgorithm_1.xml_isName)(qualifiedName))
          throw new DOMException_1.InvalidCharacterError(`Invalid XML name: ${qualifiedName}`);
        if (!(0, XMLAlgorithm_1.xml_isQName)(qualifiedName))
          throw new DOMException_1.InvalidCharacterError(`Invalid XML qualified name: ${qualifiedName}.`);
      }
      function namespace_validateAndExtract(namespace, qualifiedName) {
        if (!namespace)
          namespace = null;
        namespace_validate(qualifiedName);
        const parts = qualifiedName.split(":");
        const prefix = parts.length === 2 ? parts[0] : null;
        const localName = parts.length === 2 ? parts[1] : qualifiedName;
        if (prefix && namespace === null)
          throw new DOMException_1.NamespaceError("Qualified name includes a prefix but the namespace is null.");
        if (prefix === "xml" && namespace !== infra_1.namespace.XML)
          throw new DOMException_1.NamespaceError(`Qualified name includes the "xml" prefix but the namespace is not the XML namespace.`);
        if (namespace !== infra_1.namespace.XMLNS && (prefix === "xmlns" || qualifiedName === "xmlns"))
          throw new DOMException_1.NamespaceError(`Qualified name includes the "xmlns" prefix but the namespace is not the XMLNS namespace.`);
        if (namespace === infra_1.namespace.XMLNS && (prefix !== "xmlns" && qualifiedName !== "xmlns"))
          throw new DOMException_1.NamespaceError(`Qualified name does not include the "xmlns" prefix but the namespace is the XMLNS namespace.`);
        return [namespace, prefix, localName];
      }
      function namespace_extractQName(qualifiedName) {
        namespace_validate(qualifiedName);
        const parts = qualifiedName.split(":");
        const prefix = parts.length === 2 ? parts[0] : null;
        const localName = parts.length === 2 ? parts[1] : qualifiedName;
        return [prefix, localName];
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/DocumentAlgorithm.js
  var require_DocumentAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/DocumentAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.document_elementInterface = document_elementInterface;
      exports.document_internalCreateElementNS = document_internalCreateElementNS;
      exports.document_adopt = document_adopt;
      var DOMImpl_1 = require_DOMImpl();
      var util_1 = require_util2();
      var util_2 = require_lib4();
      var ElementImpl_1 = require_ElementImpl();
      var CustomElementAlgorithm_1 = require_CustomElementAlgorithm();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      var NamespaceAlgorithm_1 = require_NamespaceAlgorithm();
      var DOMAlgorithm_1 = require_DOMAlgorithm();
      var ElementAlgorithm_1 = require_ElementAlgorithm();
      var MutationAlgorithm_1 = require_MutationAlgorithm();
      function document_elementInterface(name, namespace) {
        return ElementImpl_1.ElementImpl;
      }
      function document_internalCreateElementNS(document2, namespace, qualifiedName, options) {
        const [ns, prefix, localName] = (0, NamespaceAlgorithm_1.namespace_validateAndExtract)(namespace, qualifiedName);
        let is = null;
        if (options !== void 0) {
          if ((0, util_2.isString)(options)) {
            is = options;
          } else {
            is = options.is;
          }
        }
        return (0, ElementAlgorithm_1.element_createAnElement)(document2, localName, ns, prefix, is, true);
      }
      function document_adopt(node, document2) {
        if (node._nodeDocument === document2 && node._parent === null) {
          return;
        }
        const oldDocument = node._nodeDocument;
        if (node._parent)
          (0, MutationAlgorithm_1.mutation_remove)(node, node._parent);
        if (document2 !== oldDocument) {
          let inclusiveDescendant = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(node, true, true);
          while (inclusiveDescendant !== null) {
            inclusiveDescendant._nodeDocument = document2;
            if (util_1.Guard.isElementNode(inclusiveDescendant)) {
              for (const attr of inclusiveDescendant._attributeList._asArray()) {
                attr._nodeDocument = document2;
              }
            }
            if (DOMImpl_1.dom.features.customElements) {
              if (util_1.Guard.isElementNode(inclusiveDescendant) && inclusiveDescendant._customElementState === "custom") {
                (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(inclusiveDescendant, "adoptedCallback", [oldDocument, document2]);
              }
            }
            if (DOMImpl_1.dom.features.steps) {
              (0, DOMAlgorithm_1.dom_runAdoptingSteps)(inclusiveDescendant, oldDocument);
            }
            inclusiveDescendant = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(node, inclusiveDescendant, true, true);
          }
        }
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/MutationAlgorithm.js
  var require_MutationAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/MutationAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mutation_ensurePreInsertionValidity = mutation_ensurePreInsertionValidity;
      exports.mutation_preInsert = mutation_preInsert;
      exports.mutation_insert = mutation_insert;
      exports.mutation_append = mutation_append;
      exports.mutation_replace = mutation_replace;
      exports.mutation_replaceAll = mutation_replaceAll;
      exports.mutation_preRemove = mutation_preRemove;
      exports.mutation_remove = mutation_remove;
      var DOMImpl_1 = require_DOMImpl();
      var DOMException_1 = require_DOMException();
      var interfaces_1 = require_interfaces2();
      var util_1 = require_util2();
      var util_2 = require_lib4();
      var infra_1 = require_lib5();
      var CustomElementAlgorithm_1 = require_CustomElementAlgorithm();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      var NodeIteratorAlgorithm_1 = require_NodeIteratorAlgorithm();
      var ShadowTreeAlgorithm_1 = require_ShadowTreeAlgorithm();
      var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
      var DOMAlgorithm_1 = require_DOMAlgorithm();
      var DocumentAlgorithm_1 = require_DocumentAlgorithm();
      function mutation_ensurePreInsertionValidity(node, parent, child) {
        const parentNodeType = parent._nodeType;
        const nodeNodeType = node._nodeType;
        const childNodeType = child ? child._nodeType : null;
        if (parentNodeType !== interfaces_1.NodeType.Document && parentNodeType !== interfaces_1.NodeType.DocumentFragment && parentNodeType !== interfaces_1.NodeType.Element)
          throw new DOMException_1.HierarchyRequestError(`Only document, document fragment and element nodes can contain child nodes. Parent node is ${parent.nodeName}.`);
        if ((0, TreeAlgorithm_1.tree_isHostIncludingAncestorOf)(parent, node, true))
          throw new DOMException_1.HierarchyRequestError(`The node to be inserted cannot be an inclusive ancestor of parent node. Node is ${node.nodeName}, parent node is ${parent.nodeName}.`);
        if (child !== null && child._parent !== parent)
          throw new DOMException_1.NotFoundError(`The reference child node cannot be found under parent node. Child node is ${child.nodeName}, parent node is ${parent.nodeName}.`);
        if (nodeNodeType !== interfaces_1.NodeType.DocumentFragment && nodeNodeType !== interfaces_1.NodeType.DocumentType && nodeNodeType !== interfaces_1.NodeType.Element && nodeNodeType !== interfaces_1.NodeType.Text && nodeNodeType !== interfaces_1.NodeType.ProcessingInstruction && nodeNodeType !== interfaces_1.NodeType.CData && nodeNodeType !== interfaces_1.NodeType.Comment)
          throw new DOMException_1.HierarchyRequestError(`Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is ${node.nodeName}.`);
        if (nodeNodeType === interfaces_1.NodeType.Text && parentNodeType === interfaces_1.NodeType.Document)
          throw new DOMException_1.HierarchyRequestError(`Cannot insert a text node as a child of a document node. Node is ${node.nodeName}.`);
        if (nodeNodeType === interfaces_1.NodeType.DocumentType && parentNodeType !== interfaces_1.NodeType.Document)
          throw new DOMException_1.HierarchyRequestError(`A document type node can only be inserted under a document node. Parent node is ${parent.nodeName}.`);
        if (parentNodeType === interfaces_1.NodeType.Document) {
          if (nodeNodeType === interfaces_1.NodeType.DocumentFragment) {
            let eleCount = 0;
            for (const childNode of node._children) {
              if (childNode._nodeType === interfaces_1.NodeType.Element)
                eleCount++;
              else if (childNode._nodeType === interfaces_1.NodeType.Text)
                throw new DOMException_1.HierarchyRequestError(`Cannot insert text a node as a child of a document node. Node is ${childNode.nodeName}.`);
            }
            if (eleCount > 1) {
              throw new DOMException_1.HierarchyRequestError(`A document node can only have one document element node. Document fragment to be inserted has ${eleCount} element nodes.`);
            } else if (eleCount === 1) {
              for (const ele of parent._children) {
                if (ele._nodeType === interfaces_1.NodeType.Element)
                  throw new DOMException_1.HierarchyRequestError(`The document node already has a document element node.`);
              }
              if (child) {
                if (childNodeType === interfaces_1.NodeType.DocumentType)
                  throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node.`);
                let doctypeChild = child._nextSibling;
                while (doctypeChild) {
                  if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                    throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node.`);
                  doctypeChild = doctypeChild._nextSibling;
                }
              }
            }
          } else if (nodeNodeType === interfaces_1.NodeType.Element) {
            for (const ele of parent._children) {
              if (ele._nodeType === interfaces_1.NodeType.Element)
                throw new DOMException_1.HierarchyRequestError(`Document already has a document element node. Node is ${node.nodeName}.`);
            }
            if (child) {
              if (childNodeType === interfaces_1.NodeType.DocumentType)
                throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node. Node is ${node.nodeName}.`);
              let doctypeChild = child._nextSibling;
              while (doctypeChild) {
                if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                  throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node. Node is ${node.nodeName}.`);
                doctypeChild = doctypeChild._nextSibling;
              }
            }
          } else if (nodeNodeType === interfaces_1.NodeType.DocumentType) {
            for (const ele of parent._children) {
              if (ele._nodeType === interfaces_1.NodeType.DocumentType)
                throw new DOMException_1.HierarchyRequestError(`Document already has a document type node. Node is ${node.nodeName}.`);
            }
            if (child) {
              let elementChild = child._previousSibling;
              while (elementChild) {
                if (elementChild._nodeType === interfaces_1.NodeType.Element)
                  throw new DOMException_1.HierarchyRequestError(`Cannot insert a document type node before an element node. Node is ${node.nodeName}.`);
                elementChild = elementChild._previousSibling;
              }
            } else {
              let elementChild = parent._firstChild;
              while (elementChild) {
                if (elementChild._nodeType === interfaces_1.NodeType.Element)
                  throw new DOMException_1.HierarchyRequestError(`Cannot insert a document type node before an element node. Node is ${node.nodeName}.`);
                elementChild = elementChild._nextSibling;
              }
            }
          }
        }
      }
      function mutation_preInsert(node, parent, child) {
        mutation_ensurePreInsertionValidity(node, parent, child);
        let referenceChild = child;
        if (referenceChild === node)
          referenceChild = node._nextSibling;
        (0, DocumentAlgorithm_1.document_adopt)(node, parent._nodeDocument);
        mutation_insert(node, parent, referenceChild);
        return node;
      }
      function mutation_insert(node, parent, child, suppressObservers) {
        if (child === null && node._nodeType !== interfaces_1.NodeType.DocumentFragment) {
          mutation_insert_single(node, parent, suppressObservers);
          return;
        }
        const count = node._nodeType === interfaces_1.NodeType.DocumentFragment ? node._children.size : 1;
        if (child !== null) {
          if (DOMImpl_1.dom.rangeList.size !== 0) {
            const index2 = (0, TreeAlgorithm_1.tree_index)(child);
            for (const range of DOMImpl_1.dom.rangeList) {
              if (range._start[0] === parent && range._start[1] > index2) {
                range._start[1] += count;
              }
              if (range._end[0] === parent && range._end[1] > index2) {
                range._end[1] += count;
              }
            }
          }
        }
        const nodes = node._nodeType === interfaces_1.NodeType.DocumentFragment ? new Array(...node._children) : [node];
        if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
          while (node._firstChild) {
            mutation_remove(node._firstChild, node, true);
          }
        }
        if (DOMImpl_1.dom.features.mutationObservers) {
          if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
            (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(node, [], nodes, null, null);
          }
        }
        const previousSibling = child ? child._previousSibling : parent._lastChild;
        let index = child === null ? -1 : (0, TreeAlgorithm_1.tree_index)(child);
        for (let i = 0; i < nodes.length; i++) {
          const node2 = nodes[i];
          if (util_1.Guard.isElementNode(node2)) {
            if (util_1.Guard.isDocumentNode(parent)) {
              parent._documentElement = node2;
            }
            if (!node2._nodeDocument._hasNamespaces && (node2._namespace !== null || node2._namespacePrefix !== null)) {
              node2._nodeDocument._hasNamespaces = true;
            }
          }
          node2._parent = parent;
          if (child === null) {
            infra_1.set.append(parent._children, node2);
          } else {
            infra_1.set.insert(parent._children, node2, index);
            index++;
          }
          if (parent._firstChild === null) {
            node2._previousSibling = null;
            node2._nextSibling = null;
            parent._firstChild = node2;
            parent._lastChild = node2;
          } else {
            const prev = child ? child._previousSibling : parent._lastChild;
            const next = child ? child : null;
            node2._previousSibling = prev;
            node2._nextSibling = next;
            if (prev)
              prev._nextSibling = node2;
            if (next)
              next._previousSibling = node2;
            if (!prev)
              parent._firstChild = node2;
            if (!next)
              parent._lastChild = node2;
          }
          if (DOMImpl_1.dom.features.slots) {
            if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node2)) {
              (0, ShadowTreeAlgorithm_1.shadowTree_assignASlot)(node2);
            }
          }
          if (DOMImpl_1.dom.features.steps) {
            if (util_1.Guard.isTextNode(node2)) {
              (0, DOMAlgorithm_1.dom_runChildTextContentChangeSteps)(parent);
            }
          }
          if (DOMImpl_1.dom.features.slots) {
            if (util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(parent)) && util_1.Guard.isSlot(parent) && (0, util_2.isEmpty)(parent._assignedNodes)) {
              (0, ShadowTreeAlgorithm_1.shadowTree_signalASlotChange)(parent);
            }
          }
          if (DOMImpl_1.dom.features.slots) {
            (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree)((0, TreeAlgorithm_1.tree_rootNode)(node2));
          }
          let inclusiveDescendant = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(node2, true, true);
          while (inclusiveDescendant !== null) {
            if (DOMImpl_1.dom.features.steps) {
              (0, DOMAlgorithm_1.dom_runInsertionSteps)(inclusiveDescendant);
            }
            if (DOMImpl_1.dom.features.customElements) {
              if (util_1.Guard.isElementNode(inclusiveDescendant) && (0, ShadowTreeAlgorithm_1.shadowTree_isConnected)(inclusiveDescendant)) {
                if (util_1.Guard.isCustomElementNode(inclusiveDescendant)) {
                  (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(inclusiveDescendant, "connectedCallback", []);
                } else {
                  (0, CustomElementAlgorithm_1.customElement_tryToUpgrade)(inclusiveDescendant);
                }
              }
            }
            inclusiveDescendant = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(node2, inclusiveDescendant, true, true);
          }
        }
        if (DOMImpl_1.dom.features.mutationObservers) {
          if (!suppressObservers) {
            (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(parent, nodes, [], previousSibling, child);
          }
        }
      }
      function mutation_insert_single(node, parent, suppressObservers) {
        const previousSibling = parent._lastChild;
        if (util_1.Guard.isElementNode(node)) {
          if (util_1.Guard.isDocumentNode(parent)) {
            parent._documentElement = node;
          }
          if (!node._nodeDocument._hasNamespaces && (node._namespace !== null || node._namespacePrefix !== null)) {
            node._nodeDocument._hasNamespaces = true;
          }
        }
        node._parent = parent;
        parent._children.add(node);
        if (parent._firstChild === null) {
          node._previousSibling = null;
          node._nextSibling = null;
          parent._firstChild = node;
          parent._lastChild = node;
        } else {
          const prev = parent._lastChild;
          node._previousSibling = prev;
          node._nextSibling = null;
          if (prev)
            prev._nextSibling = node;
          if (!prev)
            parent._firstChild = node;
          parent._lastChild = node;
        }
        if (DOMImpl_1.dom.features.slots) {
          if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node)) {
            (0, ShadowTreeAlgorithm_1.shadowTree_assignASlot)(node);
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          if (util_1.Guard.isTextNode(node)) {
            (0, DOMAlgorithm_1.dom_runChildTextContentChangeSteps)(parent);
          }
        }
        if (DOMImpl_1.dom.features.slots) {
          if (util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(parent)) && util_1.Guard.isSlot(parent) && (0, util_2.isEmpty)(parent._assignedNodes)) {
            (0, ShadowTreeAlgorithm_1.shadowTree_signalASlotChange)(parent);
          }
        }
        if (DOMImpl_1.dom.features.slots) {
          (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree)((0, TreeAlgorithm_1.tree_rootNode)(node));
        }
        if (DOMImpl_1.dom.features.steps) {
          (0, DOMAlgorithm_1.dom_runInsertionSteps)(node);
        }
        if (DOMImpl_1.dom.features.customElements) {
          if (util_1.Guard.isElementNode(node) && (0, ShadowTreeAlgorithm_1.shadowTree_isConnected)(node)) {
            if (util_1.Guard.isCustomElementNode(node)) {
              (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(node, "connectedCallback", []);
            } else {
              (0, CustomElementAlgorithm_1.customElement_tryToUpgrade)(node);
            }
          }
        }
        if (DOMImpl_1.dom.features.mutationObservers) {
          if (!suppressObservers) {
            (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(parent, [node], [], previousSibling, null);
          }
        }
      }
      function mutation_append(node, parent) {
        return mutation_preInsert(node, parent, null);
      }
      function mutation_replace(child, node, parent) {
        if (parent._nodeType !== interfaces_1.NodeType.Document && parent._nodeType !== interfaces_1.NodeType.DocumentFragment && parent._nodeType !== interfaces_1.NodeType.Element)
          throw new DOMException_1.HierarchyRequestError(`Only document, document fragment and element nodes can contain child nodes. Parent node is ${parent.nodeName}.`);
        if ((0, TreeAlgorithm_1.tree_isHostIncludingAncestorOf)(parent, node, true))
          throw new DOMException_1.HierarchyRequestError(`The node to be inserted cannot be an ancestor of parent node. Node is ${node.nodeName}, parent node is ${parent.nodeName}.`);
        if (child._parent !== parent)
          throw new DOMException_1.NotFoundError(`The reference child node cannot be found under parent node. Child node is ${child.nodeName}, parent node is ${parent.nodeName}.`);
        if (node._nodeType !== interfaces_1.NodeType.DocumentFragment && node._nodeType !== interfaces_1.NodeType.DocumentType && node._nodeType !== interfaces_1.NodeType.Element && node._nodeType !== interfaces_1.NodeType.Text && node._nodeType !== interfaces_1.NodeType.ProcessingInstruction && node._nodeType !== interfaces_1.NodeType.CData && node._nodeType !== interfaces_1.NodeType.Comment)
          throw new DOMException_1.HierarchyRequestError(`Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is ${node.nodeName}.`);
        if (node._nodeType === interfaces_1.NodeType.Text && parent._nodeType === interfaces_1.NodeType.Document)
          throw new DOMException_1.HierarchyRequestError(`Cannot insert a text node as a child of a document node. Node is ${node.nodeName}.`);
        if (node._nodeType === interfaces_1.NodeType.DocumentType && parent._nodeType !== interfaces_1.NodeType.Document)
          throw new DOMException_1.HierarchyRequestError(`A document type node can only be inserted under a document node. Parent node is ${parent.nodeName}.`);
        if (parent._nodeType === interfaces_1.NodeType.Document) {
          if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
            let eleCount = 0;
            for (const childNode of node._children) {
              if (childNode._nodeType === interfaces_1.NodeType.Element)
                eleCount++;
              else if (childNode._nodeType === interfaces_1.NodeType.Text)
                throw new DOMException_1.HierarchyRequestError(`Cannot insert text a node as a child of a document node. Node is ${childNode.nodeName}.`);
            }
            if (eleCount > 1) {
              throw new DOMException_1.HierarchyRequestError(`A document node can only have one document element node. Document fragment to be inserted has ${eleCount} element nodes.`);
            } else if (eleCount === 1) {
              for (const ele of parent._children) {
                if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
                  throw new DOMException_1.HierarchyRequestError(`The document node already has a document element node.`);
              }
              let doctypeChild = child._nextSibling;
              while (doctypeChild) {
                if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                  throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node.`);
                doctypeChild = doctypeChild._nextSibling;
              }
            }
          } else if (node._nodeType === interfaces_1.NodeType.Element) {
            for (const ele of parent._children) {
              if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
                throw new DOMException_1.HierarchyRequestError(`Document already has a document element node. Node is ${node.nodeName}.`);
            }
            let doctypeChild = child._nextSibling;
            while (doctypeChild) {
              if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                throw new DOMException_1.HierarchyRequestError(`Cannot insert an element node before a document type node. Node is ${node.nodeName}.`);
              doctypeChild = doctypeChild._nextSibling;
            }
          } else if (node._nodeType === interfaces_1.NodeType.DocumentType) {
            for (const ele of parent._children) {
              if (ele._nodeType === interfaces_1.NodeType.DocumentType && ele !== child)
                throw new DOMException_1.HierarchyRequestError(`Document already has a document type node. Node is ${node.nodeName}.`);
            }
            let elementChild = child._previousSibling;
            while (elementChild) {
              if (elementChild._nodeType === interfaces_1.NodeType.Element)
                throw new DOMException_1.HierarchyRequestError(`Cannot insert a document type node before an element node. Node is ${node.nodeName}.`);
              elementChild = elementChild._previousSibling;
            }
          }
        }
        let referenceChild = child._nextSibling;
        if (referenceChild === node)
          referenceChild = node._nextSibling;
        let previousSibling = child._previousSibling;
        (0, DocumentAlgorithm_1.document_adopt)(node, parent._nodeDocument);
        const removedNodes = [];
        if (child._parent !== null) {
          removedNodes.push(child);
          mutation_remove(child, child._parent, true);
        }
        let nodes = [];
        if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
          nodes = Array.from(node._children);
        } else {
          nodes.push(node);
        }
        mutation_insert(node, parent, referenceChild, true);
        if (DOMImpl_1.dom.features.mutationObservers) {
          (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(parent, nodes, removedNodes, previousSibling, referenceChild);
        }
        return child;
      }
      function mutation_replaceAll(node, parent) {
        if (node !== null) {
          (0, DocumentAlgorithm_1.document_adopt)(node, parent._nodeDocument);
        }
        const removedNodes = Array.from(parent._children);
        let addedNodes = [];
        if (node && node._nodeType === interfaces_1.NodeType.DocumentFragment) {
          addedNodes = Array.from(node._children);
        } else if (node !== null) {
          addedNodes.push(node);
        }
        for (const childNode of removedNodes) {
          mutation_remove(childNode, parent, true);
        }
        if (node !== null) {
          mutation_insert(node, parent, null, true);
        }
        if (DOMImpl_1.dom.features.mutationObservers) {
          (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(parent, addedNodes, removedNodes, null, null);
        }
      }
      function mutation_preRemove(child, parent) {
        if (child._parent !== parent)
          throw new DOMException_1.NotFoundError(`The child node cannot be found under parent node. Child node is ${child.nodeName}, parent node is ${parent.nodeName}.`);
        mutation_remove(child, parent);
        return child;
      }
      function mutation_remove(node, parent, suppressObservers) {
        if (DOMImpl_1.dom.rangeList.size !== 0) {
          const index = (0, TreeAlgorithm_1.tree_index)(node);
          for (const range of DOMImpl_1.dom.rangeList) {
            if ((0, TreeAlgorithm_1.tree_isDescendantOf)(node, range._start[0], true)) {
              range._start = [parent, index];
            }
            if ((0, TreeAlgorithm_1.tree_isDescendantOf)(node, range._end[0], true)) {
              range._end = [parent, index];
            }
            if (range._start[0] === parent && range._start[1] > index) {
              range._start[1]--;
            }
            if (range._end[0] === parent && range._end[1] > index) {
              range._end[1]--;
            }
          }
          for (const range of DOMImpl_1.dom.rangeList) {
            if (range._start[0] === parent && range._start[1] > index) {
              range._start[1] -= 1;
            }
            if (range._end[0] === parent && range._end[1] > index) {
              range._end[1] -= 1;
            }
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          for (const iterator of (0, NodeIteratorAlgorithm_1.nodeIterator_iteratorList)()) {
            if (iterator._root._nodeDocument === node._nodeDocument) {
              (0, DOMAlgorithm_1.dom_runNodeIteratorPreRemovingSteps)(iterator, node);
            }
          }
        }
        const oldPreviousSibling = node._previousSibling;
        const oldNextSibling = node._nextSibling;
        if (util_1.Guard.isDocumentNode(parent) && util_1.Guard.isElementNode(node)) {
          parent._documentElement = null;
        }
        node._parent = null;
        parent._children.delete(node);
        const prev = node._previousSibling;
        const next = node._nextSibling;
        node._previousSibling = null;
        node._nextSibling = null;
        if (prev)
          prev._nextSibling = next;
        if (next)
          next._previousSibling = prev;
        if (!prev)
          parent._firstChild = next;
        if (!next)
          parent._lastChild = prev;
        if (DOMImpl_1.dom.features.slots) {
          if (util_1.Guard.isSlotable(node) && node._assignedSlot !== null && (0, ShadowTreeAlgorithm_1.shadowTree_isAssigned)(node)) {
            (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotables)(node._assignedSlot);
          }
        }
        if (DOMImpl_1.dom.features.slots) {
          if (util_1.Guard.isShadowRoot((0, TreeAlgorithm_1.tree_rootNode)(parent)) && util_1.Guard.isSlot(parent) && (0, util_2.isEmpty)(parent._assignedNodes)) {
            (0, ShadowTreeAlgorithm_1.shadowTree_signalASlotChange)(parent);
          }
        }
        if (DOMImpl_1.dom.features.slots) {
          const descendant2 = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(node, true, false, (e) => util_1.Guard.isSlot(e));
          if (descendant2 !== null) {
            (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree)((0, TreeAlgorithm_1.tree_rootNode)(parent));
            (0, ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree)(node);
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          (0, DOMAlgorithm_1.dom_runRemovingSteps)(node, parent);
        }
        if (DOMImpl_1.dom.features.customElements) {
          if (util_1.Guard.isCustomElementNode(node)) {
            (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(node, "disconnectedCallback", []);
          }
        }
        let descendant = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(node, false, true);
        while (descendant !== null) {
          if (DOMImpl_1.dom.features.steps) {
            (0, DOMAlgorithm_1.dom_runRemovingSteps)(descendant, node);
          }
          if (DOMImpl_1.dom.features.customElements) {
            if (util_1.Guard.isCustomElementNode(descendant)) {
              (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(descendant, "disconnectedCallback", []);
            }
          }
          descendant = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(node, descendant, false, true);
        }
        if (DOMImpl_1.dom.features.mutationObservers) {
          let inclusiveAncestor = (0, TreeAlgorithm_1.tree_getFirstAncestorNode)(parent, true);
          while (inclusiveAncestor !== null) {
            for (const registered of inclusiveAncestor._registeredObserverList) {
              if (registered.options.subtree) {
                node._registeredObserverList.push({
                  observer: registered.observer,
                  options: registered.options,
                  source: registered
                });
              }
            }
            inclusiveAncestor = (0, TreeAlgorithm_1.tree_getNextAncestorNode)(parent, inclusiveAncestor, true);
          }
        }
        if (DOMImpl_1.dom.features.mutationObservers) {
          if (!suppressObservers) {
            (0, MutationObserverAlgorithm_1.observer_queueTreeMutationRecord)(parent, [], [node], oldPreviousSibling, oldNextSibling);
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          if (util_1.Guard.isTextNode(node)) {
            (0, DOMAlgorithm_1.dom_runChildTextContentChangeSteps)(parent);
          }
        }
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/ElementAlgorithm.js
  var require_ElementAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/ElementAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.element_has = element_has;
      exports.element_change = element_change;
      exports.element_append = element_append;
      exports.element_remove = element_remove;
      exports.element_replace = element_replace;
      exports.element_getAnAttributeByName = element_getAnAttributeByName;
      exports.element_getAnAttributeByNamespaceAndLocalName = element_getAnAttributeByNamespaceAndLocalName;
      exports.element_getAnAttributeValue = element_getAnAttributeValue;
      exports.element_setAnAttribute = element_setAnAttribute;
      exports.element_setAnAttributeValue = element_setAnAttributeValue;
      exports.element_removeAnAttributeByName = element_removeAnAttributeByName;
      exports.element_removeAnAttributeByNamespaceAndLocalName = element_removeAnAttributeByNamespaceAndLocalName;
      exports.element_createAnElement = element_createAnElement;
      exports.element_insertAdjacent = element_insertAdjacent;
      var DOMImpl_1 = require_DOMImpl();
      var infra_1 = require_lib5();
      var util_1 = require_util2();
      var DOMException_1 = require_DOMException();
      var CreateAlgorithm_1 = require_CreateAlgorithm();
      var CustomElementAlgorithm_1 = require_CustomElementAlgorithm();
      var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
      var DOMAlgorithm_1 = require_DOMAlgorithm();
      var MutationAlgorithm_1 = require_MutationAlgorithm();
      var DocumentAlgorithm_1 = require_DocumentAlgorithm();
      function element_has(attribute, element) {
        return element._attributeList._asArray().indexOf(attribute) !== -1;
      }
      function element_change(attribute, element, value) {
        if (DOMImpl_1.dom.features.mutationObservers) {
          (0, MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord)(element, attribute._localName, attribute._namespace, attribute._value);
        }
        if (DOMImpl_1.dom.features.customElements) {
          if (util_1.Guard.isCustomElementNode(element)) {
            (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(element, "attributeChangedCallback", [attribute._localName, attribute._value, value, attribute._namespace]);
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          (0, DOMAlgorithm_1.dom_runAttributeChangeSteps)(element, attribute._localName, attribute._value, value, attribute._namespace);
        }
        attribute._value = value;
      }
      function element_append(attribute, element) {
        if (DOMImpl_1.dom.features.mutationObservers) {
          (0, MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord)(element, attribute._localName, attribute._namespace, null);
        }
        if (DOMImpl_1.dom.features.customElements) {
          if (util_1.Guard.isCustomElementNode(element)) {
            (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(element, "attributeChangedCallback", [attribute._localName, null, attribute._value, attribute._namespace]);
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          (0, DOMAlgorithm_1.dom_runAttributeChangeSteps)(element, attribute._localName, null, attribute._value, attribute._namespace);
        }
        element._attributeList._asArray().push(attribute);
        attribute._element = element;
        if (!element._nodeDocument._hasNamespaces && (attribute._namespace !== null || attribute._namespacePrefix !== null || attribute._localName === "xmlns")) {
          element._nodeDocument._hasNamespaces = true;
        }
      }
      function element_remove(attribute, element) {
        if (DOMImpl_1.dom.features.mutationObservers) {
          (0, MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord)(element, attribute._localName, attribute._namespace, attribute._value);
        }
        if (DOMImpl_1.dom.features.customElements) {
          if (util_1.Guard.isCustomElementNode(element)) {
            (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(element, "attributeChangedCallback", [attribute._localName, attribute._value, null, attribute._namespace]);
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          (0, DOMAlgorithm_1.dom_runAttributeChangeSteps)(element, attribute._localName, attribute._value, null, attribute._namespace);
        }
        const index = element._attributeList._asArray().indexOf(attribute);
        element._attributeList._asArray().splice(index, 1);
        attribute._element = null;
      }
      function element_replace(oldAttr, newAttr, element) {
        if (DOMImpl_1.dom.features.mutationObservers) {
          (0, MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord)(element, oldAttr._localName, oldAttr._namespace, oldAttr._value);
        }
        if (DOMImpl_1.dom.features.customElements) {
          if (util_1.Guard.isCustomElementNode(element)) {
            (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction)(element, "attributeChangedCallback", [oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace]);
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          (0, DOMAlgorithm_1.dom_runAttributeChangeSteps)(element, oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace);
        }
        const index = element._attributeList._asArray().indexOf(oldAttr);
        if (index !== -1) {
          element._attributeList._asArray()[index] = newAttr;
        }
        oldAttr._element = null;
        newAttr._element = element;
        if (!element._nodeDocument._hasNamespaces && (newAttr._namespace !== null || newAttr._namespacePrefix !== null || newAttr._localName === "xmlns")) {
          element._nodeDocument._hasNamespaces = true;
        }
      }
      function element_getAnAttributeByName(qualifiedName, element) {
        if (element._namespace === infra_1.namespace.HTML && element._nodeDocument._type === "html") {
          qualifiedName = qualifiedName.toLowerCase();
        }
        return element._attributeList._asArray().find((attr) => attr._qualifiedName === qualifiedName) || null;
      }
      function element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
        const ns = namespace || null;
        return element._attributeList._asArray().find((attr) => attr._namespace === ns && attr._localName === localName) || null;
      }
      function element_getAnAttributeValue(element, localName, namespace = "") {
        const attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
        if (attr === null)
          return "";
        else
          return attr._value;
      }
      function element_setAnAttribute(attr, element) {
        if (attr._element !== null && attr._element !== element)
          throw new DOMException_1.InUseAttributeError(`This attribute already exists in the document: ${attr._qualifiedName} as a child of ${attr._element._qualifiedName}.`);
        const oldAttr = element_getAnAttributeByNamespaceAndLocalName(attr._namespace || "", attr._localName, element);
        if (oldAttr === attr)
          return attr;
        if (oldAttr !== null) {
          element_replace(oldAttr, attr, element);
        } else {
          element_append(attr, element);
        }
        return oldAttr;
      }
      function element_setAnAttributeValue(element, localName, value, prefix = null, namespace = null) {
        const attribute = element_getAnAttributeByNamespaceAndLocalName(namespace || "", localName, element);
        if (attribute === null) {
          const newAttr = (0, CreateAlgorithm_1.create_attr)(element._nodeDocument, localName);
          newAttr._namespace = namespace;
          newAttr._namespacePrefix = prefix;
          newAttr._value = value;
          element_append(newAttr, element);
          return;
        }
        element_change(attribute, element, value);
      }
      function element_removeAnAttributeByName(qualifiedName, element) {
        const attr = element_getAnAttributeByName(qualifiedName, element);
        if (attr !== null) {
          element_remove(attr, element);
        }
        return attr;
      }
      function element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
        const attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
        if (attr !== null) {
          element_remove(attr, element);
        }
        return attr;
      }
      function element_createAnElement(document2, localName, namespace, prefix = null, is = null, synchronousCustomElementsFlag = false) {
        let result = null;
        if (!DOMImpl_1.dom.features.customElements) {
          result = (0, CreateAlgorithm_1.create_element)(document2, localName, namespace, prefix);
          result._customElementState = "uncustomized";
          result._customElementDefinition = null;
          result._is = is;
          return result;
        }
        const definition = (0, CustomElementAlgorithm_1.customElement_lookUpACustomElementDefinition)(document2, namespace, localName, is);
        if (definition !== null && definition.name !== definition.localName) {
          const elemenInterface = (0, DocumentAlgorithm_1.document_elementInterface)(localName, infra_1.namespace.HTML);
          result = new elemenInterface();
          result._localName = localName;
          result._namespace = infra_1.namespace.HTML;
          result._namespacePrefix = prefix;
          result._customElementState = "undefined";
          result._customElementDefinition = null;
          result._is = is;
          result._nodeDocument = document2;
          if (synchronousCustomElementsFlag) {
            (0, CustomElementAlgorithm_1.customElement_upgrade)(definition, result);
          } else {
            (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction)(result, definition);
          }
        } else if (definition !== null) {
          if (synchronousCustomElementsFlag) {
            try {
              const C = definition.constructor;
              const result2 = new C();
              console.assert(result2._customElementState !== void 0);
              console.assert(result2._customElementDefinition !== void 0);
              console.assert(result2._namespace === infra_1.namespace.HTML);
              if (result2._attributeList.length !== 0)
                throw new DOMException_1.NotSupportedError("Custom element already has attributes.");
              if (result2._children.size !== 0)
                throw new DOMException_1.NotSupportedError("Custom element already has child nodes.");
              if (result2._parent !== null)
                throw new DOMException_1.NotSupportedError("Custom element already has a parent node.");
              if (result2._nodeDocument !== document2)
                throw new DOMException_1.NotSupportedError("Custom element is already in a document.");
              if (result2._localName !== localName)
                throw new DOMException_1.NotSupportedError("Custom element has a different local name.");
              result2._namespacePrefix = prefix;
              result2._is = null;
            } catch (e) {
              result = (0, CreateAlgorithm_1.create_htmlUnknownElement)(document2, localName, infra_1.namespace.HTML, prefix);
              result._customElementState = "failed";
              result._customElementDefinition = null;
              result._is = null;
            }
          } else {
            result = (0, CreateAlgorithm_1.create_htmlElement)(document2, localName, infra_1.namespace.HTML, prefix);
            result._customElementState = "undefined";
            result._customElementDefinition = null;
            result._is = null;
            (0, CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction)(result, definition);
          }
        } else {
          const elementInterface = (0, DocumentAlgorithm_1.document_elementInterface)(localName, namespace);
          result = new elementInterface();
          result._localName = localName;
          result._namespace = namespace;
          result._namespacePrefix = prefix;
          result._customElementState = "uncustomized";
          result._customElementDefinition = null;
          result._is = is;
          result._nodeDocument = document2;
          if (namespace === infra_1.namespace.HTML && (is !== null || (0, CustomElementAlgorithm_1.customElement_isValidCustomElementName)(localName))) {
            result._customElementState = "undefined";
          }
        }
        if (result === null) {
          throw new Error("Unable to create element.");
        }
        return result;
      }
      function element_insertAdjacent(element, where, node) {
        switch (where.toLowerCase()) {
          case "beforebegin":
            if (element._parent === null)
              return null;
            return (0, MutationAlgorithm_1.mutation_preInsert)(node, element._parent, element);
          case "afterbegin":
            return (0, MutationAlgorithm_1.mutation_preInsert)(node, element, element._firstChild);
          case "beforeend":
            return (0, MutationAlgorithm_1.mutation_preInsert)(node, element, null);
          case "afterend":
            if (element._parent === null)
              return null;
            return (0, MutationAlgorithm_1.mutation_preInsert)(node, element._parent, element._nextSibling);
          default:
            throw new DOMException_1.SyntaxError(`Invalid 'where' argument. "beforebegin", "afterbegin", "beforeend" or "afterend" expected`);
        }
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/AttrAlgorithm.js
  var require_AttrAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/AttrAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.attr_setAnExistingAttributeValue = attr_setAnExistingAttributeValue;
      var ElementAlgorithm_1 = require_ElementAlgorithm();
      function attr_setAnExistingAttributeValue(attribute, value) {
        if (attribute._element === null) {
          attribute._value = value;
        } else {
          (0, ElementAlgorithm_1.element_change)(attribute, attribute._element, value);
        }
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/BoundaryPointAlgorithm.js
  var require_BoundaryPointAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/BoundaryPointAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.boundaryPoint_position = boundaryPoint_position;
      var interfaces_1 = require_interfaces2();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      function boundaryPoint_position(bp, relativeTo) {
        const nodeA = bp[0];
        const offsetA = bp[1];
        const nodeB = relativeTo[0];
        const offsetB = relativeTo[1];
        console.assert((0, TreeAlgorithm_1.tree_rootNode)(nodeA) === (0, TreeAlgorithm_1.tree_rootNode)(nodeB), "Boundary points must share the same root node.");
        if (nodeA === nodeB) {
          if (offsetA === offsetB) {
            return interfaces_1.BoundaryPosition.Equal;
          } else if (offsetA < offsetB) {
            return interfaces_1.BoundaryPosition.Before;
          } else {
            return interfaces_1.BoundaryPosition.After;
          }
        }
        if ((0, TreeAlgorithm_1.tree_isFollowing)(nodeB, nodeA)) {
          const pos = boundaryPoint_position([nodeB, offsetB], [nodeA, offsetA]);
          if (pos === interfaces_1.BoundaryPosition.Before) {
            return interfaces_1.BoundaryPosition.After;
          } else if (pos === interfaces_1.BoundaryPosition.After) {
            return interfaces_1.BoundaryPosition.Before;
          }
        }
        if ((0, TreeAlgorithm_1.tree_isAncestorOf)(nodeB, nodeA)) {
          let child = nodeB;
          while (!(0, TreeAlgorithm_1.tree_isChildOf)(nodeA, child)) {
            if (child._parent !== null) {
              child = child._parent;
            }
          }
          if ((0, TreeAlgorithm_1.tree_index)(child) < offsetA) {
            return interfaces_1.BoundaryPosition.After;
          }
        }
        return interfaces_1.BoundaryPosition.Before;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/CharacterDataAlgorithm.js
  var require_CharacterDataAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/CharacterDataAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.characterData_replaceData = characterData_replaceData;
      exports.characterData_substringData = characterData_substringData;
      var DOMImpl_1 = require_DOMImpl();
      var util_1 = require_util2();
      var DOMException_1 = require_DOMException();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      var MutationObserverAlgorithm_1 = require_MutationObserverAlgorithm();
      var DOMAlgorithm_1 = require_DOMAlgorithm();
      function characterData_replaceData(node, offset, count, data) {
        const length = (0, TreeAlgorithm_1.tree_nodeLength)(node);
        if (offset > length) {
          throw new DOMException_1.IndexSizeError(`Offset exceeds character data length. Offset: ${offset}, Length: ${length}, Node is ${node.nodeName}.`);
        }
        if (offset + count > length) {
          count = length - offset;
        }
        if (DOMImpl_1.dom.features.mutationObservers) {
          (0, MutationObserverAlgorithm_1.observer_queueMutationRecord)("characterData", node, null, null, node._data, [], [], null, null);
        }
        const newData = node._data.substring(0, offset) + data + node._data.substring(offset + count);
        node._data = newData;
        for (const range of DOMImpl_1.dom.rangeList) {
          if (range._start[0] === node && range._start[1] > offset && range._start[1] <= offset + count) {
            range._start[1] = offset;
          }
          if (range._end[0] === node && range._end[1] > offset && range._end[1] <= offset + count) {
            range._end[1] = offset;
          }
          if (range._start[0] === node && range._start[1] > offset + count) {
            range._start[1] += data.length - count;
          }
          if (range._end[0] === node && range._end[1] > offset + count) {
            range._end[1] += data.length - count;
          }
        }
        if (DOMImpl_1.dom.features.steps) {
          if (util_1.Guard.isTextNode(node) && node._parent !== null) {
            (0, DOMAlgorithm_1.dom_runChildTextContentChangeSteps)(node._parent);
          }
        }
      }
      function characterData_substringData(node, offset, count) {
        const length = (0, TreeAlgorithm_1.tree_nodeLength)(node);
        if (offset > length) {
          throw new DOMException_1.IndexSizeError(`Offset exceeds character data length. Offset: ${offset}, Length: ${length}, Node is ${node.nodeName}.`);
        }
        if (offset + count > length) {
          return node._data.substr(offset);
        } else {
          return node._data.substr(offset, count);
        }
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/OrderedSetAlgorithm.js
  var require_OrderedSetAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/OrderedSetAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.orderedSet_parse = orderedSet_parse;
      exports.orderedSet_serialize = orderedSet_serialize;
      exports.orderedSet_sanitize = orderedSet_sanitize;
      exports.orderedSet_contains = orderedSet_contains;
      var infra_1 = require_lib5();
      function orderedSet_parse(value) {
        const inputTokens = infra_1.string.splitAStringOnASCIIWhitespace(value);
        return new Set(inputTokens);
      }
      function orderedSet_serialize(tokens) {
        return [...tokens].join(" ");
      }
      function orderedSet_sanitize(value) {
        return orderedSet_serialize(orderedSet_parse(value));
      }
      function orderedSet_contains(set1, set2, caseSensitive) {
        for (const val2 of set2) {
          let found = false;
          for (const val1 of set1) {
            if (caseSensitive) {
              if (val1 === val2) {
                found = true;
                break;
              }
            } else {
              if (val1.toUpperCase() === val2.toUpperCase()) {
                found = true;
                break;
              }
            }
          }
          if (!found)
            return false;
        }
        return true;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/DOMTokenListAlgorithm.js
  var require_DOMTokenListAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/DOMTokenListAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tokenList_validationSteps = tokenList_validationSteps;
      exports.tokenList_updateSteps = tokenList_updateSteps;
      exports.tokenList_serializeSteps = tokenList_serializeSteps;
      var OrderedSetAlgorithm_1 = require_OrderedSetAlgorithm();
      var DOMAlgorithm_1 = require_DOMAlgorithm();
      var ElementAlgorithm_1 = require_ElementAlgorithm();
      function tokenList_validationSteps(tokenList, token) {
        if (!(0, DOMAlgorithm_1.dom_hasSupportedTokens)(tokenList._attribute._localName)) {
          throw new TypeError(`There are no supported tokens defined for attribute name: '${tokenList._attribute._localName}'.`);
        }
        return (0, DOMAlgorithm_1.dom_getSupportedTokens)(tokenList._attribute._localName).has(token.toLowerCase());
      }
      function tokenList_updateSteps(tokenList) {
        if (!tokenList._element.hasAttribute(tokenList._attribute._localName) && tokenList._tokenSet.size === 0) {
          return;
        }
        (0, ElementAlgorithm_1.element_setAnAttributeValue)(tokenList._element, tokenList._attribute._localName, (0, OrderedSetAlgorithm_1.orderedSet_serialize)(tokenList._tokenSet));
      }
      function tokenList_serializeSteps(tokenList) {
        return (0, ElementAlgorithm_1.element_getAnAttributeValue)(tokenList._element, tokenList._attribute._localName);
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/EventTargetAlgorithm.js
  var require_EventTargetAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/EventTargetAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.eventTarget_flatten = eventTarget_flatten;
      exports.eventTarget_flattenMore = eventTarget_flattenMore;
      exports.eventTarget_addEventListener = eventTarget_addEventListener;
      exports.eventTarget_removeEventListener = eventTarget_removeEventListener;
      exports.eventTarget_removeAllEventListeners = eventTarget_removeAllEventListeners;
      var util_1 = require_lib4();
      function eventTarget_flatten(options) {
        if ((0, util_1.isBoolean)(options)) {
          return options;
        } else {
          return options.capture || false;
        }
      }
      function eventTarget_flattenMore(options) {
        const capture = eventTarget_flatten(options);
        let once = false;
        let passive = false;
        if (!(0, util_1.isBoolean)(options)) {
          once = options.once || false;
          passive = options.passive || false;
        }
        return [capture, passive, once];
      }
      function eventTarget_addEventListener(eventTarget, listener) {
        if (listener.callback === null)
          return;
        for (let i = 0; i < eventTarget._eventListenerList.length; i++) {
          const entry = eventTarget._eventListenerList[i];
          if (entry.type === listener.type && entry.callback.handleEvent === listener.callback.handleEvent && entry.capture === listener.capture) {
            return;
          }
        }
        eventTarget._eventListenerList.push(listener);
      }
      function eventTarget_removeEventListener(eventTarget, listener, index) {
        listener.removed = true;
        eventTarget._eventListenerList.splice(index, 1);
      }
      function eventTarget_removeAllEventListeners(eventTarget) {
        for (const e of eventTarget._eventListenerList) {
          e.removed = true;
        }
        eventTarget._eventListenerList.length = 0;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/NodeAlgorithm.js
  var require_NodeAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/NodeAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.node_stringReplaceAll = node_stringReplaceAll;
      exports.node_clone = node_clone;
      exports.node_equals = node_equals;
      exports.node_listOfElementsWithQualifiedName = node_listOfElementsWithQualifiedName;
      exports.node_listOfElementsWithNamespace = node_listOfElementsWithNamespace;
      exports.node_listOfElementsWithClassNames = node_listOfElementsWithClassNames;
      exports.node_locateANamespacePrefix = node_locateANamespacePrefix;
      exports.node_locateANamespace = node_locateANamespace;
      var DOMImpl_1 = require_DOMImpl();
      var util_1 = require_util2();
      var infra_1 = require_lib5();
      var CreateAlgorithm_1 = require_CreateAlgorithm();
      var OrderedSetAlgorithm_1 = require_OrderedSetAlgorithm();
      var DOMAlgorithm_1 = require_DOMAlgorithm();
      var MutationAlgorithm_1 = require_MutationAlgorithm();
      var ElementAlgorithm_1 = require_ElementAlgorithm();
      function node_stringReplaceAll(str, parent) {
        let node = null;
        if (str !== "") {
          node = (0, CreateAlgorithm_1.create_text)(parent._nodeDocument, str);
        }
        (0, MutationAlgorithm_1.mutation_replaceAll)(node, parent);
      }
      function node_clone(node, document2 = null, cloneChildrenFlag = false) {
        if (document2 === null)
          document2 = node._nodeDocument;
        let copy;
        if (util_1.Guard.isElementNode(node)) {
          copy = (0, ElementAlgorithm_1.element_createAnElement)(document2, node._localName, node._namespace, node._namespacePrefix, node._is, false);
          for (const attribute of node._attributeList) {
            const copyAttribute = node_clone(attribute, document2);
            (0, ElementAlgorithm_1.element_append)(copyAttribute, copy);
          }
        } else {
          if (util_1.Guard.isDocumentNode(node)) {
            const doc = (0, CreateAlgorithm_1.create_document)();
            doc._encoding = node._encoding;
            doc._contentType = node._contentType;
            doc._URL = node._URL;
            doc._origin = node._origin;
            doc._type = node._type;
            doc._mode = node._mode;
            copy = doc;
          } else if (util_1.Guard.isDocumentTypeNode(node)) {
            const doctype = (0, CreateAlgorithm_1.create_documentType)(document2, node._name, node._publicId, node._systemId);
            copy = doctype;
          } else if (util_1.Guard.isAttrNode(node)) {
            const attr = (0, CreateAlgorithm_1.create_attr)(document2, node.localName);
            attr._namespace = node._namespace;
            attr._namespacePrefix = node._namespacePrefix;
            attr._value = node._value;
            copy = attr;
          } else if (util_1.Guard.isExclusiveTextNode(node)) {
            copy = (0, CreateAlgorithm_1.create_text)(document2, node._data);
          } else if (util_1.Guard.isCDATASectionNode(node)) {
            copy = (0, CreateAlgorithm_1.create_cdataSection)(document2, node._data);
          } else if (util_1.Guard.isCommentNode(node)) {
            copy = (0, CreateAlgorithm_1.create_comment)(document2, node._data);
          } else if (util_1.Guard.isProcessingInstructionNode(node)) {
            copy = (0, CreateAlgorithm_1.create_processingInstruction)(document2, node._target, node._data);
          } else if (util_1.Guard.isDocumentFragmentNode(node)) {
            copy = (0, CreateAlgorithm_1.create_documentFragment)(document2);
          } else {
            copy = Object.create(node);
          }
        }
        if (util_1.Guard.isDocumentNode(copy)) {
          copy._nodeDocument = copy;
          document2 = copy;
        } else {
          copy._nodeDocument = document2;
        }
        if (DOMImpl_1.dom.features.steps) {
          (0, DOMAlgorithm_1.dom_runCloningSteps)(copy, node, document2, cloneChildrenFlag);
        }
        if (cloneChildrenFlag) {
          for (const child of node._children) {
            const childCopy = node_clone(child, document2, true);
            (0, MutationAlgorithm_1.mutation_append)(childCopy, copy);
          }
        }
        return copy;
      }
      function node_equals(a, b) {
        if (a._nodeType !== b._nodeType)
          return false;
        if (util_1.Guard.isDocumentTypeNode(a) && util_1.Guard.isDocumentTypeNode(b)) {
          if (a._name !== b._name || a._publicId !== b._publicId || a._systemId !== b._systemId)
            return false;
        } else if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
          if (a._namespace !== b._namespace || a._namespacePrefix !== b._namespacePrefix || a._localName !== b._localName || a._attributeList.length !== b._attributeList.length)
            return false;
        } else if (util_1.Guard.isAttrNode(a) && util_1.Guard.isAttrNode(b)) {
          if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value)
            return false;
        } else if (util_1.Guard.isProcessingInstructionNode(a) && util_1.Guard.isProcessingInstructionNode(b)) {
          if (a._target !== b._target || a._data !== b._data)
            return false;
        } else if (util_1.Guard.isCharacterDataNode(a) && util_1.Guard.isCharacterDataNode(b)) {
          if (a._data !== b._data)
            return false;
        }
        if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
          const attrMap = {};
          for (const attrA of a._attributeList) {
            attrMap[attrA._localName] = attrA;
          }
          for (const attrB of b._attributeList) {
            const attrA = attrMap[attrB._localName];
            if (!attrA)
              return false;
            if (!node_equals(attrA, attrB))
              return false;
          }
        }
        if (a._children.size !== b._children.size)
          return false;
        const itA = a._children[Symbol.iterator]();
        const itB = b._children[Symbol.iterator]();
        let resultA = itA.next();
        let resultB = itB.next();
        while (!resultA.done && !resultB.done) {
          const child1 = resultA.value;
          const child2 = resultB.value;
          if (!node_equals(child1, child2))
            return false;
          resultA = itA.next();
          resultB = itB.next();
        }
        return true;
      }
      function node_listOfElementsWithQualifiedName(qualifiedName, root) {
        if (qualifiedName === "*") {
          return (0, CreateAlgorithm_1.create_htmlCollection)(root);
        } else if (root._nodeDocument._type === "html") {
          return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
            if (ele._namespace === infra_1.namespace.HTML && ele._qualifiedName === qualifiedName.toLowerCase()) {
              return true;
            } else if (ele._namespace !== infra_1.namespace.HTML && ele._qualifiedName === qualifiedName) {
              return true;
            } else {
              return false;
            }
          });
        } else {
          return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
            return ele._qualifiedName === qualifiedName;
          });
        }
      }
      function node_listOfElementsWithNamespace(namespace, localName, root) {
        if (namespace === "")
          namespace = null;
        if (namespace === "*" && localName === "*") {
          return (0, CreateAlgorithm_1.create_htmlCollection)(root);
        } else if (namespace === "*") {
          return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
            return ele._localName === localName;
          });
        } else if (localName === "*") {
          return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
            return ele._namespace === namespace;
          });
        } else {
          return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
            return ele._localName === localName && ele._namespace === namespace;
          });
        }
      }
      function node_listOfElementsWithClassNames(classNames, root) {
        const classes = (0, OrderedSetAlgorithm_1.orderedSet_parse)(classNames);
        if (classes.size === 0) {
          return (0, CreateAlgorithm_1.create_htmlCollection)(root, () => false);
        }
        const caseSensitive = root._nodeDocument._mode !== "quirks";
        return (0, CreateAlgorithm_1.create_htmlCollection)(root, function(ele) {
          const eleClasses = ele.classList;
          return (0, OrderedSetAlgorithm_1.orderedSet_contains)(eleClasses._tokenSet, classes, caseSensitive);
        });
      }
      function node_locateANamespacePrefix(element, namespace) {
        if (element._namespace === namespace && element._namespacePrefix !== null) {
          return element._namespacePrefix;
        }
        for (let i = 0; i < element._attributeList.length; i++) {
          const attr = element._attributeList[i];
          if (attr._namespacePrefix === "xmlns" && attr._value === namespace) {
            return attr._localName;
          }
        }
        if (element._parent && util_1.Guard.isElementNode(element._parent)) {
          return node_locateANamespacePrefix(element._parent, namespace);
        }
        return null;
      }
      function node_locateANamespace(node, prefix) {
        if (util_1.Guard.isElementNode(node)) {
          if (node._namespace !== null && node._namespacePrefix === prefix) {
            return node._namespace;
          }
          for (let i = 0; i < node._attributeList.length; i++) {
            const attr = node._attributeList[i];
            if (attr._namespace === infra_1.namespace.XMLNS && attr._namespacePrefix === "xmlns" && attr._localName === prefix) {
              return attr._value || null;
            }
            if (prefix === null && attr._namespace === infra_1.namespace.XMLNS && attr._namespacePrefix === null && attr._localName === "xmlns") {
              return attr._value || null;
            }
          }
          if (node.parentElement === null)
            return null;
          return node_locateANamespace(node.parentElement, prefix);
        } else if (util_1.Guard.isDocumentNode(node)) {
          if (node.documentElement === null)
            return null;
          return node_locateANamespace(node.documentElement, prefix);
        } else if (util_1.Guard.isDocumentTypeNode(node) || util_1.Guard.isDocumentFragmentNode(node)) {
          return null;
        } else if (util_1.Guard.isAttrNode(node)) {
          if (node._element === null)
            return null;
          return node_locateANamespace(node._element, prefix);
        } else {
          if (!node._parent || !util_1.Guard.isElementNode(node._parent))
            return null;
          return node_locateANamespace(node._parent, prefix);
        }
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/ParentNodeAlgorithm.js
  var require_ParentNodeAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/ParentNodeAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parentNode_convertNodesIntoANode = parentNode_convertNodesIntoANode;
      var util_1 = require_lib4();
      var CreateAlgorithm_1 = require_CreateAlgorithm();
      function parentNode_convertNodesIntoANode(nodes, document2) {
        let node = null;
        for (let i = 0; i < nodes.length; i++) {
          const item = nodes[i];
          if ((0, util_1.isString)(item)) {
            const text = (0, CreateAlgorithm_1.create_text)(document2, item);
            nodes[i] = text;
          }
        }
        if (nodes.length === 1) {
          node = nodes[0];
        } else {
          node = (0, CreateAlgorithm_1.create_documentFragment)(document2);
          const ns = node;
          for (const item of nodes) {
            ns.appendChild(item);
          }
        }
        return node;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/TextAlgorithm.js
  var require_TextAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/TextAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.text_contiguousTextNodes = text_contiguousTextNodes;
      exports.text_contiguousExclusiveTextNodes = text_contiguousExclusiveTextNodes;
      exports.text_descendantTextContent = text_descendantTextContent;
      exports.text_split = text_split;
      var DOMImpl_1 = require_DOMImpl();
      var util_1 = require_util2();
      var DOMException_1 = require_DOMException();
      var CreateAlgorithm_1 = require_CreateAlgorithm();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      var CharacterDataAlgorithm_1 = require_CharacterDataAlgorithm();
      var MutationAlgorithm_1 = require_MutationAlgorithm();
      function text_contiguousTextNodes(node, self2 = false) {
        return {
          [Symbol.iterator]() {
            let currentNode = node;
            while (currentNode && util_1.Guard.isTextNode(currentNode._previousSibling)) {
              currentNode = currentNode._previousSibling;
            }
            return {
              next() {
                if (currentNode && (!self2 && currentNode === node)) {
                  if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                    currentNode = currentNode._nextSibling;
                  } else {
                    currentNode = null;
                  }
                }
                if (currentNode === null) {
                  return { done: true, value: null };
                } else {
                  const result = { done: false, value: currentNode };
                  if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                    currentNode = currentNode._nextSibling;
                  } else {
                    currentNode = null;
                  }
                  return result;
                }
              }
            };
          }
        };
      }
      function text_contiguousExclusiveTextNodes(node, self2 = false) {
        return {
          [Symbol.iterator]() {
            let currentNode = node;
            while (currentNode && util_1.Guard.isExclusiveTextNode(currentNode._previousSibling)) {
              currentNode = currentNode._previousSibling;
            }
            return {
              next() {
                if (currentNode && (!self2 && currentNode === node)) {
                  if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                    currentNode = currentNode._nextSibling;
                  } else {
                    currentNode = null;
                  }
                }
                if (currentNode === null) {
                  return { done: true, value: null };
                } else {
                  const result = { done: false, value: currentNode };
                  if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                    currentNode = currentNode._nextSibling;
                  } else {
                    currentNode = null;
                  }
                  return result;
                }
              }
            };
          }
        };
      }
      function text_descendantTextContent(node) {
        let contents = "";
        let text = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(node, false, false, (e) => util_1.Guard.isTextNode(e));
        while (text !== null) {
          contents += text._data;
          text = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(node, text, false, false, (e) => util_1.Guard.isTextNode(e));
        }
        return contents;
      }
      function text_split(node, offset) {
        const length = node._data.length;
        if (offset > length) {
          throw new DOMException_1.IndexSizeError();
        }
        const count = length - offset;
        const newData = (0, CharacterDataAlgorithm_1.characterData_substringData)(node, offset, count);
        const newNode = (0, CreateAlgorithm_1.create_text)(node._nodeDocument, newData);
        const parent = node._parent;
        if (parent !== null) {
          (0, MutationAlgorithm_1.mutation_insert)(newNode, parent, node._nextSibling);
          for (const range of DOMImpl_1.dom.rangeList) {
            if (range._start[0] === node && range._start[1] > offset) {
              range._start[0] = newNode;
              range._start[1] -= offset;
            }
            if (range._end[0] === node && range._end[1] > offset) {
              range._end[0] = newNode;
              range._end[1] -= offset;
            }
            const index = (0, TreeAlgorithm_1.tree_index)(node);
            if (range._start[0] === parent && range._start[1] === index + 1) {
              range._start[1]++;
            }
            if (range._end[0] === parent && range._end[1] === index + 1) {
              range._end[1]++;
            }
          }
        }
        (0, CharacterDataAlgorithm_1.characterData_replaceData)(node, offset, count, "");
        return newNode;
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/RangeAlgorithm.js
  var require_RangeAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/RangeAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.range_collapsed = range_collapsed;
      exports.range_root = range_root;
      exports.range_isContained = range_isContained;
      exports.range_isPartiallyContained = range_isPartiallyContained;
      exports.range_setTheStart = range_setTheStart;
      exports.range_setTheEnd = range_setTheEnd;
      exports.range_select = range_select;
      exports.range_extract = range_extract;
      exports.range_cloneTheContents = range_cloneTheContents;
      exports.range_insert = range_insert;
      exports.range_getContainedNodes = range_getContainedNodes;
      exports.range_getPartiallyContainedNodes = range_getPartiallyContainedNodes;
      var interfaces_1 = require_interfaces2();
      var DOMException_1 = require_DOMException();
      var util_1 = require_util2();
      var CreateAlgorithm_1 = require_CreateAlgorithm();
      var TreeAlgorithm_1 = require_TreeAlgorithm();
      var BoundaryPointAlgorithm_1 = require_BoundaryPointAlgorithm();
      var CharacterDataAlgorithm_1 = require_CharacterDataAlgorithm();
      var NodeAlgorithm_1 = require_NodeAlgorithm();
      var MutationAlgorithm_1 = require_MutationAlgorithm();
      var TextAlgorithm_1 = require_TextAlgorithm();
      function range_collapsed(range) {
        return range._startNode === range._endNode && range._startOffset === range._endOffset;
      }
      function range_root(range) {
        return (0, TreeAlgorithm_1.tree_rootNode)(range._startNode);
      }
      function range_isContained(node, range) {
        return (0, TreeAlgorithm_1.tree_rootNode)(node) === range_root(range) && (0, BoundaryPointAlgorithm_1.boundaryPoint_position)([node, 0], range._start) === interfaces_1.BoundaryPosition.After && (0, BoundaryPointAlgorithm_1.boundaryPoint_position)([node, (0, TreeAlgorithm_1.tree_nodeLength)(node)], range._end) === interfaces_1.BoundaryPosition.Before;
      }
      function range_isPartiallyContained(node, range) {
        const startCheck = (0, TreeAlgorithm_1.tree_isAncestorOf)(range._startNode, node, true);
        const endCheck = (0, TreeAlgorithm_1.tree_isAncestorOf)(range._endNode, node, true);
        return startCheck && !endCheck || !startCheck && endCheck;
      }
      function range_setTheStart(range, node, offset) {
        if (util_1.Guard.isDocumentTypeNode(node)) {
          throw new DOMException_1.InvalidNodeTypeError();
        }
        if (offset > (0, TreeAlgorithm_1.tree_nodeLength)(node)) {
          throw new DOMException_1.IndexSizeError();
        }
        const bp = [node, offset];
        if (range_root(range) !== (0, TreeAlgorithm_1.tree_rootNode)(node) || (0, BoundaryPointAlgorithm_1.boundaryPoint_position)(bp, range._end) === interfaces_1.BoundaryPosition.After) {
          range._end = bp;
        }
        range._start = bp;
      }
      function range_setTheEnd(range, node, offset) {
        if (util_1.Guard.isDocumentTypeNode(node)) {
          throw new DOMException_1.InvalidNodeTypeError();
        }
        if (offset > (0, TreeAlgorithm_1.tree_nodeLength)(node)) {
          throw new DOMException_1.IndexSizeError();
        }
        const bp = [node, offset];
        if (range_root(range) !== (0, TreeAlgorithm_1.tree_rootNode)(node) || (0, BoundaryPointAlgorithm_1.boundaryPoint_position)(bp, range._start) === interfaces_1.BoundaryPosition.Before) {
          range._start = bp;
        }
        range._end = bp;
      }
      function range_select(node, range) {
        const parent = node._parent;
        if (parent === null)
          throw new DOMException_1.InvalidNodeTypeError();
        const index = (0, TreeAlgorithm_1.tree_index)(node);
        range._start = [parent, index];
        range._end = [parent, index + 1];
      }
      function range_extract(range) {
        const fragment3 = (0, CreateAlgorithm_1.create_documentFragment)(range._startNode._nodeDocument);
        if (range_collapsed(range))
          return fragment3;
        const originalStartNode = range._startNode;
        const originalStartOffset = range._startOffset;
        const originalEndNode = range._endNode;
        const originalEndOffset = range._endOffset;
        if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
          const clone = (0, NodeAlgorithm_1.node_clone)(originalStartNode);
          clone._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
          (0, MutationAlgorithm_1.mutation_append)(clone, fragment3);
          (0, CharacterDataAlgorithm_1.characterData_replaceData)(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, "");
          return fragment3;
        }
        let commonAncestor = originalStartNode;
        while (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, commonAncestor, true)) {
          if (commonAncestor._parent === null) {
            throw new Error("Parent node  is null.");
          }
          commonAncestor = commonAncestor._parent;
        }
        let firstPartiallyContainedChild = null;
        if (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, originalStartNode, true)) {
          for (const node of commonAncestor._children) {
            if (range_isPartiallyContained(node, range)) {
              firstPartiallyContainedChild = node;
              break;
            }
          }
        }
        let lastPartiallyContainedChild = null;
        if (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalStartNode, originalEndNode, true)) {
          const children = [...commonAncestor._children];
          for (let i = children.length - 1; i > 0; i--) {
            const node = children[i];
            if (range_isPartiallyContained(node, range)) {
              lastPartiallyContainedChild = node;
              break;
            }
          }
        }
        const containedChildren = [];
        for (const child of commonAncestor._children) {
          if (range_isContained(child, range)) {
            if (util_1.Guard.isDocumentTypeNode(child)) {
              throw new DOMException_1.HierarchyRequestError();
            }
            containedChildren.push(child);
          }
        }
        let newNode;
        let newOffset;
        if ((0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, originalStartNode, true)) {
          newNode = originalStartNode;
          newOffset = originalStartOffset;
        } else {
          let referenceNode = originalStartNode;
          while (referenceNode._parent !== null && !(0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, referenceNode._parent)) {
            referenceNode = referenceNode._parent;
          }
          if (referenceNode._parent === null) {
            throw new Error("Parent node is null.");
          }
          newNode = referenceNode._parent;
          newOffset = 1 + (0, TreeAlgorithm_1.tree_index)(referenceNode);
        }
        if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
          const clone = (0, NodeAlgorithm_1.node_clone)(originalStartNode);
          clone._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalStartNode, originalStartOffset, (0, TreeAlgorithm_1.tree_nodeLength)(originalStartNode) - originalStartOffset);
          (0, MutationAlgorithm_1.mutation_append)(clone, fragment3);
          (0, CharacterDataAlgorithm_1.characterData_replaceData)(originalStartNode, originalStartOffset, (0, TreeAlgorithm_1.tree_nodeLength)(originalStartNode) - originalStartOffset, "");
        } else if (firstPartiallyContainedChild !== null) {
          const clone = (0, NodeAlgorithm_1.node_clone)(firstPartiallyContainedChild);
          (0, MutationAlgorithm_1.mutation_append)(clone, fragment3);
          const subrange = (0, CreateAlgorithm_1.create_range)([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, (0, TreeAlgorithm_1.tree_nodeLength)(firstPartiallyContainedChild)]);
          const subfragment = range_extract(subrange);
          (0, MutationAlgorithm_1.mutation_append)(subfragment, clone);
        }
        for (const child of containedChildren) {
          (0, MutationAlgorithm_1.mutation_append)(child, fragment3);
        }
        if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
          const clone = (0, NodeAlgorithm_1.node_clone)(originalEndNode);
          clone._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalEndNode, 0, originalEndOffset);
          (0, MutationAlgorithm_1.mutation_append)(clone, fragment3);
          (0, CharacterDataAlgorithm_1.characterData_replaceData)(originalEndNode, 0, originalEndOffset, "");
        } else if (lastPartiallyContainedChild !== null) {
          const clone = (0, NodeAlgorithm_1.node_clone)(lastPartiallyContainedChild);
          (0, MutationAlgorithm_1.mutation_append)(clone, fragment3);
          const subrange = (0, CreateAlgorithm_1.create_range)([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
          const subfragment = range_extract(subrange);
          (0, MutationAlgorithm_1.mutation_append)(subfragment, clone);
        }
        range._start = [newNode, newOffset];
        range._end = [newNode, newOffset];
        return fragment3;
      }
      function range_cloneTheContents(range) {
        const fragment3 = (0, CreateAlgorithm_1.create_documentFragment)(range._startNode._nodeDocument);
        if (range_collapsed(range))
          return fragment3;
        const originalStartNode = range._startNode;
        const originalStartOffset = range._startOffset;
        const originalEndNode = range._endNode;
        const originalEndOffset = range._endOffset;
        if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
          const clone = (0, NodeAlgorithm_1.node_clone)(originalStartNode);
          clone._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
          (0, MutationAlgorithm_1.mutation_append)(clone, fragment3);
        }
        let commonAncestor = originalStartNode;
        while (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, commonAncestor, true)) {
          if (commonAncestor._parent === null) {
            throw new Error("Parent node  is null.");
          }
          commonAncestor = commonAncestor._parent;
        }
        let firstPartiallyContainedChild = null;
        if (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalEndNode, originalStartNode, true)) {
          for (const node of commonAncestor._children) {
            if (range_isPartiallyContained(node, range)) {
              firstPartiallyContainedChild = node;
              break;
            }
          }
        }
        let lastPartiallyContainedChild = null;
        if (!(0, TreeAlgorithm_1.tree_isAncestorOf)(originalStartNode, originalEndNode, true)) {
          const children = [...commonAncestor._children];
          for (let i = children.length - 1; i > 0; i--) {
            const node = children[i];
            if (range_isPartiallyContained(node, range)) {
              lastPartiallyContainedChild = node;
              break;
            }
          }
        }
        const containedChildren = [];
        for (const child of commonAncestor._children) {
          if (range_isContained(child, range)) {
            if (util_1.Guard.isDocumentTypeNode(child)) {
              throw new DOMException_1.HierarchyRequestError();
            }
            containedChildren.push(child);
          }
        }
        if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
          const clone = (0, NodeAlgorithm_1.node_clone)(originalStartNode);
          clone._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalStartNode, originalStartOffset, (0, TreeAlgorithm_1.tree_nodeLength)(originalStartNode) - originalStartOffset);
          (0, MutationAlgorithm_1.mutation_append)(clone, fragment3);
        } else if (firstPartiallyContainedChild !== null) {
          const clone = (0, NodeAlgorithm_1.node_clone)(firstPartiallyContainedChild);
          (0, MutationAlgorithm_1.mutation_append)(clone, fragment3);
          const subrange = (0, CreateAlgorithm_1.create_range)([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, (0, TreeAlgorithm_1.tree_nodeLength)(firstPartiallyContainedChild)]);
          const subfragment = range_cloneTheContents(subrange);
          (0, MutationAlgorithm_1.mutation_append)(subfragment, clone);
        }
        for (const child of containedChildren) {
          const clone = (0, NodeAlgorithm_1.node_clone)(child);
          (0, MutationAlgorithm_1.mutation_append)(clone, fragment3);
        }
        if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
          const clone = (0, NodeAlgorithm_1.node_clone)(originalEndNode);
          clone._data = (0, CharacterDataAlgorithm_1.characterData_substringData)(originalEndNode, 0, originalEndOffset);
          (0, MutationAlgorithm_1.mutation_append)(clone, fragment3);
        } else if (lastPartiallyContainedChild !== null) {
          const clone = (0, NodeAlgorithm_1.node_clone)(lastPartiallyContainedChild);
          fragment3.append(clone);
          const subrange = (0, CreateAlgorithm_1.create_range)([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
          const subfragment = range_extract(subrange);
          (0, MutationAlgorithm_1.mutation_append)(subfragment, clone);
        }
        return fragment3;
      }
      function range_insert(node, range) {
        if (util_1.Guard.isProcessingInstructionNode(range._startNode) || util_1.Guard.isCommentNode(range._startNode) || util_1.Guard.isTextNode(range._startNode) && range._startNode._parent === null || range._startNode === node) {
          throw new DOMException_1.HierarchyRequestError();
        }
        let referenceNode = null;
        if (util_1.Guard.isTextNode(range._startNode)) {
          referenceNode = range._startNode;
        } else {
          let index = 0;
          for (const child of range._startNode._children) {
            if (index === range._startOffset) {
              referenceNode = child;
              break;
            }
            index++;
          }
        }
        let parent;
        if (referenceNode === null) {
          parent = range._startNode;
        } else {
          if (referenceNode._parent === null) {
            throw new Error("Parent node is null.");
          }
          parent = referenceNode._parent;
        }
        (0, MutationAlgorithm_1.mutation_ensurePreInsertionValidity)(node, parent, referenceNode);
        if (util_1.Guard.isTextNode(range._startNode)) {
          referenceNode = (0, TextAlgorithm_1.text_split)(range._startNode, range._startOffset);
        }
        if (node === referenceNode) {
          referenceNode = node._nextSibling;
        }
        if (node._parent !== null) {
          (0, MutationAlgorithm_1.mutation_remove)(node, node._parent);
        }
        let newOffset = referenceNode === null ? (0, TreeAlgorithm_1.tree_nodeLength)(parent) : (0, TreeAlgorithm_1.tree_index)(referenceNode);
        if (util_1.Guard.isDocumentFragmentNode(node)) {
          newOffset += (0, TreeAlgorithm_1.tree_nodeLength)(node);
        } else {
          newOffset++;
        }
        (0, MutationAlgorithm_1.mutation_preInsert)(node, parent, referenceNode);
        if (range_collapsed(range)) {
          range._end = [parent, newOffset];
        }
      }
      function range_getContainedNodes(range) {
        return {
          [Symbol.iterator]: () => {
            const container = range.commonAncestorContainer;
            let currentNode = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(container);
            return {
              next: () => {
                while (currentNode && !range_isContained(currentNode, range)) {
                  currentNode = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(container, currentNode);
                }
                if (currentNode === null) {
                  return { done: true, value: null };
                } else {
                  const result = { done: false, value: currentNode };
                  currentNode = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(container, currentNode);
                  return result;
                }
              }
            };
          }
        };
      }
      function range_getPartiallyContainedNodes(range) {
        return {
          [Symbol.iterator]: () => {
            const container = range.commonAncestorContainer;
            let currentNode = (0, TreeAlgorithm_1.tree_getFirstDescendantNode)(container);
            return {
              next: () => {
                while (currentNode && !range_isPartiallyContained(currentNode, range)) {
                  currentNode = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(container, currentNode);
                }
                if (currentNode === null) {
                  return { done: true, value: null };
                } else {
                  const result = { done: false, value: currentNode };
                  currentNode = (0, TreeAlgorithm_1.tree_getNextDescendantNode)(container, currentNode);
                  return result;
                }
              }
            };
          }
        };
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/SelectorsAlgorithm.js
  var require_SelectorsAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/SelectorsAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.selectors_scopeMatchASelectorsString = selectors_scopeMatchASelectorsString;
      var DOMException_1 = require_DOMException();
      function selectors_scopeMatchASelectorsString(selectors, node) {
        throw new DOMException_1.NotSupportedError();
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/TreeWalkerAlgorithm.js
  var require_TreeWalkerAlgorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/TreeWalkerAlgorithm.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.treeWalker_traverseChildren = treeWalker_traverseChildren;
      exports.treeWalker_traverseSiblings = treeWalker_traverseSiblings;
      var interfaces_1 = require_interfaces2();
      var TraversalAlgorithm_1 = require_TraversalAlgorithm();
      function treeWalker_traverseChildren(walker, first) {
        let node = first ? walker._current._firstChild : walker._current._lastChild;
        while (node !== null) {
          const result = (0, TraversalAlgorithm_1.traversal_filter)(walker, node);
          if (result === interfaces_1.FilterResult.Accept) {
            walker._current = node;
            return node;
          } else if (result === interfaces_1.FilterResult.Skip) {
            const child = first ? node._firstChild : node._lastChild;
            if (child !== null) {
              node = child;
              continue;
            }
          }
          while (node !== null) {
            const sibling = first ? node._nextSibling : node._previousSibling;
            if (sibling !== null) {
              node = sibling;
              break;
            }
            const parent = node._parent;
            if (parent === null || parent === walker._root || parent === walker._current) {
              return null;
            }
            node = parent;
          }
        }
        return null;
      }
      function treeWalker_traverseSiblings(walker, next) {
        let node = walker._current;
        if (node === walker._root)
          return null;
        while (true) {
          let sibling = next ? node._nextSibling : node._previousSibling;
          while (sibling !== null) {
            node = sibling;
            const result = (0, TraversalAlgorithm_1.traversal_filter)(walker, node);
            if (result === interfaces_1.FilterResult.Accept) {
              walker._current = node;
              return node;
            }
            sibling = next ? node._firstChild : node._lastChild;
            if (result === interfaces_1.FilterResult.Reject || sibling === null) {
              sibling = next ? node._nextSibling : node._previousSibling;
            }
          }
          node = node._parent;
          if (node === null || node === walker._root) {
            return null;
          }
          if ((0, TraversalAlgorithm_1.traversal_filter)(walker, node) === interfaces_1.FilterResult.Accept) {
            return null;
          }
        }
      }
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/index.js
  var require_algorithm = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/algorithm/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_AbortAlgorithm(), exports);
      __exportStar(require_AttrAlgorithm(), exports);
      __exportStar(require_BoundaryPointAlgorithm(), exports);
      __exportStar(require_CharacterDataAlgorithm(), exports);
      __exportStar(require_CreateAlgorithm(), exports);
      __exportStar(require_CustomElementAlgorithm(), exports);
      __exportStar(require_DocumentAlgorithm(), exports);
      __exportStar(require_DOMAlgorithm(), exports);
      __exportStar(require_DOMTokenListAlgorithm(), exports);
      __exportStar(require_ElementAlgorithm(), exports);
      __exportStar(require_EventAlgorithm(), exports);
      __exportStar(require_EventTargetAlgorithm(), exports);
      __exportStar(require_MutationAlgorithm(), exports);
      __exportStar(require_MutationObserverAlgorithm(), exports);
      __exportStar(require_NamespaceAlgorithm(), exports);
      __exportStar(require_NodeAlgorithm(), exports);
      __exportStar(require_NodeIteratorAlgorithm(), exports);
      __exportStar(require_OrderedSetAlgorithm(), exports);
      __exportStar(require_ParentNodeAlgorithm(), exports);
      __exportStar(require_RangeAlgorithm(), exports);
      __exportStar(require_SelectorsAlgorithm(), exports);
      __exportStar(require_ShadowTreeAlgorithm(), exports);
      __exportStar(require_TextAlgorithm(), exports);
      __exportStar(require_TraversalAlgorithm(), exports);
      __exportStar(require_TreeAlgorithm(), exports);
      __exportStar(require_TreeWalkerAlgorithm(), exports);
      __exportStar(require_WebIDLAlgorithm(), exports);
      __exportStar(require_XMLAlgorithm(), exports);
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/constants.js
  var require_constants2 = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.nonEntityAmpersandRegex = void 0;
      exports.nonEntityAmpersandRegex = /&(?![A-Za-z]+;|#\d+;)/g;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/BaseWriter.js
  var require_BaseWriter = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/BaseWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseWriter = void 0;
      var interfaces_1 = require_interfaces2();
      var LocalNameSet_1 = require_LocalNameSet();
      var NamespacePrefixMap_1 = require_NamespacePrefixMap();
      var infra_1 = require_lib5();
      var algorithm_1 = require_algorithm();
      var constants_1 = require_constants2();
      var _BaseWriter = class _BaseWriter {
        /**
         * Initializes a new instance of `BaseWriter`.
         *
         * @param builderOptions - XML builder options
         */
        constructor(builderOptions) {
          __publicField(this, "_builderOptions");
          __publicField(this, "_writerOptions");
          /**
           * Gets the current depth of the XML tree.
           */
          __publicField(this, "level", 0);
          /**
           * Gets the current XML node.
           */
          __publicField(this, "currentNode");
          this._builderOptions = builderOptions;
        }
        /**
         * Used by derived classes to serialize the XML declaration.
         *
         * @param version - a version number string
         * @param encoding - encoding declaration
         * @param standalone - standalone document declaration
         */
        declaration(version, encoding, standalone) {
        }
        /**
         * Used by derived classes to serialize a DocType node.
         *
         * @param name - node name
         * @param publicId - public identifier
         * @param systemId - system identifier
         */
        docType(name, publicId, systemId) {
        }
        /**
         * Used by derived classes to serialize a comment node.
         *
         * @param data - node data
         */
        comment(data) {
        }
        /**
         * Used by derived classes to serialize a text node.
         *
         * @param data - node data
         */
        text(data) {
        }
        /**
         * Used by derived classes to serialize a processing instruction node.
         *
         * @param target - instruction target
         * @param data - node data
         */
        instruction(target, data) {
        }
        /**
         * Used by derived classes to serialize a CData section node.
         *
         * @param data - node data
         */
        cdata(data) {
        }
        /**
         * Used by derived classes to serialize the beginning of the opening tag of an
         * element node.
         *
         * @param name - node name
         */
        openTagBegin(name) {
        }
        /**
         * Used by derived classes to serialize the ending of the opening tag of an
         * element node.
         *
         * @param name - node name
         * @param selfClosing - whether the element node is self closing
         * @param voidElement - whether the element node is a HTML void element
         */
        openTagEnd(name, selfClosing, voidElement) {
        }
        /**
         * Used by derived classes to serialize the closing tag of an element node.
         *
         * @param name - node name
         */
        closeTag(name) {
        }
        /**
         * Used by derived classes to serialize attributes or namespace declarations.
         *
         * @param attributes - attribute array
         */
        attributes(attributes) {
          for (const attr of attributes) {
            this.attribute(attr[1] === null ? attr[2] : attr[1] + ":" + attr[2], attr[3]);
          }
        }
        /**
         * Used by derived classes to serialize an attribute or namespace declaration.
         *
         * @param name - node name
         * @param value - node value
         */
        attribute(name, value) {
        }
        /**
         * Used by derived classes to perform any pre-processing steps before starting
         * serializing an element node.
         *
         * @param name - node name
         */
        beginElement(name) {
        }
        /**
         * Used by derived classes to perform any post-processing steps after
         * completing serializing an element node.
         *
         * @param name - node name
         */
        endElement(name) {
        }
        /**
         * Produces an XML serialization of the given node. The pre-serializer inserts
         * namespace declarations where necessary and produces qualified names for
         * nodes and attributes.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        serializeNode(node, requireWellFormed) {
          const hasNamespaces = node._nodeDocument !== void 0 && node._nodeDocument._hasNamespaces;
          this.level = 0;
          this.currentNode = node;
          if (hasNamespaces) {
            let namespace = null;
            const prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
            prefixMap.set("xml", infra_1.namespace.XML);
            const prefixIndex = { value: 1 };
            this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
          } else {
            this._serializeNode(node, requireWellFormed);
          }
        }
        /**
         * Produces an XML serialization of a node.
         *
         * @param node - node to serialize
         * @param namespace - context namespace
         * @param prefixMap - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param requireWellFormed - whether to check conformance
         */
        _serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
          this.currentNode = node;
          switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
              this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
              break;
            case interfaces_1.NodeType.Document:
              this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
              break;
            case interfaces_1.NodeType.Comment:
              this._serializeComment(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.Text:
              this._serializeText(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.DocumentFragment:
              this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
              break;
            case interfaces_1.NodeType.DocumentType:
              this._serializeDocumentType(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.ProcessingInstruction:
              this._serializeProcessingInstruction(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.CData:
              this._serializeCData(node, requireWellFormed);
              break;
            default:
              throw new Error(`Unknown node type: ${node.nodeType}`);
          }
        }
        /**
         * Produces an XML serialization of a node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeNode(node, requireWellFormed) {
          this.currentNode = node;
          switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
              this._serializeElement(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.Document:
              this._serializeDocument(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.Comment:
              this._serializeComment(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.Text:
              this._serializeText(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.DocumentFragment:
              this._serializeDocumentFragment(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.DocumentType:
              this._serializeDocumentType(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.ProcessingInstruction:
              this._serializeProcessingInstruction(node, requireWellFormed);
              break;
            case interfaces_1.NodeType.CData:
              this._serializeCData(node, requireWellFormed);
              break;
            default:
              throw new Error(`Unknown node type: ${node.nodeType}`);
          }
        }
        /**
         * Produces an XML serialization of an element node.
         *
         * @param node - node to serialize
         * @param namespace - context namespace
         * @param prefixMap - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param requireWellFormed - whether to check conformance
         */
        _serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
          const attributes = [];
          if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
          }
          let qualifiedName = "";
          let skipEndTag = false;
          let ignoreNamespaceDefinitionAttribute = false;
          let map = prefixMap.copy();
          let localPrefixesMap = {};
          let localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
          let inheritedNS = namespace;
          let ns = node.namespaceURI;
          if (inheritedNS === ns) {
            if (localDefaultNamespace !== null) {
              ignoreNamespaceDefinitionAttribute = true;
            }
            if (ns === infra_1.namespace.XML) {
              qualifiedName = "xml:" + node.localName;
            } else {
              qualifiedName = node.localName;
            }
            this.beginElement(qualifiedName);
            this.openTagBegin(qualifiedName);
          } else {
            let prefix = node.prefix;
            let candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
              candidatePrefix = map.get(prefix, ns);
            }
            if (prefix === "xmlns") {
              if (requireWellFormed) {
                throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
              }
              candidatePrefix = prefix;
            }
            if (candidatePrefix !== null) {
              qualifiedName = candidatePrefix + ":" + node.localName;
              if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                inheritedNS = localDefaultNamespace || null;
              }
              this.beginElement(qualifiedName);
              this.openTagBegin(qualifiedName);
            } else if (prefix !== null) {
              if (prefix in localPrefixesMap) {
                prefix = this._generatePrefix(ns, map, prefixIndex);
              }
              map.set(prefix, ns);
              qualifiedName += prefix + ":" + node.localName;
              this.beginElement(qualifiedName);
              this.openTagBegin(qualifiedName);
              attributes.push([
                null,
                "xmlns",
                prefix,
                this._serializeAttributeValue(ns, requireWellFormed)
              ]);
              if (localDefaultNamespace !== null) {
                inheritedNS = localDefaultNamespace || null;
              }
            } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
              ignoreNamespaceDefinitionAttribute = true;
              qualifiedName += node.localName;
              inheritedNS = ns;
              this.beginElement(qualifiedName);
              this.openTagBegin(qualifiedName);
              attributes.push([
                null,
                null,
                "xmlns",
                this._serializeAttributeValue(ns, requireWellFormed)
              ]);
            } else {
              qualifiedName += node.localName;
              inheritedNS = ns;
              this.beginElement(qualifiedName);
              this.openTagBegin(qualifiedName);
            }
          }
          attributes.push(...this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed));
          this.attributes(attributes);
          const isHTML = ns === infra_1.namespace.HTML;
          if (isHTML && node.childNodes.length === 0 && _BaseWriter._VoidElementNames.has(node.localName)) {
            this.openTagEnd(qualifiedName, true, true);
            this.endElement(qualifiedName);
            skipEndTag = true;
          } else if (!isHTML && node.childNodes.length === 0) {
            this.openTagEnd(qualifiedName, true, false);
            this.endElement(qualifiedName);
            skipEndTag = true;
          } else {
            this.openTagEnd(qualifiedName, false, false);
          }
          if (skipEndTag)
            return;
          if (isHTML && node.localName === "template") {
          } else {
            for (const childNode of node.childNodes) {
              this.level++;
              this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
              this.level--;
            }
          }
          this.closeTag(qualifiedName);
          this.endElement(qualifiedName);
        }
        /**
         * Produces an XML serialization of an element node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeElement(node, requireWellFormed) {
          if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
          }
          let skipEndTag = false;
          const qualifiedName = node.localName;
          this.beginElement(qualifiedName);
          this.openTagBegin(qualifiedName);
          const attributes = this._serializeAttributes(node, requireWellFormed);
          this.attributes(attributes);
          if (!node.hasChildNodes()) {
            this.openTagEnd(qualifiedName, true, false);
            this.endElement(qualifiedName);
            skipEndTag = true;
          } else {
            this.openTagEnd(qualifiedName, false, false);
          }
          if (skipEndTag)
            return;
          for (const childNode of node._children) {
            this.level++;
            this._serializeNode(childNode, requireWellFormed);
            this.level--;
          }
          this.closeTag(qualifiedName);
          this.endElement(qualifiedName);
        }
        /**
         * Produces an XML serialization of a document node.
         *
         * @param node - node to serialize
         * @param namespace - context namespace
         * @param prefixMap - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param requireWellFormed - whether to check conformance
         */
        _serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
          if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
          }
          for (const childNode of node.childNodes) {
            this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
          }
        }
        /**
         * Produces an XML serialization of a document node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeDocument(node, requireWellFormed) {
          if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
          }
          for (const childNode of node._children) {
            this._serializeNode(childNode, requireWellFormed);
          }
        }
        /**
         * Produces an XML serialization of a comment node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeComment(node, requireWellFormed) {
          if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            throw new Error("Comment data contains invalid characters (well-formed required).");
          }
          this.comment(node.data);
        }
        /**
         * Produces an XML serialization of a text node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         * @param level - current depth of the XML tree
         */
        _serializeText(node, requireWellFormed) {
          if (requireWellFormed && !(0, algorithm_1.xml_isLegalChar)(node.data)) {
            throw new Error("Text data contains invalid characters (well-formed required).");
          }
          const markup = node.data.replace(constants_1.nonEntityAmpersandRegex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          this.text(markup);
        }
        /**
         * Produces an XML serialization of a document fragment node.
         *
         * @param node - node to serialize
         * @param namespace - context namespace
         * @param prefixMap - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param requireWellFormed - whether to check conformance
         */
        _serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
          for (const childNode of node.childNodes) {
            this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
          }
        }
        /**
         * Produces an XML serialization of a document fragment node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeDocumentFragment(node, requireWellFormed) {
          for (const childNode of node._children) {
            this._serializeNode(childNode, requireWellFormed);
          }
        }
        /**
         * Produces an XML serialization of a document type node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeDocumentType(node, requireWellFormed) {
          if (requireWellFormed && !(0, algorithm_1.xml_isPubidChar)(node.publicId)) {
            throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
          }
          if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
            throw new Error("DocType system identifier contains invalid characters (well-formed required).");
          }
          this.docType(node.name, node.publicId, node.systemId);
        }
        /**
         * Produces an XML serialization of a processing instruction node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeProcessingInstruction(node, requireWellFormed) {
          if (requireWellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
            throw new Error("Processing instruction target contains invalid characters (well-formed required).");
          }
          if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.data) || node.data.indexOf("?>") !== -1)) {
            throw new Error("Processing instruction data contains invalid characters (well-formed required).");
          }
          this.instruction(node.target, node.data);
        }
        /**
         * Produces an XML serialization of a CDATA node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeCData(node, requireWellFormed) {
          if (requireWellFormed && node.data.indexOf("]]>") !== -1) {
            throw new Error("CDATA contains invalid characters (well-formed required).");
          }
          this.cdata(node.data);
        }
        /**
        * Produces an XML serialization of the attributes of an element node.
        *
         * @param node - node to serialize
         * @param map - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param localPrefixesMap - local prefixes map
         * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
         * attributes
         * @param requireWellFormed - whether to check conformance
        */
        _serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
          const result = [];
          const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : void 0;
          for (const attr of node.attributes) {
            if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
              result.push([
                null,
                null,
                attr.localName,
                this._serializeAttributeValue(attr.value, requireWellFormed)
              ]);
              continue;
            }
            if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
              throw new Error("Element contains duplicate attributes (well-formed required).");
            }
            if (requireWellFormed && localNameSet)
              localNameSet.set(attr.namespaceURI, attr.localName);
            let attributeNamespace = attr.namespaceURI;
            let candidatePrefix = null;
            if (attributeNamespace !== null) {
              candidatePrefix = map.get(attr.prefix, attributeNamespace);
              if (attributeNamespace === infra_1.namespace.XMLNS) {
                if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value))
                  continue;
                if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                  throw new Error("XMLNS namespace is reserved (well-formed required).");
                }
                if (requireWellFormed && attr.value === "") {
                  throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                }
                if (attr.prefix === "xmlns")
                  candidatePrefix = "xmlns";
              } else if (candidatePrefix === null) {
                if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
                  candidatePrefix = attr.prefix;
                } else {
                  candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                }
                result.push([
                  null,
                  "xmlns",
                  candidatePrefix,
                  this._serializeAttributeValue(attributeNamespace, requireWellFormed)
                ]);
              }
            }
            let attrName = "";
            if (candidatePrefix !== null) {
              attrName = candidatePrefix;
            }
            if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
              throw new Error("Attribute local name contains invalid characters (well-formed required).");
            }
            result.push([
              attributeNamespace,
              candidatePrefix,
              attr.localName,
              this._serializeAttributeValue(attr.value, requireWellFormed)
            ]);
          }
          return result;
        }
        /**
        * Produces an XML serialization of the attributes of an element node.
        *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
        */
        _serializeAttributes(node, requireWellFormed) {
          const result = [];
          const localNameSet = requireWellFormed ? {} : void 0;
          for (const attr of node.attributes) {
            if (!requireWellFormed) {
              result.push([
                null,
                null,
                attr.localName,
                this._serializeAttributeValue(attr.value, requireWellFormed)
              ]);
              continue;
            }
            if (requireWellFormed && localNameSet && attr.localName in localNameSet) {
              throw new Error("Element contains duplicate attributes (well-formed required).");
            }
            if (requireWellFormed && localNameSet)
              localNameSet[attr.localName] = true;
            if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attr.localName))) {
              throw new Error("Attribute local name contains invalid characters (well-formed required).");
            }
            result.push([
              null,
              null,
              attr.localName,
              this._serializeAttributeValue(attr.value, requireWellFormed)
            ]);
          }
          return result;
        }
        /**
        * Records namespace information for the given element and returns the
        * default namespace attribute value.
        *
        * @param node - element node to process
        * @param map - namespace prefix map
        * @param localPrefixesMap - local prefixes map
        */
        _recordNamespaceInformation(node, map, localPrefixesMap) {
          let defaultNamespaceAttrValue = null;
          for (const attr of node.attributes) {
            let attributeNamespace = attr.namespaceURI;
            let attributePrefix = attr.prefix;
            if (attributeNamespace === infra_1.namespace.XMLNS) {
              if (attributePrefix === null) {
                defaultNamespaceAttrValue = attr.value;
                continue;
              } else {
                let prefixDefinition = attr.localName;
                let namespaceDefinition = attr.value;
                if (namespaceDefinition === infra_1.namespace.XML) {
                  continue;
                }
                if (namespaceDefinition === "") {
                  namespaceDefinition = null;
                }
                if (map.has(prefixDefinition, namespaceDefinition)) {
                  continue;
                }
                map.set(prefixDefinition, namespaceDefinition);
                localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
              }
            }
          }
          return defaultNamespaceAttrValue;
        }
        /**
        * Generates a new prefix for the given namespace.
        *
        * @param newNamespace - a namespace to generate prefix for
        * @param prefixMap - namespace prefix map
        * @param prefixIndex - generated namespace prefix index
        */
        _generatePrefix(newNamespace, prefixMap, prefixIndex) {
          const generatedPrefix = "ns" + prefixIndex.value.toString();
          prefixIndex.value++;
          prefixMap.set(generatedPrefix, newNamespace);
          return generatedPrefix;
        }
        /**
         * Produces an XML serialization of an attribute value.
         *
         * @param value - attribute value
         * @param requireWellFormed - whether to check conformance
         */
        _serializeAttributeValue(value, requireWellFormed) {
          if (requireWellFormed && value !== null && !(0, algorithm_1.xml_isLegalChar)(value)) {
            throw new Error("Invalid characters in attribute value.");
          }
          if (value === null)
            return "";
          return value.replace(constants_1.nonEntityAmpersandRegex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
        }
      };
      __publicField(_BaseWriter, "_VoidElementNames", /* @__PURE__ */ new Set([
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "menuitem",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]));
      var BaseWriter = _BaseWriter;
      exports.BaseWriter = BaseWriter;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/ObjectWriter.js
  var require_ObjectWriter = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/ObjectWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ObjectWriter = void 0;
      var util_1 = require_lib4();
      var interfaces_1 = require_interfaces2();
      var BaseWriter_1 = require_BaseWriter();
      var ObjectWriter = class extends BaseWriter_1.BaseWriter {
        /**
         * Initializes a new instance of `ObjectWriter`.
         *
         * @param builderOptions - XML builder options
         * @param writerOptions - serialization options
         */
        constructor(builderOptions, writerOptions) {
          super(builderOptions);
          __publicField(this, "_currentList");
          __publicField(this, "_currentIndex");
          __publicField(this, "_listRegister");
          this._writerOptions = (0, util_1.applyDefaults)(writerOptions, {
            format: "object",
            wellFormed: false,
            group: false,
            verbose: false
          });
        }
        /**
         * Produces an XML serialization of the given node.
         *
         * @param node - node to serialize
         */
        serialize(node) {
          this._currentList = [];
          this._currentIndex = 0;
          this._listRegister = [this._currentList];
          this.serializeNode(node, this._writerOptions.wellFormed);
          return this._process(this._currentList, this._writerOptions);
        }
        _process(items, options) {
          if (items.length === 0)
            return {};
          const namesSeen = {};
          let hasNonUniqueNames = false;
          let textCount = 0;
          let commentCount = 0;
          let instructionCount = 0;
          let cdataCount = 0;
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const key = Object.keys(item)[0];
            switch (key) {
              case "@":
                continue;
              case "#":
                textCount++;
                break;
              case "!":
                commentCount++;
                break;
              case "?":
                instructionCount++;
                break;
              case "$":
                cdataCount++;
                break;
              default:
                if (namesSeen[key]) {
                  hasNonUniqueNames = true;
                } else {
                  namesSeen[key] = true;
                }
                break;
            }
          }
          const defAttrKey = this._getAttrKey();
          const defTextKey = this._getNodeKey(interfaces_1.NodeType.Text);
          const defCommentKey = this._getNodeKey(interfaces_1.NodeType.Comment);
          const defInstructionKey = this._getNodeKey(interfaces_1.NodeType.ProcessingInstruction);
          const defCdataKey = this._getNodeKey(interfaces_1.NodeType.CData);
          if (textCount === 1 && items.length === 1 && (0, util_1.isString)(items[0]["#"])) {
            return items[0]["#"];
          } else if (hasNonUniqueNames) {
            const obj = {};
            for (let i = 0; i < items.length; i++) {
              const item = items[i];
              const key = Object.keys(item)[0];
              if (key === "@") {
                const attrs = item["@"];
                const attrKeys = Object.keys(attrs);
                if (!options.group || attrKeys.length === 1) {
                  for (const attrName in attrs) {
                    obj[defAttrKey + attrName] = attrs[attrName];
                  }
                } else {
                  obj[defAttrKey] = attrs;
                }
              }
            }
            const result = [];
            for (let i = 0; i < items.length; i++) {
              const item = items[i];
              const key = Object.keys(item)[0];
              switch (key) {
                case "@":
                  break;
                case "#":
                  result.push({ [defTextKey]: item["#"] });
                  break;
                case "!":
                  result.push({ [defCommentKey]: item["!"] });
                  break;
                case "?":
                  result.push({ [defInstructionKey]: item["?"] });
                  break;
                case "$":
                  result.push({ [defCdataKey]: item["$"] });
                  break;
                default:
                  const ele = item;
                  if (ele[key].length !== 0 && (0, util_1.isArray)(ele[key][0])) {
                    const eleGroup = [];
                    const listOfLists = ele[key];
                    for (let i2 = 0; i2 < listOfLists.length; i2++) {
                      eleGroup.push(this._process(listOfLists[i2], options));
                    }
                    result.push({ [key]: eleGroup });
                  } else {
                    if (options.verbose) {
                      result.push({ [key]: [this._process(ele[key], options)] });
                    } else {
                      result.push({ [key]: this._process(ele[key], options) });
                    }
                  }
                  break;
              }
            }
            obj[defTextKey] = result;
            return obj;
          } else {
            let textId = 1;
            let commentId = 1;
            let instructionId = 1;
            let cdataId = 1;
            const obj = {};
            for (let i = 0; i < items.length; i++) {
              const item = items[i];
              const key = Object.keys(item)[0];
              switch (key) {
                case "@":
                  const attrs = item["@"];
                  const attrKeys = Object.keys(attrs);
                  if (!options.group || attrKeys.length === 1) {
                    for (const attrName in attrs) {
                      obj[defAttrKey + attrName] = attrs[attrName];
                    }
                  } else {
                    obj[defAttrKey] = attrs;
                  }
                  break;
                case "#":
                  textId = this._processSpecItem(item["#"], obj, options.group, defTextKey, textCount, textId);
                  break;
                case "!":
                  commentId = this._processSpecItem(item["!"], obj, options.group, defCommentKey, commentCount, commentId);
                  break;
                case "?":
                  instructionId = this._processSpecItem(item["?"], obj, options.group, defInstructionKey, instructionCount, instructionId);
                  break;
                case "$":
                  cdataId = this._processSpecItem(item["$"], obj, options.group, defCdataKey, cdataCount, cdataId);
                  break;
                default:
                  const ele = item;
                  if (ele[key].length !== 0 && (0, util_1.isArray)(ele[key][0])) {
                    const eleGroup = [];
                    const listOfLists = ele[key];
                    for (let i2 = 0; i2 < listOfLists.length; i2++) {
                      eleGroup.push(this._process(listOfLists[i2], options));
                    }
                    obj[key] = eleGroup;
                  } else {
                    if (options.verbose) {
                      obj[key] = [this._process(ele[key], options)];
                    } else {
                      obj[key] = this._process(ele[key], options);
                    }
                  }
                  break;
              }
            }
            return obj;
          }
        }
        _processSpecItem(item, obj, group, defKey, count, id) {
          if (!group && (0, util_1.isArray)(item) && count + item.length > 2) {
            for (const subItem of item) {
              const key = defKey + (id++).toString();
              obj[key] = subItem;
            }
          } else {
            const key = count > 1 ? defKey + (id++).toString() : defKey;
            obj[key] = item;
          }
          return id;
        }
        /** @inheritdoc */
        beginElement(name) {
          const childItems = [];
          if (this._currentList.length === 0) {
            this._currentList.push({ [name]: childItems });
          } else {
            const lastItem = this._currentList[this._currentList.length - 1];
            if (this._isElementNode(lastItem, name)) {
              if (lastItem[name].length !== 0 && (0, util_1.isArray)(lastItem[name][0])) {
                const listOfLists = lastItem[name];
                listOfLists.push(childItems);
              } else {
                lastItem[name] = [lastItem[name], childItems];
              }
            } else {
              this._currentList.push({ [name]: childItems });
            }
          }
          this._currentIndex++;
          if (this._listRegister.length > this._currentIndex) {
            this._listRegister[this._currentIndex] = childItems;
          } else {
            this._listRegister.push(childItems);
          }
          this._currentList = childItems;
        }
        /** @inheritdoc */
        endElement() {
          this._currentList = this._listRegister[--this._currentIndex];
        }
        /** @inheritdoc */
        attribute(name, value) {
          if (this._currentList.length === 0) {
            this._currentList.push({ "@": { [name]: value } });
          } else {
            const lastItem = this._currentList[this._currentList.length - 1];
            if (this._isAttrNode(lastItem)) {
              lastItem["@"][name] = value;
            } else {
              this._currentList.push({ "@": { [name]: value } });
            }
          }
        }
        /** @inheritdoc */
        comment(data) {
          if (this._currentList.length === 0) {
            this._currentList.push({ "!": data });
          } else {
            const lastItem = this._currentList[this._currentList.length - 1];
            if (this._isCommentNode(lastItem)) {
              if ((0, util_1.isArray)(lastItem["!"])) {
                lastItem["!"].push(data);
              } else {
                lastItem["!"] = [lastItem["!"], data];
              }
            } else {
              this._currentList.push({ "!": data });
            }
          }
        }
        /** @inheritdoc */
        text(data) {
          if (this._currentList.length === 0) {
            this._currentList.push({ "#": data });
          } else {
            const lastItem = this._currentList[this._currentList.length - 1];
            if (this._isTextNode(lastItem)) {
              if ((0, util_1.isArray)(lastItem["#"])) {
                lastItem["#"].push(data);
              } else {
                lastItem["#"] = [lastItem["#"], data];
              }
            } else {
              this._currentList.push({ "#": data });
            }
          }
        }
        /** @inheritdoc */
        instruction(target, data) {
          const value = data === "" ? target : target + " " + data;
          if (this._currentList.length === 0) {
            this._currentList.push({ "?": value });
          } else {
            const lastItem = this._currentList[this._currentList.length - 1];
            if (this._isInstructionNode(lastItem)) {
              if ((0, util_1.isArray)(lastItem["?"])) {
                lastItem["?"].push(value);
              } else {
                lastItem["?"] = [lastItem["?"], value];
              }
            } else {
              this._currentList.push({ "?": value });
            }
          }
        }
        /** @inheritdoc */
        cdata(data) {
          if (this._currentList.length === 0) {
            this._currentList.push({ "$": data });
          } else {
            const lastItem = this._currentList[this._currentList.length - 1];
            if (this._isCDATANode(lastItem)) {
              if ((0, util_1.isArray)(lastItem["$"])) {
                lastItem["$"].push(data);
              } else {
                lastItem["$"] = [lastItem["$"], data];
              }
            } else {
              this._currentList.push({ "$": data });
            }
          }
        }
        _isAttrNode(x) {
          return "@" in x;
        }
        _isTextNode(x) {
          return "#" in x;
        }
        _isCommentNode(x) {
          return "!" in x;
        }
        _isInstructionNode(x) {
          return "?" in x;
        }
        _isCDATANode(x) {
          return "$" in x;
        }
        _isElementNode(x, name) {
          return name in x;
        }
        /**
         * Returns an object key for an attribute or namespace declaration.
         */
        _getAttrKey() {
          return this._builderOptions.convert.att;
        }
        /**
         * Returns an object key for the given node type.
         *
         * @param nodeType - node type to get a key for
         */
        _getNodeKey(nodeType) {
          switch (nodeType) {
            case interfaces_1.NodeType.Comment:
              return this._builderOptions.convert.comment;
            case interfaces_1.NodeType.Text:
              return this._builderOptions.convert.text;
            case interfaces_1.NodeType.ProcessingInstruction:
              return this._builderOptions.convert.ins;
            case interfaces_1.NodeType.CData:
              return this._builderOptions.convert.cdata;
            /* istanbul ignore next */
            default:
              throw new Error("Invalid node type.");
          }
        }
      };
      exports.ObjectWriter = ObjectWriter;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/MapWriter.js
  var require_MapWriter = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/MapWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MapWriter = void 0;
      var util_1 = require_lib4();
      var ObjectWriter_1 = require_ObjectWriter();
      var BaseWriter_1 = require_BaseWriter();
      var MapWriter = class extends BaseWriter_1.BaseWriter {
        /**
         * Initializes a new instance of `MapWriter`.
         *
         * @param builderOptions - XML builder options
         * @param writerOptions - serialization options
         */
        constructor(builderOptions, writerOptions) {
          super(builderOptions);
          this._writerOptions = (0, util_1.applyDefaults)(writerOptions, {
            format: "map",
            wellFormed: false,
            group: false,
            verbose: false
          });
        }
        /**
         * Produces an XML serialization of the given node.
         *
         * @param node - node to serialize
         */
        serialize(node) {
          const objectWriterOptions = (0, util_1.applyDefaults)(this._writerOptions, {
            format: "object",
            wellFormed: false,
            verbose: false
          });
          const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
          const val = objectWriter.serialize(node);
          return this._convertObject(val);
        }
        /**
         * Recursively converts a JS object into an ES5 map.
         *
         * @param obj - a JS object
         */
        _convertObject(obj) {
          if ((0, util_1.isArray)(obj)) {
            for (let i = 0; i < obj.length; i++) {
              obj[i] = this._convertObject(obj[i]);
            }
            return obj;
          } else if ((0, util_1.isObject)(obj)) {
            const map = /* @__PURE__ */ new Map();
            for (const key in obj) {
              map.set(key, this._convertObject(obj[key]));
            }
            return map;
          } else {
            return obj;
          }
        }
      };
      exports.MapWriter = MapWriter;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/XMLWriter.js
  var require_XMLWriter = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/XMLWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLWriter = void 0;
      var util_1 = require_lib4();
      var interfaces_1 = require_interfaces2();
      var BaseWriter_1 = require_BaseWriter();
      var util_2 = require_util2();
      var XMLWriter = class extends BaseWriter_1.BaseWriter {
        /**
         * Initializes a new instance of `XMLWriter`.
         *
         * @param builderOptions - XML builder options
         * @param writerOptions - serialization options
         */
        constructor(builderOptions, writerOptions) {
          super(builderOptions);
          __publicField(this, "_refs");
          __publicField(this, "_indentation", {});
          __publicField(this, "_lengthToLastNewline", 0);
          this._writerOptions = (0, util_1.applyDefaults)(writerOptions, {
            wellFormed: false,
            headless: false,
            prettyPrint: false,
            indent: "  ",
            newline: "\n",
            offset: 0,
            width: 0,
            allowEmptyTags: false,
            indentTextOnlyNodes: false,
            spaceBeforeSlash: false
          });
        }
        /**
         * Produces an XML serialization of the given node.
         *
         * @param node - node to serialize
         */
        serialize(node) {
          this._refs = { suppressPretty: false, emptyNode: false, markup: "" };
          if (node.nodeType === interfaces_1.NodeType.Document && !this._writerOptions.headless) {
            this.declaration(this._builderOptions.version, this._builderOptions.encoding, this._builderOptions.standalone);
          }
          this.serializeNode(node, this._writerOptions.wellFormed);
          if (this._writerOptions.prettyPrint && this._refs.markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {
            this._refs.markup = this._refs.markup.slice(0, -this._writerOptions.newline.length);
          }
          return this._refs.markup;
        }
        /** @inheritdoc */
        declaration(version, encoding, standalone) {
          this._beginLine();
          this._refs.markup += '<?xml version="' + version + '"';
          if (encoding !== void 0) {
            this._refs.markup += ' encoding="' + encoding + '"';
          }
          if (standalone !== void 0) {
            this._refs.markup += ' standalone="' + (standalone ? "yes" : "no") + '"';
          }
          this._refs.markup += "?>";
          this._endLine();
        }
        /** @inheritdoc */
        docType(name, publicId, systemId) {
          this._beginLine();
          if (publicId && systemId) {
            this._refs.markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '" "' + systemId + '">';
          } else if (publicId) {
            this._refs.markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '">';
          } else if (systemId) {
            this._refs.markup += "<!DOCTYPE " + name + ' SYSTEM "' + systemId + '">';
          } else {
            this._refs.markup += "<!DOCTYPE " + name + ">";
          }
          this._endLine();
        }
        /** @inheritdoc */
        openTagBegin(name) {
          this._beginLine();
          this._refs.markup += "<" + name;
        }
        /** @inheritdoc */
        openTagEnd(name, selfClosing, voidElement) {
          this._refs.suppressPretty = false;
          this._refs.emptyNode = false;
          if (this._writerOptions.prettyPrint && !selfClosing && !voidElement) {
            let textOnlyNode = true;
            let emptyNode = true;
            let childNode = this.currentNode.firstChild;
            let cdataCount = 0;
            let textCount = 0;
            while (childNode) {
              if (util_2.Guard.isExclusiveTextNode(childNode)) {
                textCount++;
              } else if (util_2.Guard.isCDATASectionNode(childNode)) {
                cdataCount++;
              } else {
                textOnlyNode = false;
                emptyNode = false;
                break;
              }
              if (childNode.data !== "") {
                emptyNode = false;
              }
              childNode = childNode.nextSibling;
            }
            this._refs.suppressPretty = !this._writerOptions.indentTextOnlyNodes && textOnlyNode && (cdataCount <= 1 && textCount === 0 || cdataCount === 0);
            this._refs.emptyNode = emptyNode;
          }
          if ((voidElement || selfClosing || this._refs.emptyNode) && this._writerOptions.allowEmptyTags) {
            this._refs.markup += "></" + name + ">";
          } else {
            this._refs.markup += voidElement ? " />" : selfClosing || this._refs.emptyNode ? this._writerOptions.spaceBeforeSlash ? " />" : "/>" : ">";
          }
          this._endLine();
        }
        /** @inheritdoc */
        closeTag(name) {
          if (!this._refs.emptyNode) {
            this._beginLine();
            this._refs.markup += "</" + name + ">";
          }
          this._refs.suppressPretty = false;
          this._refs.emptyNode = false;
          this._endLine();
        }
        /** @inheritdoc */
        attribute(name, value) {
          const str = name + '="' + value + '"';
          if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._refs.markup.length - this._lengthToLastNewline + 1 + str.length > this._writerOptions.width) {
            this._endLine();
            this._beginLine();
            this._refs.markup += this._indent(1) + str;
          } else {
            this._refs.markup += " " + str;
          }
        }
        /** @inheritdoc */
        text(data) {
          if (data !== "") {
            this._beginLine();
            this._refs.markup += data;
            this._endLine();
          }
        }
        /** @inheritdoc */
        cdata(data) {
          if (data !== "") {
            this._beginLine();
            this._refs.markup += "<![CDATA[" + data + "]]>";
            this._endLine();
          }
        }
        /** @inheritdoc */
        comment(data) {
          this._beginLine();
          this._refs.markup += "<!--" + data + "-->";
          this._endLine();
        }
        /** @inheritdoc */
        instruction(target, data) {
          this._beginLine();
          this._refs.markup += "<?" + (data === "" ? target : target + " " + data) + "?>";
          this._endLine();
        }
        /**
         * Produces characters to be prepended to a line of string in pretty-print
         * mode.
         */
        _beginLine() {
          if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {
            this._refs.markup += this._indent(this._writerOptions.offset + this.level);
          }
        }
        /**
         * Produces characters to be appended to a line of string in pretty-print
         * mode.
         */
        _endLine() {
          if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {
            this._refs.markup += this._writerOptions.newline;
            this._lengthToLastNewline = this._refs.markup.length;
          }
        }
        /**
         * Produces an indentation string.
         *
         * @param level - depth of the tree
         */
        _indent(level) {
          if (level <= 0) {
            return "";
          } else if (this._indentation[level] !== void 0) {
            return this._indentation[level];
          } else {
            const str = this._writerOptions.indent.repeat(level);
            this._indentation[level] = str;
            return str;
          }
        }
      };
      exports.XMLWriter = XMLWriter;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/JSONWriter.js
  var require_JSONWriter = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/JSONWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JSONWriter = void 0;
      var ObjectWriter_1 = require_ObjectWriter();
      var util_1 = require_lib4();
      var BaseWriter_1 = require_BaseWriter();
      var JSONWriter = class extends BaseWriter_1.BaseWriter {
        /**
         * Initializes a new instance of `JSONWriter`.
         *
         * @param builderOptions - XML builder options
         * @param writerOptions - serialization options
         */
        constructor(builderOptions, writerOptions) {
          super(builderOptions);
          this._writerOptions = (0, util_1.applyDefaults)(writerOptions, {
            wellFormed: false,
            prettyPrint: false,
            indent: "  ",
            newline: "\n",
            offset: 0,
            group: false,
            verbose: false
          });
        }
        /**
         * Produces an XML serialization of the given node.
         *
         * @param node - node to serialize
         * @param writerOptions - serialization options
         */
        serialize(node) {
          const objectWriterOptions = (0, util_1.applyDefaults)(this._writerOptions, {
            format: "object",
            wellFormed: false
          });
          const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
          const val = objectWriter.serialize(node);
          return this._beginLine(this._writerOptions, 0) + this._convertObject(val, this._writerOptions);
        }
        /**
         * Produces an XML serialization of the given object.
         *
         * @param obj - object to serialize
         * @param options - serialization options
         * @param level - depth of the XML tree
         */
        _convertObject(obj, options, level = 0) {
          let markup = "";
          const isLeaf = this._isLeafNode(obj);
          if ((0, util_1.isArray)(obj)) {
            markup += "[";
            const len = obj.length;
            let i = 0;
            for (const val of obj) {
              markup += this._endLine(options, level + 1) + this._beginLine(options, level + 1) + this._convertObject(val, options, level + 1);
              if (i < len - 1) {
                markup += ",";
              }
              i++;
            }
            markup += this._endLine(options, level) + this._beginLine(options, level);
            markup += "]";
          } else if ((0, util_1.isObject)(obj)) {
            markup += "{";
            const len = (0, util_1.objectLength)(obj);
            let i = 0;
            (0, util_1.forEachObject)(obj, (key, val) => {
              if (isLeaf && options.prettyPrint) {
                markup += " ";
              } else {
                markup += this._endLine(options, level + 1) + this._beginLine(options, level + 1);
              }
              markup += this._key(key);
              if (options.prettyPrint) {
                markup += " ";
              }
              markup += this._convertObject(val, options, level + 1);
              if (i < len - 1) {
                markup += ",";
              }
              i++;
            }, this);
            if (isLeaf && options.prettyPrint) {
              markup += " ";
            } else {
              markup += this._endLine(options, level) + this._beginLine(options, level);
            }
            markup += "}";
          } else {
            markup += this._val(obj);
          }
          return markup;
        }
        /**
         * Produces characters to be prepended to a line of string in pretty-print
         * mode.
         *
         * @param options - serialization options
         * @param level - current depth of the XML tree
         */
        _beginLine(options, level) {
          if (!options.prettyPrint) {
            return "";
          } else {
            const indentLevel = options.offset + level + 1;
            if (indentLevel > 0) {
              return new Array(indentLevel).join(options.indent);
            }
          }
          return "";
        }
        /**
         * Produces characters to be appended to a line of string in pretty-print
         * mode.
         *
         * @param options - serialization options
         * @param level - current depth of the XML tree
         */
        _endLine(options, level) {
          if (!options.prettyPrint) {
            return "";
          } else {
            return options.newline;
          }
        }
        /**
         * Produces a JSON key string delimited with double quotes.
         */
        _key(key) {
          return '"' + key + '":';
        }
        /**
         * Produces a JSON value string delimited with double quotes.
         */
        _val(val) {
          return JSON.stringify(val);
        }
        /**
         * Determines if an object is a leaf node.
         *
         * @param obj
         */
        _isLeafNode(obj) {
          return this._descendantCount(obj) <= 1;
        }
        /**
         * Counts the number of descendants of the given object.
         *
         * @param obj
         * @param count
         */
        _descendantCount(obj, count = 0) {
          if ((0, util_1.isArray)(obj)) {
            (0, util_1.forEachArray)(obj, (val) => count += this._descendantCount(val, count), this);
          } else if ((0, util_1.isObject)(obj)) {
            (0, util_1.forEachObject)(obj, (key, val) => count += this._descendantCount(val, count), this);
          } else {
            count++;
          }
          return count;
        }
      };
      exports.JSONWriter = JSONWriter;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/YAMLWriter.js
  var require_YAMLWriter = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/YAMLWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.YAMLWriter = void 0;
      var ObjectWriter_1 = require_ObjectWriter();
      var util_1 = require_lib4();
      var BaseWriter_1 = require_BaseWriter();
      var YAMLWriter = class extends BaseWriter_1.BaseWriter {
        /**
         * Initializes a new instance of `YAMLWriter`.
         *
         * @param builderOptions - XML builder options
         * @param writerOptions - serialization options
         */
        constructor(builderOptions, writerOptions) {
          super(builderOptions);
          this._writerOptions = (0, util_1.applyDefaults)(writerOptions, {
            wellFormed: false,
            indent: "  ",
            newline: "\n",
            offset: 0,
            group: false,
            verbose: false
          });
          if (this._writerOptions.indent.length < 2) {
            throw new Error("YAML indententation string must be at least two characters long.");
          }
          if (this._writerOptions.offset < 0) {
            throw new Error("YAML offset should be zero or a positive number.");
          }
        }
        /**
         * Produces an XML serialization of the given node.
         *
         * @param node - node to serialize
         * @param writerOptions - serialization options
         */
        serialize(node) {
          const objectWriterOptions = (0, util_1.applyDefaults)(this._writerOptions, {
            format: "object",
            wellFormed: false
          });
          const objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
          const val = objectWriter.serialize(node);
          let markup = this._beginLine(this._writerOptions, 0) + "---" + this._endLine(this._writerOptions) + this._convertObject(val, this._writerOptions, 0);
          if (markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {
            markup = markup.slice(0, -this._writerOptions.newline.length);
          }
          return markup;
        }
        /**
         * Produces an XML serialization of the given object.
         *
         * @param obj - object to serialize
         * @param options - serialization options
         * @param level - depth of the XML tree
         * @param indentLeaf - indents leaf nodes
         */
        _convertObject(obj, options, level, suppressIndent = false) {
          let markup = "";
          if ((0, util_1.isArray)(obj)) {
            for (const val of obj) {
              markup += this._beginLine(options, level, true);
              if (!(0, util_1.isObject)(val)) {
                markup += this._val(val) + this._endLine(options);
              } else if ((0, util_1.isEmpty)(val)) {
                markup += '""' + this._endLine(options);
              } else {
                markup += this._convertObject(val, options, level, true);
              }
            }
          } else {
            (0, util_1.forEachObject)(obj, (key, val) => {
              if (suppressIndent) {
                markup += this._key(key);
                suppressIndent = false;
              } else {
                markup += this._beginLine(options, level) + this._key(key);
              }
              if (!(0, util_1.isObject)(val) && !(0, util_1.isArray)(val)) {
                markup += " " + this._val(val) + this._endLine(options);
              } else if ((0, util_1.isEmpty)(val)) {
                markup += ' ""' + this._endLine(options);
              } else {
                markup += this._endLine(options) + this._convertObject(val, options, level + 1);
              }
            }, this);
          }
          return markup;
        }
        /**
         * Produces characters to be prepended to a line of string in pretty-print
         * mode.
         *
         * @param options - serialization options
         * @param level - current depth of the XML tree
         * @param isArray - whether this line is an array item
         */
        _beginLine(options, level, isArray = false) {
          const indentLevel = options.offset + level + 1;
          const chars = new Array(indentLevel).join(options.indent);
          if (isArray) {
            return chars.substr(0, chars.length - 2) + "-" + chars.substr(-1, 1);
          } else {
            return chars;
          }
        }
        /**
         * Produces characters to be appended to a line of string in pretty-print
         * mode.
         *
         * @param options - serialization options
         */
        _endLine(options) {
          return options.newline;
        }
        /**
         * Produces a YAML key string delimited with double quotes.
         */
        _key(key) {
          return '"' + key + '":';
        }
        /**
         * Produces a YAML value string delimited with double quotes.
         */
        _val(val) {
          return JSON.stringify(val);
        }
      };
      exports.YAMLWriter = YAMLWriter;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/index.js
  var require_writers = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.YAMLWriter = exports.JSONWriter = exports.ObjectWriter = exports.XMLWriter = exports.MapWriter = void 0;
      var MapWriter_1 = require_MapWriter();
      Object.defineProperty(exports, "MapWriter", { enumerable: true, get: function() {
        return MapWriter_1.MapWriter;
      } });
      var XMLWriter_1 = require_XMLWriter();
      Object.defineProperty(exports, "XMLWriter", { enumerable: true, get: function() {
        return XMLWriter_1.XMLWriter;
      } });
      var ObjectWriter_1 = require_ObjectWriter();
      Object.defineProperty(exports, "ObjectWriter", { enumerable: true, get: function() {
        return ObjectWriter_1.ObjectWriter;
      } });
      var JSONWriter_1 = require_JSONWriter();
      Object.defineProperty(exports, "JSONWriter", { enumerable: true, get: function() {
        return JSONWriter_1.JSONWriter;
      } });
      var YAMLWriter_1 = require_YAMLWriter();
      Object.defineProperty(exports, "YAMLWriter", { enumerable: true, get: function() {
        return YAMLWriter_1.YAMLWriter;
      } });
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/ChildNodeImpl.js
  var require_ChildNodeImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/ChildNodeImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ChildNodeImpl = void 0;
      var util_1 = require_util2();
      var algorithm_1 = require_algorithm();
      var ChildNodeImpl = class {
        /** @inheritdoc */
        before(...nodes) {
          const context = util_1.Cast.asNode(this);
          const parent = context._parent;
          if (parent === null)
            return;
          let viablePreviousSibling = context._previousSibling;
          let flag = true;
          while (flag && viablePreviousSibling) {
            flag = false;
            for (let i = 0; i < nodes.length; i++) {
              const child = nodes[i];
              if (child === viablePreviousSibling) {
                viablePreviousSibling = viablePreviousSibling._previousSibling;
                flag = true;
                break;
              }
            }
          }
          const node = (0, algorithm_1.parentNode_convertNodesIntoANode)(nodes, context._nodeDocument);
          if (viablePreviousSibling === null)
            viablePreviousSibling = parent._firstChild;
          else
            viablePreviousSibling = viablePreviousSibling._nextSibling;
          (0, algorithm_1.mutation_preInsert)(node, parent, viablePreviousSibling);
        }
        /** @inheritdoc */
        after(...nodes) {
          const context = util_1.Cast.asNode(this);
          const parent = context._parent;
          if (!parent)
            return;
          let viableNextSibling = context._nextSibling;
          let flag = true;
          while (flag && viableNextSibling) {
            flag = false;
            for (let i = 0; i < nodes.length; i++) {
              const child = nodes[i];
              if (child === viableNextSibling) {
                viableNextSibling = viableNextSibling._nextSibling;
                flag = true;
                break;
              }
            }
          }
          const node = (0, algorithm_1.parentNode_convertNodesIntoANode)(nodes, context._nodeDocument);
          (0, algorithm_1.mutation_preInsert)(node, parent, viableNextSibling);
        }
        /** @inheritdoc */
        replaceWith(...nodes) {
          const context = util_1.Cast.asNode(this);
          const parent = context._parent;
          if (!parent)
            return;
          let viableNextSibling = context._nextSibling;
          let flag = true;
          while (flag && viableNextSibling) {
            flag = false;
            for (let i = 0; i < nodes.length; i++) {
              const child = nodes[i];
              if (child === viableNextSibling) {
                viableNextSibling = viableNextSibling._nextSibling;
                flag = true;
                break;
              }
            }
          }
          const node = (0, algorithm_1.parentNode_convertNodesIntoANode)(nodes, context._nodeDocument);
          if (context._parent === parent)
            (0, algorithm_1.mutation_replace)(context, node, parent);
          else
            (0, algorithm_1.mutation_preInsert)(node, parent, viableNextSibling);
        }
        /** @inheritdoc */
        remove() {
          const context = util_1.Cast.asNode(this);
          const parent = context._parent;
          if (!parent)
            return;
          (0, algorithm_1.mutation_remove)(context, parent);
        }
      };
      exports.ChildNodeImpl = ChildNodeImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DocumentOrShadowRootImpl.js
  var require_DocumentOrShadowRootImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/DocumentOrShadowRootImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DocumentOrShadowRootImpl = void 0;
      var DocumentOrShadowRootImpl = class {
      };
      exports.DocumentOrShadowRootImpl = DocumentOrShadowRootImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/MutationObserverImpl.js
  var require_MutationObserverImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/MutationObserverImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MutationObserverImpl = void 0;
      var DOMImpl_1 = require_DOMImpl();
      var util_1 = require_util2();
      var infra_1 = require_lib5();
      var MutationObserverImpl = class {
        /**
         * Initializes a new instance of `MutationObserver`.
         *
         * @param callback - the callback function
         */
        constructor(callback) {
          __publicField(this, "_callback");
          __publicField(this, "_nodeList", []);
          __publicField(this, "_recordQueue", []);
          this._callback = callback;
          const window2 = DOMImpl_1.dom.window;
          infra_1.set.append(window2._mutationObservers, this);
        }
        /** @inheritdoc */
        observe(target, options) {
          options = options || {
            childList: false,
            subtree: false
          };
          if ((options.attributeOldValue !== void 0 || options.attributeFilter !== void 0) && options.attributes === void 0) {
            options.attributes = true;
          }
          if (options.characterDataOldValue !== void 0 && options.characterData === void 0) {
            options.characterData = true;
          }
          if (!options.childList && !options.attributes && !options.characterData) {
            throw new TypeError();
          }
          if (options.attributeOldValue && !options.attributes) {
            throw new TypeError();
          }
          if (options.attributeFilter !== void 0 && !options.attributes) {
            throw new TypeError();
          }
          if (options.characterDataOldValue && !options.characterData) {
            throw new TypeError();
          }
          let isRegistered = false;
          const coptions = options;
          for (const registered of target._registeredObserverList) {
            if (registered.observer === this) {
              isRegistered = true;
              for (const node of this._nodeList) {
                infra_1.list.remove(node._registeredObserverList, (ob) => util_1.Guard.isTransientRegisteredObserver(ob) && ob.source === registered);
              }
              registered.options = coptions;
            }
          }
          if (!isRegistered) {
            target._registeredObserverList.push({ observer: this, options });
            this._nodeList.push(target);
          }
        }
        /** @inheritdoc */
        disconnect() {
          for (const node of this._nodeList) {
            infra_1.list.remove(node._registeredObserverList, (ob) => ob.observer === this);
          }
          this._recordQueue = [];
        }
        /** @inheritdoc */
        takeRecords() {
          const records = this._recordQueue;
          this._recordQueue = [];
          return records;
        }
      };
      exports.MutationObserverImpl = MutationObserverImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NonDocumentTypeChildNodeImpl.js
  var require_NonDocumentTypeChildNodeImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NonDocumentTypeChildNodeImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NonDocumentTypeChildNodeImpl = void 0;
      var util_1 = require_util2();
      var NonDocumentTypeChildNodeImpl = class {
        /** @inheritdoc */
        get previousElementSibling() {
          let node = util_1.Cast.asNode(this)._previousSibling;
          while (node) {
            if (util_1.Guard.isElementNode(node))
              return node;
            else
              node = node._previousSibling;
          }
          return null;
        }
        /** @inheritdoc */
        get nextElementSibling() {
          let node = util_1.Cast.asNode(this)._nextSibling;
          while (node) {
            if (util_1.Guard.isElementNode(node))
              return node;
            else
              node = node._nextSibling;
          }
          return null;
        }
      };
      exports.NonDocumentTypeChildNodeImpl = NonDocumentTypeChildNodeImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NonElementParentNodeImpl.js
  var require_NonElementParentNodeImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/NonElementParentNodeImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NonElementParentNodeImpl = void 0;
      var util_1 = require_util2();
      var algorithm_1 = require_algorithm();
      var NonElementParentNodeImpl = class {
        /** @inheritdoc */
        getElementById(id) {
          let ele = (0, algorithm_1.tree_getFirstDescendantNode)(util_1.Cast.asNode(this), false, false, (e) => util_1.Guard.isElementNode(e));
          while (ele !== null) {
            if (ele._uniqueIdentifier === id) {
              return ele;
            }
            ele = (0, algorithm_1.tree_getNextDescendantNode)(util_1.Cast.asNode(this), ele, false, false, (e) => util_1.Guard.isElementNode(e));
          }
          return null;
        }
      };
      exports.NonElementParentNodeImpl = NonElementParentNodeImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/ParentNodeImpl.js
  var require_ParentNodeImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/ParentNodeImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ParentNodeImpl = void 0;
      var util_1 = require_util2();
      var algorithm_1 = require_algorithm();
      var ParentNodeImpl = class {
        /** @inheritdoc */
        get children() {
          return (0, algorithm_1.create_htmlCollection)(util_1.Cast.asNode(this));
        }
        /** @inheritdoc */
        get firstElementChild() {
          let node = util_1.Cast.asNode(this)._firstChild;
          while (node) {
            if (util_1.Guard.isElementNode(node))
              return node;
            else
              node = node._nextSibling;
          }
          return null;
        }
        /** @inheritdoc */
        get lastElementChild() {
          let node = util_1.Cast.asNode(this)._lastChild;
          while (node) {
            if (util_1.Guard.isElementNode(node))
              return node;
            else
              node = node._previousSibling;
          }
          return null;
        }
        /** @inheritdoc */
        get childElementCount() {
          let count = 0;
          for (const childNode of util_1.Cast.asNode(this)._children) {
            if (util_1.Guard.isElementNode(childNode))
              count++;
          }
          return count;
        }
        /** @inheritdoc */
        prepend(...nodes) {
          const node = util_1.Cast.asNode(this);
          const childNode = (0, algorithm_1.parentNode_convertNodesIntoANode)(nodes, node._nodeDocument);
          (0, algorithm_1.mutation_preInsert)(childNode, node, node._firstChild);
        }
        /** @inheritdoc */
        append(...nodes) {
          const node = util_1.Cast.asNode(this);
          const childNode = (0, algorithm_1.parentNode_convertNodesIntoANode)(nodes, node._nodeDocument);
          (0, algorithm_1.mutation_append)(childNode, node);
        }
        /** @inheritdoc */
        querySelector(selectors) {
          const node = util_1.Cast.asNode(this);
          const result = (0, algorithm_1.selectors_scopeMatchASelectorsString)(selectors, node);
          return result.length === 0 ? null : result[0];
        }
        /** @inheritdoc */
        querySelectorAll(selectors) {
          const node = util_1.Cast.asNode(this);
          const result = (0, algorithm_1.selectors_scopeMatchASelectorsString)(selectors, node);
          return (0, algorithm_1.create_nodeListStatic)(node, result);
        }
      };
      exports.ParentNodeImpl = ParentNodeImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/SlotableImpl.js
  var require_SlotableImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/SlotableImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SlotableImpl = void 0;
      var algorithm_1 = require_algorithm();
      var SlotableImpl = class {
        constructor() {
          __publicField(this, "__name");
          __publicField(this, "__assignedSlot");
        }
        get _name() {
          return this.__name || "";
        }
        set _name(val) {
          this.__name = val;
        }
        get _assignedSlot() {
          return this.__assignedSlot || null;
        }
        set _assignedSlot(val) {
          this.__assignedSlot = val;
        }
        /** @inheritdoc */
        get assignedSlot() {
          return (0, algorithm_1.shadowTree_findASlot)(this, true);
        }
      };
      exports.SlotableImpl = SlotableImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/StaticRangeImpl.js
  var require_StaticRangeImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/StaticRangeImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StaticRangeImpl = void 0;
      var AbstractRangeImpl_1 = require_AbstractRangeImpl();
      var DOMException_1 = require_DOMException();
      var util_1 = require_util2();
      var StaticRangeImpl = class extends AbstractRangeImpl_1.AbstractRangeImpl {
        /**
         * Initializes a new instance of `StaticRange`.
         */
        constructor(init) {
          super();
          __publicField(this, "_start");
          __publicField(this, "_end");
          if (util_1.Guard.isDocumentTypeNode(init.startContainer) || util_1.Guard.isAttrNode(init.startContainer) || util_1.Guard.isDocumentTypeNode(init.endContainer) || util_1.Guard.isAttrNode(init.endContainer)) {
            throw new DOMException_1.InvalidNodeTypeError();
          }
          this._start = [init.startContainer, init.startOffset];
          this._end = [init.endContainer, init.endOffset];
        }
      };
      exports.StaticRangeImpl = StaticRangeImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/index.js
  var require_dom = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/dom/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLDocument = exports.Window = exports.TreeWalker = exports.Traverser = exports.Text = exports.StaticRange = exports.ShadowRoot = exports.Range = exports.ProcessingInstruction = exports.NodeListStatic = exports.NodeList = exports.NodeIterator = exports.Node = exports.NodeFilter = exports.NamedNodeMap = exports.MutationRecord = exports.MutationObserver = exports.HTMLCollection = exports.EventTarget = exports.Event = exports.Element = exports.DOMTokenList = exports.DOMImplementation = exports.dom = exports.DocumentType = exports.Document = exports.DocumentFragment = exports.CustomEvent = exports.Comment = exports.CharacterData = exports.CDATASection = exports.Attr = exports.AbstractRange = exports.AbortSignal = exports.AbortController = void 0;
      var util_1 = require_lib4();
      var AbortControllerImpl_1 = require_AbortControllerImpl();
      Object.defineProperty(exports, "AbortController", { enumerable: true, get: function() {
        return AbortControllerImpl_1.AbortControllerImpl;
      } });
      var AbortSignalImpl_1 = require_AbortSignalImpl();
      Object.defineProperty(exports, "AbortSignal", { enumerable: true, get: function() {
        return AbortSignalImpl_1.AbortSignalImpl;
      } });
      var AbstractRangeImpl_1 = require_AbstractRangeImpl();
      Object.defineProperty(exports, "AbstractRange", { enumerable: true, get: function() {
        return AbstractRangeImpl_1.AbstractRangeImpl;
      } });
      var AttrImpl_1 = require_AttrImpl();
      Object.defineProperty(exports, "Attr", { enumerable: true, get: function() {
        return AttrImpl_1.AttrImpl;
      } });
      var CDATASectionImpl_1 = require_CDATASectionImpl();
      Object.defineProperty(exports, "CDATASection", { enumerable: true, get: function() {
        return CDATASectionImpl_1.CDATASectionImpl;
      } });
      var CharacterDataImpl_1 = require_CharacterDataImpl();
      Object.defineProperty(exports, "CharacterData", { enumerable: true, get: function() {
        return CharacterDataImpl_1.CharacterDataImpl;
      } });
      var ChildNodeImpl_1 = require_ChildNodeImpl();
      var CommentImpl_1 = require_CommentImpl();
      Object.defineProperty(exports, "Comment", { enumerable: true, get: function() {
        return CommentImpl_1.CommentImpl;
      } });
      var CustomEventImpl_1 = require_CustomEventImpl();
      Object.defineProperty(exports, "CustomEvent", { enumerable: true, get: function() {
        return CustomEventImpl_1.CustomEventImpl;
      } });
      var DocumentFragmentImpl_1 = require_DocumentFragmentImpl();
      Object.defineProperty(exports, "DocumentFragment", { enumerable: true, get: function() {
        return DocumentFragmentImpl_1.DocumentFragmentImpl;
      } });
      var DocumentImpl_1 = require_DocumentImpl();
      Object.defineProperty(exports, "Document", { enumerable: true, get: function() {
        return DocumentImpl_1.DocumentImpl;
      } });
      var DocumentOrShadowRootImpl_1 = require_DocumentOrShadowRootImpl();
      var DocumentTypeImpl_1 = require_DocumentTypeImpl();
      Object.defineProperty(exports, "DocumentType", { enumerable: true, get: function() {
        return DocumentTypeImpl_1.DocumentTypeImpl;
      } });
      var DOMImpl_1 = require_DOMImpl();
      Object.defineProperty(exports, "dom", { enumerable: true, get: function() {
        return DOMImpl_1.dom;
      } });
      var DOMImplementationImpl_1 = require_DOMImplementationImpl();
      Object.defineProperty(exports, "DOMImplementation", { enumerable: true, get: function() {
        return DOMImplementationImpl_1.DOMImplementationImpl;
      } });
      var DOMTokenListImpl_1 = require_DOMTokenListImpl();
      Object.defineProperty(exports, "DOMTokenList", { enumerable: true, get: function() {
        return DOMTokenListImpl_1.DOMTokenListImpl;
      } });
      var ElementImpl_1 = require_ElementImpl();
      Object.defineProperty(exports, "Element", { enumerable: true, get: function() {
        return ElementImpl_1.ElementImpl;
      } });
      var EventImpl_1 = require_EventImpl();
      Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
        return EventImpl_1.EventImpl;
      } });
      var EventTargetImpl_1 = require_EventTargetImpl();
      Object.defineProperty(exports, "EventTarget", { enumerable: true, get: function() {
        return EventTargetImpl_1.EventTargetImpl;
      } });
      var HTMLCollectionImpl_1 = require_HTMLCollectionImpl();
      Object.defineProperty(exports, "HTMLCollection", { enumerable: true, get: function() {
        return HTMLCollectionImpl_1.HTMLCollectionImpl;
      } });
      var MutationObserverImpl_1 = require_MutationObserverImpl();
      Object.defineProperty(exports, "MutationObserver", { enumerable: true, get: function() {
        return MutationObserverImpl_1.MutationObserverImpl;
      } });
      var MutationRecordImpl_1 = require_MutationRecordImpl();
      Object.defineProperty(exports, "MutationRecord", { enumerable: true, get: function() {
        return MutationRecordImpl_1.MutationRecordImpl;
      } });
      var NamedNodeMapImpl_1 = require_NamedNodeMapImpl();
      Object.defineProperty(exports, "NamedNodeMap", { enumerable: true, get: function() {
        return NamedNodeMapImpl_1.NamedNodeMapImpl;
      } });
      var NodeFilterImpl_1 = require_NodeFilterImpl();
      Object.defineProperty(exports, "NodeFilter", { enumerable: true, get: function() {
        return NodeFilterImpl_1.NodeFilterImpl;
      } });
      var NodeImpl_1 = require_NodeImpl();
      Object.defineProperty(exports, "Node", { enumerable: true, get: function() {
        return NodeImpl_1.NodeImpl;
      } });
      var NodeIteratorImpl_1 = require_NodeIteratorImpl();
      Object.defineProperty(exports, "NodeIterator", { enumerable: true, get: function() {
        return NodeIteratorImpl_1.NodeIteratorImpl;
      } });
      var NodeListImpl_1 = require_NodeListImpl();
      Object.defineProperty(exports, "NodeList", { enumerable: true, get: function() {
        return NodeListImpl_1.NodeListImpl;
      } });
      var NodeListStaticImpl_1 = require_NodeListStaticImpl();
      Object.defineProperty(exports, "NodeListStatic", { enumerable: true, get: function() {
        return NodeListStaticImpl_1.NodeListStaticImpl;
      } });
      var NonDocumentTypeChildNodeImpl_1 = require_NonDocumentTypeChildNodeImpl();
      var NonElementParentNodeImpl_1 = require_NonElementParentNodeImpl();
      var ParentNodeImpl_1 = require_ParentNodeImpl();
      var ProcessingInstructionImpl_1 = require_ProcessingInstructionImpl();
      Object.defineProperty(exports, "ProcessingInstruction", { enumerable: true, get: function() {
        return ProcessingInstructionImpl_1.ProcessingInstructionImpl;
      } });
      var RangeImpl_1 = require_RangeImpl();
      Object.defineProperty(exports, "Range", { enumerable: true, get: function() {
        return RangeImpl_1.RangeImpl;
      } });
      var ShadowRootImpl_1 = require_ShadowRootImpl();
      Object.defineProperty(exports, "ShadowRoot", { enumerable: true, get: function() {
        return ShadowRootImpl_1.ShadowRootImpl;
      } });
      var SlotableImpl_1 = require_SlotableImpl();
      var StaticRangeImpl_1 = require_StaticRangeImpl();
      Object.defineProperty(exports, "StaticRange", { enumerable: true, get: function() {
        return StaticRangeImpl_1.StaticRangeImpl;
      } });
      var TextImpl_1 = require_TextImpl();
      Object.defineProperty(exports, "Text", { enumerable: true, get: function() {
        return TextImpl_1.TextImpl;
      } });
      var TraverserImpl_1 = require_TraverserImpl();
      Object.defineProperty(exports, "Traverser", { enumerable: true, get: function() {
        return TraverserImpl_1.TraverserImpl;
      } });
      var TreeWalkerImpl_1 = require_TreeWalkerImpl();
      Object.defineProperty(exports, "TreeWalker", { enumerable: true, get: function() {
        return TreeWalkerImpl_1.TreeWalkerImpl;
      } });
      var WindowImpl_1 = require_WindowImpl();
      Object.defineProperty(exports, "Window", { enumerable: true, get: function() {
        return WindowImpl_1.WindowImpl;
      } });
      var XMLDocumentImpl_1 = require_XMLDocumentImpl();
      Object.defineProperty(exports, "XMLDocument", { enumerable: true, get: function() {
        return XMLDocumentImpl_1.XMLDocumentImpl;
      } });
      (0, util_1.applyMixin)(ElementImpl_1.ElementImpl, ChildNodeImpl_1.ChildNodeImpl);
      (0, util_1.applyMixin)(CharacterDataImpl_1.CharacterDataImpl, ChildNodeImpl_1.ChildNodeImpl);
      (0, util_1.applyMixin)(DocumentTypeImpl_1.DocumentTypeImpl, ChildNodeImpl_1.ChildNodeImpl);
      (0, util_1.applyMixin)(DocumentImpl_1.DocumentImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
      (0, util_1.applyMixin)(ShadowRootImpl_1.ShadowRootImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
      (0, util_1.applyMixin)(ElementImpl_1.ElementImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
      (0, util_1.applyMixin)(CharacterDataImpl_1.CharacterDataImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
      (0, util_1.applyMixin)(DocumentImpl_1.DocumentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
      (0, util_1.applyMixin)(DocumentFragmentImpl_1.DocumentFragmentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
      (0, util_1.applyMixin)(DocumentImpl_1.DocumentImpl, ParentNodeImpl_1.ParentNodeImpl);
      (0, util_1.applyMixin)(DocumentFragmentImpl_1.DocumentFragmentImpl, ParentNodeImpl_1.ParentNodeImpl);
      (0, util_1.applyMixin)(ElementImpl_1.ElementImpl, ParentNodeImpl_1.ParentNodeImpl);
      (0, util_1.applyMixin)(TextImpl_1.TextImpl, SlotableImpl_1.SlotableImpl);
      (0, util_1.applyMixin)(ElementImpl_1.ElementImpl, SlotableImpl_1.SlotableImpl);
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/parser/interfaces.js
  var require_interfaces4 = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/parser/interfaces.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TokenType = void 0;
      var TokenType;
      (function(TokenType2) {
        TokenType2[TokenType2["EOF"] = 0] = "EOF";
        TokenType2[TokenType2["Declaration"] = 1] = "Declaration";
        TokenType2[TokenType2["DocType"] = 2] = "DocType";
        TokenType2[TokenType2["Element"] = 3] = "Element";
        TokenType2[TokenType2["Text"] = 4] = "Text";
        TokenType2[TokenType2["CDATA"] = 5] = "CDATA";
        TokenType2[TokenType2["PI"] = 6] = "PI";
        TokenType2[TokenType2["Comment"] = 7] = "Comment";
        TokenType2[TokenType2["ClosingTag"] = 8] = "ClosingTag";
      })(TokenType || (exports.TokenType = TokenType = {}));
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/parser/XMLStringLexer.js
  var require_XMLStringLexer = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/parser/XMLStringLexer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLStringLexer = void 0;
      var interfaces_1 = require_interfaces4();
      var XMLStringLexer = class _XMLStringLexer {
        /**
         * Initializes a new instance of `XMLStringLexer`.
         *
         * @param str - the string to tokenize and lex
         * @param options - lexer options
         */
        constructor(str, options) {
          __publicField(this, "_str");
          __publicField(this, "_index");
          __publicField(this, "_length");
          __publicField(this, "_options", {
            skipWhitespaceOnlyText: false
          });
          __publicField(this, "err", { line: -1, col: -1, index: -1, str: "" });
          this._str = str;
          this._index = 0;
          this._length = str.length;
          if (options) {
            this._options.skipWhitespaceOnlyText = options.skipWhitespaceOnlyText || false;
          }
        }
        /**
         * Returns the next token.
         */
        nextToken() {
          if (this.eof()) {
            return { type: interfaces_1.TokenType.EOF };
          }
          let token = this.skipIfStartsWith("<") ? this.openBracket() : this.text();
          if (this._options.skipWhitespaceOnlyText) {
            if (token.type === interfaces_1.TokenType.Text && _XMLStringLexer.isWhiteSpaceToken(token)) {
              token = this.nextToken();
            }
          }
          return token;
        }
        /**
         * Branches from an opening bracket (`<`).
         */
        openBracket() {
          if (this.skipIfStartsWith("?")) {
            if (this.skipIfStartsWith("xml")) {
              if (_XMLStringLexer.isSpace(this._str[this._index])) {
                return this.declaration();
              } else {
                this.seek(-3);
                return this.pi();
              }
            } else {
              return this.pi();
            }
          } else if (this.skipIfStartsWith("!")) {
            if (this.skipIfStartsWith("--")) {
              return this.comment();
            } else if (this.skipIfStartsWith("[CDATA[")) {
              return this.cdata();
            } else if (this.skipIfStartsWith("DOCTYPE")) {
              return this.doctype();
            } else {
              this.throwError("Invalid '!' in opening tag.");
            }
          } else if (this.skipIfStartsWith("/")) {
            return this.closeTag();
          } else {
            return this.openTag();
          }
        }
        /**
         * Produces an XML declaration token.
         */
        declaration() {
          let version = "";
          let encoding = "";
          let standalone = "";
          while (!this.eof()) {
            this.skipSpace();
            if (this.skipIfStartsWith("?>")) {
              return { type: interfaces_1.TokenType.Declaration, version, encoding, standalone };
            } else {
              const [attName, attValue] = this.attribute();
              if (attName === "version")
                version = attValue;
              else if (attName === "encoding")
                encoding = attValue;
              else if (attName === "standalone")
                standalone = attValue;
              else
                this.throwError("Invalid attribute name: " + attName);
            }
          }
          this.throwError("Missing declaration end symbol `?>`");
        }
        /**
         * Produces a doc type token.
         */
        doctype() {
          let pubId = "";
          let sysId = "";
          this.skipSpace();
          const name = this.takeUntil2("[", ">", true);
          this.skipSpace();
          if (this.skipIfStartsWith("PUBLIC")) {
            pubId = this.quotedString();
            sysId = this.quotedString();
          } else if (this.skipIfStartsWith("SYSTEM")) {
            sysId = this.quotedString();
          }
          this.skipSpace();
          if (this.skipIfStartsWith("[")) {
            this.skipUntil("]");
            if (!this.skipIfStartsWith("]")) {
              this.throwError("Missing end bracket of DTD internal subset");
            }
          }
          this.skipSpace();
          if (!this.skipIfStartsWith(">")) {
            this.throwError("Missing doctype end symbol `>`");
          }
          return { type: interfaces_1.TokenType.DocType, name, pubId, sysId };
        }
        /**
         * Produces a processing instruction token.
         */
        pi() {
          const target = this.takeUntilStartsWith("?>", true);
          if (this.eof()) {
            this.throwError("Missing processing instruction end symbol `?>`");
          }
          this.skipSpace();
          if (this.skipIfStartsWith("?>")) {
            return { type: interfaces_1.TokenType.PI, target, data: "" };
          }
          const data = this.takeUntilStartsWith("?>");
          if (this.eof()) {
            this.throwError("Missing processing instruction end symbol `?>`");
          }
          this.seek(2);
          return { type: interfaces_1.TokenType.PI, target, data };
        }
        /**
         * Produces a text token.
         *
         */
        text() {
          const data = this.takeUntil("<");
          return { type: interfaces_1.TokenType.Text, data };
        }
        /**
         * Produces a comment token.
         *
         */
        comment() {
          const data = this.takeUntilStartsWith("-->");
          if (this.eof()) {
            this.throwError("Missing comment end symbol `-->`");
          }
          this.seek(3);
          return { type: interfaces_1.TokenType.Comment, data };
        }
        /**
         * Produces a CDATA token.
         *
         */
        cdata() {
          const data = this.takeUntilStartsWith("]]>");
          if (this.eof()) {
            this.throwError("Missing CDATA end symbol `]>`");
          }
          this.seek(3);
          return { type: interfaces_1.TokenType.CDATA, data };
        }
        /**
         * Produces an element token.
         */
        openTag() {
          this.skipSpace();
          const name = this.takeUntil2(">", "/", true);
          this.skipSpace();
          if (this.skipIfStartsWith(">")) {
            return { type: interfaces_1.TokenType.Element, name, attributes: [], selfClosing: false };
          } else if (this.skipIfStartsWith("/>")) {
            return { type: interfaces_1.TokenType.Element, name, attributes: [], selfClosing: true };
          }
          const attributes = [];
          while (!this.eof()) {
            this.skipSpace();
            if (this.skipIfStartsWith(">")) {
              return { type: interfaces_1.TokenType.Element, name, attributes, selfClosing: false };
            } else if (this.skipIfStartsWith("/>")) {
              return { type: interfaces_1.TokenType.Element, name, attributes, selfClosing: true };
            }
            const attr = this.attribute();
            attributes.push(attr);
          }
          this.throwError("Missing opening element tag end symbol `>`");
        }
        /**
         * Produces a closing tag token.
         *
         */
        closeTag() {
          this.skipSpace();
          const name = this.takeUntil(">", true);
          this.skipSpace();
          if (!this.skipIfStartsWith(">")) {
            this.throwError("Missing closing element tag end symbol `>`");
          }
          return { type: interfaces_1.TokenType.ClosingTag, name };
        }
        /**
         * Reads an attribute name, value pair
         */
        attribute() {
          this.skipSpace();
          const name = this.takeUntil("=", true);
          this.skipSpace();
          if (!this.skipIfStartsWith("=")) {
            this.throwError("Missing equals sign before attribute value");
          }
          const value = this.quotedString();
          return [name, value];
        }
        /**
         * Reads a string between double or single quotes.
         */
        quotedString() {
          this.skipSpace();
          const startQuote = this.take(1);
          if (!_XMLStringLexer.isQuote(startQuote)) {
            this.throwError("Missing start quote character before quoted value");
          }
          const value = this.takeUntil(startQuote);
          if (!this.skipIfStartsWith(startQuote)) {
            this.throwError("Missing end quote character after quoted value");
          }
          return value;
        }
        /**
         * Determines if the current index is at or past the end of input string.
         */
        eof() {
          return this._index >= this._length;
        }
        /**
         * Skips the length of the given string if the string from current position
         * starts with the given string.
         *
         * @param str - the string to match
         */
        skipIfStartsWith(str) {
          const strLength = str.length;
          if (strLength === 1) {
            if (this._str[this._index] === str) {
              this._index++;
              return true;
            } else {
              return false;
            }
          }
          for (let i = 0; i < strLength; i++) {
            if (this._str[this._index + i] !== str[i])
              return false;
          }
          this._index += strLength;
          return true;
        }
        /**
         * Seeks a number of character codes.
         *
         * @param count - number of characters to skip
         */
        seek(count) {
          this._index += count;
          if (this._index < 0)
            this._index = 0;
          if (this._index > this._length)
            this._index = this._length;
        }
        /**
         * Skips space characters.
         */
        skipSpace() {
          while (!this.eof() && _XMLStringLexer.isSpace(this._str[this._index])) {
            this._index++;
          }
        }
        /**
         * Takes a given number of characters.
         *
         * @param count - character count
         */
        take(count) {
          if (count === 1) {
            return this._str[this._index++];
          }
          const startIndex = this._index;
          this.seek(count);
          return this._str.slice(startIndex, this._index);
        }
        /**
         * Takes characters until the next character matches `char`.
         *
         * @param char - a character to match
         * @param space - whether a space character stops iteration
         */
        takeUntil(char, space = false) {
          const startIndex = this._index;
          while (this._index < this._length) {
            const c = this._str[this._index];
            if (c !== char && (!space || !_XMLStringLexer.isSpace(c))) {
              this._index++;
            } else {
              break;
            }
          }
          return this._str.slice(startIndex, this._index);
        }
        /**
         * Takes characters until the next character matches `char1` or `char1`.
         *
         * @param char1 - a character to match
         * @param char2 - a character to match
         * @param space - whether a space character stops iteration
         */
        takeUntil2(char1, char2, space = false) {
          const startIndex = this._index;
          while (this._index < this._length) {
            const c = this._str[this._index];
            if (c !== char1 && c !== char2 && (!space || !_XMLStringLexer.isSpace(c))) {
              this._index++;
            } else {
              break;
            }
          }
          return this._str.slice(startIndex, this._index);
        }
        /**
         * Takes characters until the next characters matches `str`.
         *
         * @param str - a string to match
         * @param space - whether a space character stops iteration
         */
        takeUntilStartsWith(str, space = false) {
          const startIndex = this._index;
          const strLength = str.length;
          while (this._index < this._length) {
            let match = true;
            for (let i = 0; i < strLength; i++) {
              const c = this._str[this._index + i];
              const char = str[i];
              if (space && _XMLStringLexer.isSpace(c)) {
                return this._str.slice(startIndex, this._index);
              } else if (c !== char) {
                this._index++;
                match = false;
                break;
              }
            }
            if (match)
              return this._str.slice(startIndex, this._index);
          }
          this._index = this._length;
          return this._str.slice(startIndex);
        }
        /**
         * Skips characters until the next character matches `char`.
         *
         * @param char - a character to match
         */
        skipUntil(char) {
          while (this._index < this._length) {
            const c = this._str[this._index];
            if (c !== char) {
              this._index++;
            } else {
              break;
            }
          }
        }
        /**
         * Determines if the given token is entirely whitespace.
         *
         * @param token - the token to check
         */
        static isWhiteSpaceToken(token) {
          const str = token.data;
          for (let i = 0; i < str.length; i++) {
            const c = str[i];
            if (c !== " " && c !== "\n" && c !== "\r" && c !== "	" && c !== "\f")
              return false;
          }
          return true;
        }
        /**
         * Determines if the given character is whitespace.
         *
         * @param char - the character to check
         */
        static isSpace(char) {
          return char === " " || char === "\n" || char === "\r" || char === "	";
        }
        /**
         * Determines if the given character is a quote character.
         *
         * @param char - the character to check
         */
        static isQuote(char) {
          return char === '"' || char === "'";
        }
        /**
         * Throws a parser error and records the line and column numbers in the parsed
         * string.
         *
         * @param msg - error message
         */
        throwError(msg) {
          const regexp = /\r\n|\r|\n/g;
          let match = null;
          let line = 0;
          let firstNewLineIndex = 0;
          let lastNewlineIndex = this._str.length;
          while ((match = regexp.exec(this._str)) !== null) {
            if (match === null)
              break;
            line++;
            if (match.index < this._index)
              firstNewLineIndex = regexp.lastIndex;
            if (match.index > this._index) {
              lastNewlineIndex = match.index;
              break;
            }
          }
          this.err = {
            line,
            col: this._index - firstNewLineIndex,
            index: this._index,
            str: this._str.substring(firstNewLineIndex, lastNewlineIndex)
          };
          throw new Error(msg + "\nIndex: " + this.err.index + "\nLn: " + this.err.line + ", Col: " + this.err.col + "\nInput: " + this.err.str);
        }
        /**
         * Returns an iterator for the lexer.
         */
        [Symbol.iterator]() {
          this._index = 0;
          return {
            next: function() {
              const token = this.nextToken();
              if (token.type === interfaces_1.TokenType.EOF) {
                return { done: true, value: null };
              } else {
                return { done: false, value: token };
              }
            }.bind(this)
          };
        }
      };
      exports.XMLStringLexer = XMLStringLexer;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/parser/XMLParserImpl.js
  var require_XMLParserImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/parser/XMLParserImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLParserImpl = void 0;
      var XMLStringLexer_1 = require_XMLStringLexer();
      var interfaces_1 = require_interfaces4();
      var infra_1 = require_lib5();
      var algorithm_1 = require_algorithm();
      var LocalNameSet_1 = require_LocalNameSet();
      var XMLParserImpl = class {
        /**
         * Parses XML content.
         *
         * @param source - a string containing XML content
         */
        parse(source) {
          const lexer = new XMLStringLexer_1.XMLStringLexer(source, { skipWhitespaceOnlyText: true });
          const doc = (0, algorithm_1.create_document)();
          let context = doc;
          let token = lexer.nextToken();
          while (token.type !== interfaces_1.TokenType.EOF) {
            switch (token.type) {
              case interfaces_1.TokenType.Declaration:
                const declaration = token;
                if (declaration.version !== "1.0") {
                  throw new Error("Invalid xml version: " + declaration.version);
                }
                break;
              case interfaces_1.TokenType.DocType:
                const doctype = token;
                if (!(0, algorithm_1.xml_isPubidChar)(doctype.pubId)) {
                  throw new Error("DocType public identifier does not match PubidChar construct.");
                }
                if (!(0, algorithm_1.xml_isLegalChar)(doctype.sysId) || doctype.sysId.indexOf('"') !== -1 && doctype.sysId.indexOf("'") !== -1) {
                  throw new Error("DocType system identifier contains invalid characters.");
                }
                context.appendChild(doc.implementation.createDocumentType(doctype.name, doctype.pubId, doctype.sysId));
                break;
              case interfaces_1.TokenType.CDATA:
                const cdata = token;
                if (!(0, algorithm_1.xml_isLegalChar)(cdata.data) || cdata.data.indexOf("]]>") !== -1) {
                  throw new Error("CDATA contains invalid characters.");
                }
                context.appendChild(doc.createCDATASection(cdata.data));
                break;
              case interfaces_1.TokenType.Comment:
                const comment = token;
                if (!(0, algorithm_1.xml_isLegalChar)(comment.data) || comment.data.indexOf("--") !== -1 || comment.data.endsWith("-")) {
                  throw new Error("Comment data contains invalid characters.");
                }
                context.appendChild(doc.createComment(comment.data));
                break;
              case interfaces_1.TokenType.PI:
                const pi = token;
                if (pi.target.indexOf(":") !== -1 || /^xml$/i.test(pi.target)) {
                  throw new Error("Processing instruction target contains invalid characters.");
                }
                if (!(0, algorithm_1.xml_isLegalChar)(pi.data) || pi.data.indexOf("?>") !== -1) {
                  throw new Error("Processing instruction data contains invalid characters.");
                }
                context.appendChild(doc.createProcessingInstruction(pi.target, pi.data));
                break;
              case interfaces_1.TokenType.Text:
                const text = token;
                if (!(0, algorithm_1.xml_isLegalChar)(text.data)) {
                  throw new Error("Text data contains invalid characters.");
                }
                context.appendChild(doc.createTextNode(this._decodeText(text.data)));
                break;
              case interfaces_1.TokenType.Element:
                const element = token;
                const [prefix, localName] = (0, algorithm_1.namespace_extractQName)(element.name);
                if (localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(localName)) {
                  throw new Error("Node local name contains invalid characters.");
                }
                if (prefix === "xmlns") {
                  throw new Error("An element cannot have the 'xmlns' prefix.");
                }
                let namespace = context.lookupNamespaceURI(prefix);
                const nsDeclarations = {};
                for (const [attName, attValue] of element.attributes) {
                  if (attName === "xmlns") {
                    namespace = attValue;
                  } else {
                    const [attPrefix, attLocalName] = (0, algorithm_1.namespace_extractQName)(attName);
                    if (attPrefix === "xmlns") {
                      if (attLocalName === prefix) {
                        namespace = attValue;
                      }
                      nsDeclarations[attLocalName] = attValue;
                    }
                  }
                }
                const elementNode = namespace !== null ? doc.createElementNS(namespace, element.name) : doc.createElement(element.name);
                context.appendChild(elementNode);
                const localNameSet = new LocalNameSet_1.LocalNameSet();
                for (const [attName, attValue] of element.attributes) {
                  const [attPrefix, attLocalName] = (0, algorithm_1.namespace_extractQName)(attName);
                  let attNamespace = null;
                  if (attPrefix === "xmlns" || attPrefix === null && attLocalName === "xmlns") {
                    attNamespace = infra_1.namespace.XMLNS;
                  } else {
                    attNamespace = elementNode.lookupNamespaceURI(attPrefix);
                    if (attNamespace !== null && elementNode.isDefaultNamespace(attNamespace)) {
                      attNamespace = null;
                    } else if (attNamespace === null && attPrefix !== null) {
                      attNamespace = nsDeclarations[attPrefix] || null;
                    }
                  }
                  if (localNameSet.has(attNamespace, attLocalName)) {
                    throw new Error("Element contains duplicate attributes.");
                  }
                  localNameSet.set(attNamespace, attLocalName);
                  if (attNamespace === infra_1.namespace.XMLNS) {
                    if (attValue === infra_1.namespace.XMLNS) {
                      throw new Error("XMLNS namespace is reserved.");
                    }
                  }
                  if (attLocalName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attLocalName)) {
                    throw new Error("Attribute local name contains invalid characters.");
                  }
                  if (attPrefix === "xmlns" && attValue === "") {
                    throw new Error("Empty XML namespace is not allowed.");
                  }
                  if (attNamespace !== null)
                    elementNode.setAttributeNS(attNamespace, attName, this._decodeAttributeValue(attValue));
                  else
                    elementNode.setAttribute(attName, this._decodeAttributeValue(attValue));
                }
                if (!element.selfClosing) {
                  context = elementNode;
                }
                break;
              case interfaces_1.TokenType.ClosingTag:
                const closingTag = token;
                if (closingTag.name !== context.nodeName) {
                  throw new Error("Closing tag name does not match opening tag name.");
                }
                if (context._parent) {
                  context = context._parent;
                }
                break;
            }
            token = lexer.nextToken();
          }
          return doc;
        }
        /**
         * Decodes serialized text.
         *
         * @param text - text value to serialize
         */
        _decodeText(text) {
          return text == null ? text : text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
        }
        /**
         * Decodes serialized attribute value.
         *
         * @param text - attribute value to serialize
         */
        _decodeAttributeValue(text) {
          return text == null ? text : text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
        }
      };
      exports.XMLParserImpl = XMLParserImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/parser/DOMParserImpl.js
  var require_DOMParserImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/parser/DOMParserImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DOMParserImpl = void 0;
      var algorithm_1 = require_algorithm();
      var XMLParserImpl_1 = require_XMLParserImpl();
      var DOMParserImpl = class {
        /** @inheritdoc */
        parseFromString(source, mimeType) {
          if (mimeType === "text/html")
            throw new Error("HTML parser not implemented.");
          try {
            const parser = new XMLParserImpl_1.XMLParserImpl();
            const doc = parser.parse(source);
            doc._contentType = mimeType;
            return doc;
          } catch (e) {
            const errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
            const doc = (0, algorithm_1.create_xmlDocument)();
            const root = doc.createElementNS(errorNS, "parsererror");
            const ele = doc.createElementNS(errorNS, "error");
            ele.setAttribute("message", e.message);
            root.appendChild(ele);
            doc.appendChild(root);
            return doc;
          }
        }
      };
      exports.DOMParserImpl = DOMParserImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/parser/index.js
  var require_parser = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/parser/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DOMParser = void 0;
      var DOMParserImpl_1 = require_DOMParserImpl();
      Object.defineProperty(exports, "DOMParser", { enumerable: true, get: function() {
        return DOMParserImpl_1.DOMParserImpl;
      } });
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/serializer/XMLSerializerImpl.js
  var require_XMLSerializerImpl = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/serializer/XMLSerializerImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLSerializerImpl = void 0;
      var interfaces_1 = require_interfaces2();
      var LocalNameSet_1 = require_LocalNameSet();
      var NamespacePrefixMap_1 = require_NamespacePrefixMap();
      var DOMException_1 = require_DOMException();
      var infra_1 = require_lib5();
      var algorithm_1 = require_algorithm();
      var _XMLSerializerImpl = class _XMLSerializerImpl {
        /** @inheritdoc */
        serializeToString(root) {
          return this._xmlSerialization(root, false);
        }
        /**
         * Produces an XML serialization of the given node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _xmlSerialization(node, requireWellFormed) {
          if (node._nodeDocument === void 0 || node._nodeDocument._hasNamespaces) {
            const namespace = null;
            const prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
            prefixMap.set("xml", infra_1.namespace.XML);
            const prefixIndex = { value: 1 };
            try {
              return this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            } catch (e) {
              throw new DOMException_1.InvalidStateError();
            }
          } else {
            try {
              return this._serializeNode(node, requireWellFormed);
            } catch (e) {
              throw new DOMException_1.InvalidStateError();
            }
          }
        }
        /**
         * Produces an XML serialization of a node.
         *
         * @param node - node to serialize
         * @param namespace - context namespace
         * @param prefixMap - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param requireWellFormed - whether to check conformance
         */
        _serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
          switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
              return this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.Document:
              return this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.Comment:
              return this._serializeComment(node, requireWellFormed);
            case interfaces_1.NodeType.Text:
              return this._serializeText(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentFragment:
              return this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.DocumentType:
              return this._serializeDocumentType(node, requireWellFormed);
            case interfaces_1.NodeType.ProcessingInstruction:
              return this._serializeProcessingInstruction(node, requireWellFormed);
            case interfaces_1.NodeType.CData:
              return this._serializeCData(node, requireWellFormed);
            default:
              throw new Error(`Unknown node type: ${node.nodeType}`);
          }
        }
        /**
         * Produces an XML serialization of a node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeNode(node, requireWellFormed) {
          switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
              return this._serializeElement(node, requireWellFormed);
            case interfaces_1.NodeType.Document:
              return this._serializeDocument(node, requireWellFormed);
            case interfaces_1.NodeType.Comment:
              return this._serializeComment(node, requireWellFormed);
            case interfaces_1.NodeType.Text:
              return this._serializeText(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentFragment:
              return this._serializeDocumentFragment(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentType:
              return this._serializeDocumentType(node, requireWellFormed);
            case interfaces_1.NodeType.ProcessingInstruction:
              return this._serializeProcessingInstruction(node, requireWellFormed);
            case interfaces_1.NodeType.CData:
              return this._serializeCData(node, requireWellFormed);
            default:
              throw new Error(`Unknown node type: ${node.nodeType}`);
          }
        }
        /**
         * Produces an XML serialization of an element node.
         *
         * @param node - node to serialize
         * @param namespace - context namespace
         * @param prefixMap - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param requireWellFormed - whether to check conformance
         */
        _serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
          if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
          }
          let markup = "<";
          let qualifiedName = "";
          let skipEndTag = false;
          let ignoreNamespaceDefinitionAttribute = false;
          let map = prefixMap.copy();
          let localPrefixesMap = {};
          let localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
          let inheritedNS = namespace;
          let ns = node.namespaceURI;
          if (inheritedNS === ns) {
            if (localDefaultNamespace !== null) {
              ignoreNamespaceDefinitionAttribute = true;
            }
            if (ns === infra_1.namespace.XML) {
              qualifiedName = "xml:" + node.localName;
            } else {
              qualifiedName = node.localName;
            }
            markup += qualifiedName;
          } else {
            let prefix = node.prefix;
            let candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
              candidatePrefix = map.get(prefix, ns);
            }
            if (prefix === "xmlns") {
              if (requireWellFormed) {
                throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
              }
              candidatePrefix = prefix;
            }
            if (candidatePrefix !== null) {
              qualifiedName = candidatePrefix + ":" + node.localName;
              if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                inheritedNS = localDefaultNamespace || null;
              }
              markup += qualifiedName;
            } else if (prefix !== null) {
              if (prefix in localPrefixesMap) {
                prefix = this._generatePrefix(ns, map, prefixIndex);
              }
              map.set(prefix, ns);
              qualifiedName += prefix + ":" + node.localName;
              markup += qualifiedName;
              markup += " xmlns:" + prefix + '="' + this._serializeAttributeValue(ns, requireWellFormed) + '"';
              if (localDefaultNamespace !== null) {
                inheritedNS = localDefaultNamespace || null;
              }
            } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
              ignoreNamespaceDefinitionAttribute = true;
              qualifiedName += node.localName;
              inheritedNS = ns;
              markup += qualifiedName;
              markup += ' xmlns="' + this._serializeAttributeValue(ns, requireWellFormed) + '"';
            } else {
              qualifiedName += node.localName;
              inheritedNS = ns;
              markup += qualifiedName;
            }
          }
          markup += this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed);
          const isHTML = ns === infra_1.namespace.HTML;
          if (isHTML && node.childNodes.length === 0 && _XMLSerializerImpl._VoidElementNames.has(node.localName)) {
            markup += " /";
            skipEndTag = true;
          } else if (!isHTML && node.childNodes.length === 0) {
            markup += "/";
            skipEndTag = true;
          }
          markup += ">";
          if (skipEndTag)
            return markup;
          if (isHTML && node.localName === "template") {
          } else {
            for (const childNode of node._children || node.childNodes) {
              markup += this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
            }
          }
          markup += "</" + qualifiedName + ">";
          return markup;
        }
        /**
         * Produces an XML serialization of a document node.
         *
         * @param node - node to serialize
         * @param namespace - context namespace
         * @param prefixMap - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param requireWellFormed - whether to check conformance
         */
        _serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
          if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
          }
          let serializedDocument = "";
          for (const childNode of node._children || node.childNodes) {
            serializedDocument += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
          }
          return serializedDocument;
        }
        /**
         * Produces an XML serialization of a comment node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeComment(node, requireWellFormed) {
          if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            throw new Error("Comment data contains invalid characters (well-formed required).");
          }
          return "<!--" + node.data + "-->";
        }
        /**
         * Produces an XML serialization of a text node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         * @param level - current depth of the XML tree
         */
        _serializeText(node, requireWellFormed) {
          if (requireWellFormed && !(0, algorithm_1.xml_isLegalChar)(node.data)) {
            throw new Error("Text data contains invalid characters (well-formed required).");
          }
          let result = "";
          for (let i = 0; i < node.data.length; i++) {
            const c = node.data[i];
            if (c === "&")
              result += "&amp;";
            else if (c === "<")
              result += "&lt;";
            else if (c === ">")
              result += "&gt;";
            else
              result += c;
          }
          return result;
        }
        /**
         * Produces an XML serialization of a document fragment node.
         *
         * @param node - node to serialize
         * @param namespace - context namespace
         * @param prefixMap - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param requireWellFormed - whether to check conformance
         */
        _serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
          let markup = "";
          for (const childNode of node._children || node.childNodes) {
            markup += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
          }
          return markup;
        }
        /**
         * Produces an XML serialization of a document type node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeDocumentType(node, requireWellFormed) {
          if (requireWellFormed && !(0, algorithm_1.xml_isPubidChar)(node.publicId)) {
            throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
          }
          if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
            throw new Error("DocType system identifier contains invalid characters (well-formed required).");
          }
          return node.publicId && node.systemId ? "<!DOCTYPE " + node.name + ' PUBLIC "' + node.publicId + '" "' + node.systemId + '">' : node.publicId ? "<!DOCTYPE " + node.name + ' PUBLIC "' + node.publicId + '">' : node.systemId ? "<!DOCTYPE " + node.name + ' SYSTEM "' + node.systemId + '">' : "<!DOCTYPE " + node.name + ">";
        }
        /**
         * Produces an XML serialization of a processing instruction node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeProcessingInstruction(node, requireWellFormed) {
          if (requireWellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
            throw new Error("Processing instruction target contains invalid characters (well-formed required).");
          }
          if (requireWellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.data) || node.data.indexOf("?>") !== -1)) {
            throw new Error("Processing instruction data contains invalid characters (well-formed required).");
          }
          return "<?" + (node.data === "" ? node.target : node.target + " " + node.data) + "?>";
        }
        /**
         * Produces an XML serialization of a CDATA node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeCData(node, requireWellFormed) {
          if (requireWellFormed && node.data.indexOf("]]>") !== -1) {
            throw new Error("CDATA contains invalid characters (well-formed required).");
          }
          return "<![CDATA[" + node.data + "]]>";
        }
        /**
        * Produces an XML serialization of the attributes of an element node.
        *
         * @param node - node to serialize
         * @param map - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param localPrefixesMap - local prefixes map
         * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
         * attributes
         * @param requireWellFormed - whether to check conformance
        */
        _serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
          let result = "";
          const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : void 0;
          for (const attr of node.attributes) {
            if (!ignoreNamespaceDefinitionAttribute && !requireWellFormed && attr.namespaceURI === null) {
              result += " " + attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
              continue;
            }
            if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
              throw new Error("Element contains duplicate attributes (well-formed required).");
            }
            if (requireWellFormed && localNameSet)
              localNameSet.set(attr.namespaceURI, attr.localName);
            let attributeNamespace = attr.namespaceURI;
            let candidatePrefix = null;
            if (attributeNamespace !== null) {
              candidatePrefix = map.get(attr.prefix, attributeNamespace);
              if (attributeNamespace === infra_1.namespace.XMLNS) {
                if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value))
                  continue;
                if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                  throw new Error("XMLNS namespace is reserved (well-formed required).");
                }
                if (requireWellFormed && attr.value === "") {
                  throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                }
                if (attr.prefix === "xmlns")
                  candidatePrefix = "xmlns";
              } else if (candidatePrefix === null) {
                if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
                  candidatePrefix = attr.prefix;
                } else {
                  candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                }
                result += " xmlns:" + candidatePrefix + '="' + this._serializeAttributeValue(attributeNamespace, requireWellFormed) + '"';
              }
            }
            result += " ";
            if (candidatePrefix !== null) {
              result += candidatePrefix + ":";
            }
            if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
              throw new Error("Attribute local name contains invalid characters (well-formed required).");
            }
            result += attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
          }
          return result;
        }
        /**
        * Records namespace information for the given element and returns the
        * default namespace attribute value.
        *
        * @param node - element node to process
        * @param map - namespace prefix map
        * @param localPrefixesMap - local prefixes map
        */
        _recordNamespaceInformation(node, map, localPrefixesMap) {
          let defaultNamespaceAttrValue = null;
          for (const attr of node.attributes) {
            let attributeNamespace = attr.namespaceURI;
            let attributePrefix = attr.prefix;
            if (attributeNamespace === infra_1.namespace.XMLNS) {
              if (attributePrefix === null) {
                defaultNamespaceAttrValue = attr.value;
                continue;
              } else {
                let prefixDefinition = attr.localName;
                let namespaceDefinition = attr.value;
                if (namespaceDefinition === infra_1.namespace.XML) {
                  continue;
                }
                if (namespaceDefinition === "") {
                  namespaceDefinition = null;
                }
                if (map.has(prefixDefinition, namespaceDefinition)) {
                  continue;
                }
                map.set(prefixDefinition, namespaceDefinition);
                localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
              }
            }
          }
          return defaultNamespaceAttrValue;
        }
        /**
        * Generates a new prefix for the given namespace.
        *
        * @param newNamespace - a namespace to generate prefix for
        * @param prefixMap - namespace prefix map
        * @param prefixIndex - generated namespace prefix index
        */
        _generatePrefix(newNamespace, prefixMap, prefixIndex) {
          let generatedPrefix = "ns" + prefixIndex.value;
          prefixIndex.value++;
          prefixMap.set(generatedPrefix, newNamespace);
          return generatedPrefix;
        }
        /**
         * Produces an XML serialization of an attribute value.
         *
         * @param value - attribute value
         * @param requireWellFormed - whether to check conformance
         */
        _serializeAttributeValue(value, requireWellFormed) {
          if (requireWellFormed && value !== null && !(0, algorithm_1.xml_isLegalChar)(value)) {
            throw new Error("Invalid characters in attribute value.");
          }
          if (value === null)
            return "";
          let result = "";
          for (let i = 0; i < value.length; i++) {
            const c = value[i];
            if (c === '"')
              result += "&quot;";
            else if (c === "&")
              result += "&amp;";
            else if (c === "<")
              result += "&lt;";
            else if (c === ">")
              result += "&gt;";
            else
              result += c;
          }
          return result;
        }
        /**
         * Produces an XML serialization of an element node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeElement(node, requireWellFormed) {
          if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
          }
          let skipEndTag = false;
          const qualifiedName = node.localName;
          let markup = "<" + qualifiedName;
          markup += this._serializeAttributes(node, requireWellFormed);
          if (node._children.size === 0) {
            markup += "/";
            skipEndTag = true;
          }
          markup += ">";
          if (skipEndTag)
            return markup;
          for (const childNode of node._children) {
            markup += this._serializeNode(childNode, requireWellFormed);
          }
          markup += "</" + qualifiedName + ">";
          return markup;
        }
        /**
         * Produces an XML serialization of a document node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeDocument(node, requireWellFormed) {
          if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
          }
          let serializedDocument = "";
          for (const childNode of node._children) {
            serializedDocument += this._serializeNode(childNode, requireWellFormed);
          }
          return serializedDocument;
        }
        /**
         * Produces an XML serialization of a document fragment node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeDocumentFragment(node, requireWellFormed) {
          let markup = "";
          for (const childNode of node._children) {
            markup += this._serializeNode(childNode, requireWellFormed);
          }
          return markup;
        }
        /**
         * Produces an XML serialization of the attributes of an element node.
         *
         * @param node - node to serialize
         * @param requireWellFormed - whether to check conformance
         */
        _serializeAttributes(node, requireWellFormed) {
          let result = "";
          const localNameSet = requireWellFormed ? {} : void 0;
          for (const attr of node.attributes) {
            if (requireWellFormed && localNameSet && attr.localName in localNameSet) {
              throw new Error("Element contains duplicate attributes (well-formed required).");
            }
            if (requireWellFormed && localNameSet)
              localNameSet[attr.localName] = true;
            if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attr.localName))) {
              throw new Error("Attribute local name contains invalid characters (well-formed required).");
            }
            result += " " + attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
          }
          return result;
        }
      };
      __publicField(_XMLSerializerImpl, "_VoidElementNames", /* @__PURE__ */ new Set([
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "menuitem",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]));
      var XMLSerializerImpl = _XMLSerializerImpl;
      exports.XMLSerializerImpl = XMLSerializerImpl;
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/serializer/index.js
  var require_serializer = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/serializer/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLSerializer = void 0;
      var XMLSerializerImpl_1 = require_XMLSerializerImpl();
      Object.defineProperty(exports, "XMLSerializer", { enumerable: true, get: function() {
        return XMLSerializerImpl_1.XMLSerializerImpl;
      } });
    }
  });

  // node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/.pnpm/@oozcitak+dom@2.0.2/node_modules/@oozcitak/dom/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLSerializer = exports.DOMParser = exports.DOMImplementation = void 0;
      var dom_1 = require_dom();
      dom_1.dom.setFeatures(true);
      var dom_2 = require_dom();
      Object.defineProperty(exports, "DOMImplementation", { enumerable: true, get: function() {
        return dom_2.DOMImplementation;
      } });
      var parser_1 = require_parser();
      Object.defineProperty(exports, "DOMParser", { enumerable: true, get: function() {
        return parser_1.DOMParser;
      } });
      var serializer_1 = require_serializer();
      Object.defineProperty(exports, "XMLSerializer", { enumerable: true, get: function() {
        return serializer_1.XMLSerializer;
      } });
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/dom.js
  var require_dom2 = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/dom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createDocument = createDocument;
      exports.sanitizeInput = sanitizeInput;
      var dom_1 = require_lib6();
      var dom_2 = require_dom();
      var util_1 = require_lib4();
      dom_2.dom.setFeatures(false);
      function createDocument() {
        const impl = new dom_1.DOMImplementation();
        const doc = impl.createDocument(null, "root", null);
        if (doc.documentElement) {
          doc.removeChild(doc.documentElement);
        }
        return doc;
      }
      function sanitizeInput(str, replacement) {
        if (str == null) {
          return str;
        } else if (replacement === void 0) {
          return str + "";
        } else {
          let result = "";
          str = str + "";
          for (let i = 0; i < str.length; i++) {
            let n = str.charCodeAt(i);
            if (n === 9 || n === 10 || n === 13 || n >= 32 && n <= 55295 || n >= 57344 && n <= 65533) {
              result += str.charAt(i);
            } else if (n >= 55296 && n <= 56319 && i < str.length - 1) {
              const n2 = str.charCodeAt(i + 1);
              if (n2 >= 56320 && n2 <= 57343) {
                n = (n - 55296) * 1024 + n2 - 56320 + 65536;
                result += String.fromCodePoint(n);
                i++;
              } else {
                result += (0, util_1.isString)(replacement) ? replacement : replacement(str.charAt(i), i, str);
              }
            } else {
              result += (0, util_1.isString)(replacement) ? replacement : replacement(str.charAt(i), i, str);
            }
          }
          return result;
        }
      }
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/BaseReader.js
  var require_BaseReader = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/BaseReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseReader = void 0;
      var dom_1 = require_dom2();
      var _BaseReader = class _BaseReader {
        /**
         * Initializes a new instance of `BaseReader`.
         *
         * @param builderOptions - XML builder options
         */
        constructor(builderOptions) {
          __publicField(this, "_builderOptions");
          this._builderOptions = builderOptions;
          if (builderOptions.parser) {
            Object.assign(this, builderOptions.parser);
          }
        }
        _docType(parent, name, publicId, systemId) {
          return parent.dtd({ name, pubID: publicId, sysID: systemId });
        }
        _comment(parent, data) {
          return parent.com(data);
        }
        _text(parent, data) {
          return parent.txt(data);
        }
        _instruction(parent, target, data) {
          return parent.ins(target, data);
        }
        _cdata(parent, data) {
          return parent.dat(data);
        }
        _element(parent, namespace, name) {
          return namespace === void 0 ? parent.ele(name) : parent.ele(namespace, name);
        }
        _attribute(parent, namespace, name, value) {
          return namespace === void 0 ? parent.att(name, value) : parent.att(namespace, name, value);
        }
        _sanitize(str) {
          return (0, dom_1.sanitizeInput)(str, this._builderOptions.invalidCharReplacement);
        }
        /**
         * Decodes serialized text.
         *
         * @param text - text value to serialize
         */
        _decodeText(text) {
          if (text == null)
            return text;
          return text.replace(/&(quot|amp|apos|lt|gt);/g, (_match, tag) => _BaseReader._entityTable[tag]).replace(/&#(?:x([a-fA-F0-9]+)|([0-9]+));/g, (_match, hexStr, numStr) => String.fromCodePoint(parseInt(hexStr || numStr, hexStr ? 16 : 10)));
        }
        /**
         * Decodes serialized attribute value.
         *
         * @param text - attribute value to serialize
         */
        _decodeAttributeValue(text) {
          return this._decodeText(text);
        }
        /**
         * Main parser function which parses the given object and returns an XMLBuilder.
         *
         * @param node - node to recieve parsed content
         * @param obj - object to parse
         */
        parse(node, obj) {
          return this._parse(node, obj);
        }
        /**
         * Creates a DocType node.
         * The node will be skipped if the function returns `undefined`.
         *
         * @param name - node name
         * @param publicId - public identifier
         * @param systemId - system identifier
         */
        docType(parent, name, publicId, systemId) {
          return this._docType(parent, name, publicId, systemId);
        }
        /**
         * Creates a comment node.
         * The node will be skipped if the function returns `undefined`.
         *
         * @param parent - parent node
         * @param data - node data
         */
        comment(parent, data) {
          return this._comment(parent, data);
        }
        /**
         * Creates a text node.
         * The node will be skipped if the function returns `undefined`.
         *
         * @param parent - parent node
         * @param data - node data
         */
        text(parent, data) {
          return this._text(parent, data);
        }
        /**
         * Creates a processing instruction node.
         * The node will be skipped if the function returns `undefined`.
         *
         * @param parent - parent node
         * @param target - instruction target
         * @param data - node data
         */
        instruction(parent, target, data) {
          return this._instruction(parent, target, data);
        }
        /**
         * Creates a CData section node.
         * The node will be skipped if the function returns `undefined`.
         *
         * @param parent - parent node
         * @param data - node data
         */
        cdata(parent, data) {
          return this._cdata(parent, data);
        }
        /**
         * Creates an element node.
         * The node will be skipped if the function returns `undefined`.
         *
         * @param parent - parent node
         * @param namespace - node namespace
         * @param name - node name
         */
        element(parent, namespace, name) {
          return this._element(parent, namespace, name);
        }
        /**
         * Creates an attribute or namespace declaration.
         * The node will be skipped if the function returns `undefined`.
         *
         * @param parent - parent node
         * @param namespace - node namespace
         * @param name - node name
         * @param value - node value
         */
        attribute(parent, namespace, name, value) {
          return this._attribute(parent, namespace, name, value);
        }
        /**
         * Sanitizes input strings.
         *
         * @param str - input string
         */
        sanitize(str) {
          return this._sanitize(str);
        }
      };
      __publicField(_BaseReader, "_entityTable", {
        "lt": "<",
        "gt": ">",
        "amp": "&",
        "quot": '"',
        "apos": "'"
      });
      var BaseReader = _BaseReader;
      exports.BaseReader = BaseReader;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/XMLReader.js
  var require_XMLReader = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/XMLReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLReader = void 0;
      var XMLStringLexer_1 = require_XMLStringLexer();
      var interfaces_1 = require_interfaces4();
      var interfaces_2 = require_interfaces2();
      var infra_1 = require_lib5();
      var algorithm_1 = require_algorithm();
      var BaseReader_1 = require_BaseReader();
      var XMLReader = class extends BaseReader_1.BaseReader {
        /**
         * Parses the given document representation.
         *
         * @param node - node receive parsed XML nodes
         * @param str - XML document string to parse
         */
        _parse(node, str) {
          const lexer = new XMLStringLexer_1.XMLStringLexer(str, { skipWhitespaceOnlyText: this._builderOptions.skipWhitespaceOnlyText });
          let lastChild = node;
          let context = node;
          let token = lexer.nextToken();
          while (token.type !== interfaces_1.TokenType.EOF) {
            switch (token.type) {
              case interfaces_1.TokenType.Declaration:
                const declaration = token;
                const version = this.sanitize(declaration.version);
                if (version !== "1.0") {
                  throw new Error("Invalid xml version: " + version);
                }
                const builderOptions = {
                  version
                };
                if (declaration.encoding) {
                  builderOptions.encoding = this.sanitize(declaration.encoding);
                }
                if (declaration.standalone) {
                  builderOptions.standalone = this.sanitize(declaration.standalone) === "yes";
                }
                context.set(builderOptions);
                break;
              case interfaces_1.TokenType.DocType:
                const doctype = token;
                context = this.docType(context, this.sanitize(doctype.name), this.sanitize(doctype.pubId), this.sanitize(doctype.sysId)) || context;
                break;
              case interfaces_1.TokenType.CDATA:
                const cdata = token;
                context = this.cdata(context, this.sanitize(cdata.data)) || context;
                break;
              case interfaces_1.TokenType.Comment:
                const comment = token;
                context = this.comment(context, this.sanitize(comment.data)) || context;
                break;
              case interfaces_1.TokenType.PI:
                const pi = token;
                context = this.instruction(context, this.sanitize(pi.target), this.sanitize(pi.data)) || context;
                break;
              case interfaces_1.TokenType.Text:
                if (context.node.nodeType === interfaces_2.NodeType.Document)
                  break;
                const text = token;
                context = this.text(context, this._decodeText(this.sanitize(text.data))) || context;
                break;
              case interfaces_1.TokenType.Element:
                const element = token;
                const elementName = this.sanitize(element.name);
                const [prefix] = (0, algorithm_1.namespace_extractQName)(elementName);
                let namespace = context.node.lookupNamespaceURI(prefix);
                const nsDeclarations = {};
                for (let [attName, attValue] of element.attributes) {
                  attName = this.sanitize(attName);
                  attValue = this.sanitize(attValue);
                  if (attName === "xmlns") {
                    namespace = attValue;
                  } else {
                    const [attPrefix, attLocalName] = (0, algorithm_1.namespace_extractQName)(attName);
                    if (attPrefix === "xmlns") {
                      if (attLocalName === prefix) {
                        namespace = attValue;
                      }
                      nsDeclarations[attLocalName] = attValue;
                    }
                  }
                }
                const elementNode = namespace !== null ? this.element(context, namespace, elementName) : this.element(context, void 0, elementName);
                if (elementNode === void 0)
                  break;
                if (context.node === node.node)
                  lastChild = elementNode;
                for (let [attName, attValue] of element.attributes) {
                  attName = this.sanitize(attName);
                  attValue = this.sanitize(attValue);
                  const [attPrefix, attLocalName] = (0, algorithm_1.namespace_extractQName)(attName);
                  let attNamespace = null;
                  if (attPrefix === "xmlns" || attPrefix === null && attLocalName === "xmlns") {
                    attNamespace = infra_1.namespace.XMLNS;
                  } else {
                    attNamespace = elementNode.node.lookupNamespaceURI(attPrefix);
                    if (attNamespace !== null && elementNode.node.isDefaultNamespace(attNamespace)) {
                      attNamespace = null;
                    } else if (attNamespace === null && attPrefix !== null) {
                      attNamespace = nsDeclarations[attPrefix] || null;
                    }
                  }
                  if (attNamespace !== null)
                    this.attribute(elementNode, attNamespace, attName, this._decodeAttributeValue(attValue));
                  else
                    this.attribute(elementNode, void 0, attName, this._decodeAttributeValue(attValue));
                }
                if (!element.selfClosing) {
                  context = elementNode;
                }
                break;
              case interfaces_1.TokenType.ClosingTag:
                if (context.node.parentNode) {
                  context = context.up();
                }
                break;
            }
            token = lexer.nextToken();
          }
          return lastChild;
        }
      };
      exports.XMLReader = XMLReader;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/ObjectReader.js
  var require_ObjectReader = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/ObjectReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ObjectReader = void 0;
      var util_1 = require_lib4();
      var BaseReader_1 = require_BaseReader();
      var ObjectReader = class extends BaseReader_1.BaseReader {
        /**
         * Parses the given document representation.
         *
         * @param node - node receive parsed XML nodes
         * @param obj - object to parse
         */
        _parse(node, obj) {
          const options = this._builderOptions;
          let lastChild = null;
          if ((0, util_1.isFunction)(obj)) {
            lastChild = this.parse(node, obj.call(this));
          } else if ((0, util_1.isArray)(obj) || (0, util_1.isSet)(obj)) {
            (0, util_1.forEachArray)(obj, (item) => lastChild = this.parse(node, item), this);
          } else if ((0, util_1.isMap)(obj) || (0, util_1.isObject)(obj)) {
            (0, util_1.forEachObject)(obj, (key, val) => {
              if ((0, util_1.isFunction)(val)) {
                val = val.call(this);
              }
              if (!options.ignoreConverters && key.indexOf(options.convert.att) === 0) {
                if (key === options.convert.att) {
                  if ((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) {
                    throw new Error("Invalid attribute: " + val.toString() + ". " + node._debugInfo());
                  } else {
                    (0, util_1.forEachObject)(val, (attrKey, attrVal) => {
                      lastChild = this.attribute(node, void 0, this.sanitize(attrKey), this._decodeAttributeValue(this.sanitize(attrVal))) || lastChild;
                    });
                  }
                } else {
                  lastChild = this.attribute(node, void 0, this.sanitize(key.substring(options.convert.att.length)), this._decodeAttributeValue(this.sanitize(val == null ? void 0 : val.toString()))) || lastChild;
                }
              } else if (!options.ignoreConverters && key.indexOf(options.convert.text) === 0) {
                if ((0, util_1.isMap)(val) || (0, util_1.isObject)(val)) {
                  lastChild = this.parse(node, val);
                } else {
                  lastChild = this.text(node, this._decodeText(this.sanitize(val == null ? void 0 : val.toString()))) || lastChild;
                }
              } else if (!options.ignoreConverters && key.indexOf(options.convert.cdata) === 0) {
                if ((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) {
                  (0, util_1.forEachArray)(val, (item) => lastChild = this.cdata(node, this.sanitize(item)) || lastChild, this);
                } else {
                  lastChild = this.cdata(node, this.sanitize(val == null ? void 0 : val.toString())) || lastChild;
                }
              } else if (!options.ignoreConverters && key.indexOf(options.convert.comment) === 0) {
                if ((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) {
                  (0, util_1.forEachArray)(val, (item) => lastChild = this.comment(node, this.sanitize(item)) || lastChild, this);
                } else {
                  lastChild = this.comment(node, this.sanitize(val == null ? void 0 : val.toString())) || lastChild;
                }
              } else if (!options.ignoreConverters && key.indexOf(options.convert.ins) === 0) {
                if ((0, util_1.isString)(val)) {
                  const insIndex = val.indexOf(" ");
                  const insTarget = insIndex === -1 ? val : val.substr(0, insIndex);
                  const insValue = insIndex === -1 ? "" : val.substr(insIndex + 1);
                  lastChild = this.instruction(node, this.sanitize(insTarget), this.sanitize(insValue)) || lastChild;
                } else if ((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) {
                  (0, util_1.forEachArray)(val, (item) => {
                    const insIndex = item.indexOf(" ");
                    const insTarget = insIndex === -1 ? item : item.substr(0, insIndex);
                    const insValue = insIndex === -1 ? "" : item.substr(insIndex + 1);
                    lastChild = this.instruction(node, this.sanitize(insTarget), this.sanitize(insValue)) || lastChild;
                  }, this);
                } else {
                  (0, util_1.forEachObject)(val, (insTarget, insValue) => lastChild = this.instruction(node, this.sanitize(insTarget), this.sanitize(insValue)) || lastChild, this);
                }
              } else if (((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) && (0, util_1.isEmpty)(val)) {
              } else if (((0, util_1.isMap)(val) || (0, util_1.isObject)(val)) && (0, util_1.isEmpty)(val)) {
                lastChild = this.element(node, void 0, this.sanitize(key)) || lastChild;
              } else if (!options.keepNullNodes && val == null) {
              } else if ((0, util_1.isArray)(val) || (0, util_1.isSet)(val)) {
                (0, util_1.forEachArray)(val, (item) => {
                  const childNode = {};
                  childNode[key] = item;
                  lastChild = this.parse(node, childNode);
                }, this);
              } else if ((0, util_1.isMap)(val) || (0, util_1.isObject)(val)) {
                const parent = this.element(node, void 0, this.sanitize(key));
                if (parent) {
                  lastChild = parent;
                  this.parse(parent, val);
                }
              } else if (val != null && (!(0, util_1.isString)(val) || val !== "")) {
                const parent = this.element(node, void 0, this.sanitize(key));
                if (parent) {
                  lastChild = parent;
                  this.text(parent, this._decodeText(this.sanitize(val == null ? void 0 : val.toString())));
                }
              } else {
                lastChild = this.element(node, void 0, this.sanitize(key)) || lastChild;
              }
            }, this);
          } else if (!options.keepNullNodes && obj == null) {
          } else {
            lastChild = this.text(node, this._decodeText(this.sanitize(obj == null ? void 0 : obj.toString()))) || lastChild;
          }
          return lastChild || node;
        }
      };
      exports.ObjectReader = ObjectReader;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/JSONReader.js
  var require_JSONReader = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/JSONReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JSONReader = void 0;
      var ObjectReader_1 = require_ObjectReader();
      var BaseReader_1 = require_BaseReader();
      var JSONReader = class extends BaseReader_1.BaseReader {
        /**
         * Parses the given document representation.
         *
         * @param node - node receive parsed XML nodes
         * @param str - JSON string to parse
         */
        _parse(node, str) {
          return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, JSON.parse(str));
        }
      };
      exports.JSONReader = JSONReader;
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/common.js
  var require_common2 = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/common.js"(exports, module) {
      "use strict";
      function isNothing(subject) {
        return typeof subject === "undefined" || subject === null;
      }
      function isObject(subject) {
        return typeof subject === "object" && subject !== null;
      }
      function toArray(sequence) {
        if (Array.isArray(sequence)) return sequence;
        else if (isNothing(sequence)) return [];
        return [sequence];
      }
      function extend(target, source) {
        var index, length, key, sourceKeys;
        if (source) {
          sourceKeys = Object.keys(source);
          for (index = 0, length = sourceKeys.length; index < length; index += 1) {
            key = sourceKeys[index];
            target[key] = source[key];
          }
        }
        return target;
      }
      function repeat(string, count) {
        var result = "", cycle;
        for (cycle = 0; cycle < count; cycle += 1) {
          result += string;
        }
        return result;
      }
      function isNegativeZero(number) {
        return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
      }
      module.exports.isNothing = isNothing;
      module.exports.isObject = isObject;
      module.exports.toArray = toArray;
      module.exports.repeat = repeat;
      module.exports.isNegativeZero = isNegativeZero;
      module.exports.extend = extend;
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/exception.js
  var require_exception = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/exception.js"(exports, module) {
      "use strict";
      function formatError(exception, compact) {
        var where = "", message = exception.reason || "(unknown reason)";
        if (!exception.mark) return message;
        if (exception.mark.name) {
          where += 'in "' + exception.mark.name + '" ';
        }
        where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
        if (!compact && exception.mark.snippet) {
          where += "\n\n" + exception.mark.snippet;
        }
        return message + " " + where;
      }
      function YAMLException(reason, mark) {
        Error.call(this);
        this.name = "YAMLException";
        this.reason = reason;
        this.mark = mark;
        this.message = formatError(this, false);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error().stack || "";
        }
      }
      YAMLException.prototype = Object.create(Error.prototype);
      YAMLException.prototype.constructor = YAMLException;
      YAMLException.prototype.toString = function toString(compact) {
        return this.name + ": " + formatError(this, compact);
      };
      module.exports = YAMLException;
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/snippet.js
  var require_snippet = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/snippet.js"(exports, module) {
      "use strict";
      var common = require_common2();
      function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
        var head = "";
        var tail = "";
        var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
        if (position - lineStart > maxHalfLength) {
          head = " ... ";
          lineStart = position - maxHalfLength + head.length;
        }
        if (lineEnd - position > maxHalfLength) {
          tail = " ...";
          lineEnd = position + maxHalfLength - tail.length;
        }
        return {
          str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
          pos: position - lineStart + head.length
          // relative position
        };
      }
      function padStart(string, max) {
        return common.repeat(" ", max - string.length) + string;
      }
      function makeSnippet(mark, options) {
        options = Object.create(options || null);
        if (!mark.buffer) return null;
        if (!options.maxLength) options.maxLength = 79;
        if (typeof options.indent !== "number") options.indent = 1;
        if (typeof options.linesBefore !== "number") options.linesBefore = 3;
        if (typeof options.linesAfter !== "number") options.linesAfter = 2;
        var re = /\r?\n|\r|\0/g;
        var lineStarts = [0];
        var lineEnds = [];
        var match;
        var foundLineNo = -1;
        while (match = re.exec(mark.buffer)) {
          lineEnds.push(match.index);
          lineStarts.push(match.index + match[0].length);
          if (mark.position <= match.index && foundLineNo < 0) {
            foundLineNo = lineStarts.length - 2;
          }
        }
        if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
        var result = "", i, line;
        var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
        var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
        for (i = 1; i <= options.linesBefore; i++) {
          if (foundLineNo - i < 0) break;
          line = getLine(
            mark.buffer,
            lineStarts[foundLineNo - i],
            lineEnds[foundLineNo - i],
            mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
            maxLineLength
          );
          result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
        }
        line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
        result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
        result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
        for (i = 1; i <= options.linesAfter; i++) {
          if (foundLineNo + i >= lineEnds.length) break;
          line = getLine(
            mark.buffer,
            lineStarts[foundLineNo + i],
            lineEnds[foundLineNo + i],
            mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
            maxLineLength
          );
          result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
        }
        return result.replace(/\n$/, "");
      }
      module.exports = makeSnippet;
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type.js
  var require_type = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type.js"(exports, module) {
      "use strict";
      var YAMLException = require_exception();
      var TYPE_CONSTRUCTOR_OPTIONS = [
        "kind",
        "multi",
        "resolve",
        "construct",
        "instanceOf",
        "predicate",
        "represent",
        "representName",
        "defaultStyle",
        "styleAliases"
      ];
      var YAML_NODE_KINDS = [
        "scalar",
        "sequence",
        "mapping"
      ];
      function compileStyleAliases(map) {
        var result = {};
        if (map !== null) {
          Object.keys(map).forEach(function(style) {
            map[style].forEach(function(alias) {
              result[String(alias)] = style;
            });
          });
        }
        return result;
      }
      function Type(tag, options) {
        options = options || {};
        Object.keys(options).forEach(function(name) {
          if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
          }
        });
        this.options = options;
        this.tag = tag;
        this.kind = options["kind"] || null;
        this.resolve = options["resolve"] || function() {
          return true;
        };
        this.construct = options["construct"] || function(data) {
          return data;
        };
        this.instanceOf = options["instanceOf"] || null;
        this.predicate = options["predicate"] || null;
        this.represent = options["represent"] || null;
        this.representName = options["representName"] || null;
        this.defaultStyle = options["defaultStyle"] || null;
        this.multi = options["multi"] || false;
        this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
        if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
          throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
        }
      }
      module.exports = Type;
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/schema.js
  var require_schema = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/schema.js"(exports, module) {
      "use strict";
      var YAMLException = require_exception();
      var Type = require_type();
      function compileList(schema, name) {
        var result = [];
        schema[name].forEach(function(currentType) {
          var newIndex = result.length;
          result.forEach(function(previousType, previousIndex) {
            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
              newIndex = previousIndex;
            }
          });
          result[newIndex] = currentType;
        });
        return result;
      }
      function compileMap() {
        var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {},
          multi: {
            scalar: [],
            sequence: [],
            mapping: [],
            fallback: []
          }
        }, index, length;
        function collectType(type) {
          if (type.multi) {
            result.multi[type.kind].push(type);
            result.multi["fallback"].push(type);
          } else {
            result[type.kind][type.tag] = result["fallback"][type.tag] = type;
          }
        }
        for (index = 0, length = arguments.length; index < length; index += 1) {
          arguments[index].forEach(collectType);
        }
        return result;
      }
      function Schema(definition) {
        return this.extend(definition);
      }
      Schema.prototype.extend = function extend(definition) {
        var implicit = [];
        var explicit = [];
        if (definition instanceof Type) {
          explicit.push(definition);
        } else if (Array.isArray(definition)) {
          explicit = explicit.concat(definition);
        } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
          if (definition.implicit) implicit = implicit.concat(definition.implicit);
          if (definition.explicit) explicit = explicit.concat(definition.explicit);
        } else {
          throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
        }
        implicit.forEach(function(type) {
          if (!(type instanceof Type)) {
            throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
          }
          if (type.loadKind && type.loadKind !== "scalar") {
            throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
          }
          if (type.multi) {
            throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
          }
        });
        explicit.forEach(function(type) {
          if (!(type instanceof Type)) {
            throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
          }
        });
        var result = Object.create(Schema.prototype);
        result.implicit = (this.implicit || []).concat(implicit);
        result.explicit = (this.explicit || []).concat(explicit);
        result.compiledImplicit = compileList(result, "implicit");
        result.compiledExplicit = compileList(result, "explicit");
        result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
        return result;
      };
      module.exports = Schema;
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/str.js
  var require_str = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/str.js"(exports, module) {
      "use strict";
      var Type = require_type();
      module.exports = new Type("tag:yaml.org,2002:str", {
        kind: "scalar",
        construct: function(data) {
          return data !== null ? data : "";
        }
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/seq.js
  var require_seq = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/seq.js"(exports, module) {
      "use strict";
      var Type = require_type();
      module.exports = new Type("tag:yaml.org,2002:seq", {
        kind: "sequence",
        construct: function(data) {
          return data !== null ? data : [];
        }
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/map.js
  var require_map = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/map.js"(exports, module) {
      "use strict";
      var Type = require_type();
      module.exports = new Type("tag:yaml.org,2002:map", {
        kind: "mapping",
        construct: function(data) {
          return data !== null ? data : {};
        }
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/schema/failsafe.js
  var require_failsafe = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/schema/failsafe.js"(exports, module) {
      "use strict";
      var Schema = require_schema();
      module.exports = new Schema({
        explicit: [
          require_str(),
          require_seq(),
          require_map()
        ]
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/null.js
  var require_null = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/null.js"(exports, module) {
      "use strict";
      var Type = require_type();
      function resolveYamlNull(data) {
        if (data === null) return true;
        var max = data.length;
        return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
      }
      function constructYamlNull() {
        return null;
      }
      function isNull(object) {
        return object === null;
      }
      module.exports = new Type("tag:yaml.org,2002:null", {
        kind: "scalar",
        resolve: resolveYamlNull,
        construct: constructYamlNull,
        predicate: isNull,
        represent: {
          canonical: function() {
            return "~";
          },
          lowercase: function() {
            return "null";
          },
          uppercase: function() {
            return "NULL";
          },
          camelcase: function() {
            return "Null";
          },
          empty: function() {
            return "";
          }
        },
        defaultStyle: "lowercase"
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/bool.js
  var require_bool = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/bool.js"(exports, module) {
      "use strict";
      var Type = require_type();
      function resolveYamlBoolean(data) {
        if (data === null) return false;
        var max = data.length;
        return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
      }
      function constructYamlBoolean(data) {
        return data === "true" || data === "True" || data === "TRUE";
      }
      function isBoolean(object) {
        return Object.prototype.toString.call(object) === "[object Boolean]";
      }
      module.exports = new Type("tag:yaml.org,2002:bool", {
        kind: "scalar",
        resolve: resolveYamlBoolean,
        construct: constructYamlBoolean,
        predicate: isBoolean,
        represent: {
          lowercase: function(object) {
            return object ? "true" : "false";
          },
          uppercase: function(object) {
            return object ? "TRUE" : "FALSE";
          },
          camelcase: function(object) {
            return object ? "True" : "False";
          }
        },
        defaultStyle: "lowercase"
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/int.js
  var require_int = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/int.js"(exports, module) {
      "use strict";
      var common = require_common2();
      var Type = require_type();
      function isHexCode(c) {
        return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
      }
      function isOctCode(c) {
        return 48 <= c && c <= 55;
      }
      function isDecCode(c) {
        return 48 <= c && c <= 57;
      }
      function resolveYamlInteger(data) {
        if (data === null) return false;
        var max = data.length, index = 0, hasDigits = false, ch;
        if (!max) return false;
        ch = data[index];
        if (ch === "-" || ch === "+") {
          ch = data[++index];
        }
        if (ch === "0") {
          if (index + 1 === max) return true;
          ch = data[++index];
          if (ch === "b") {
            index++;
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_") continue;
              if (ch !== "0" && ch !== "1") return false;
              hasDigits = true;
            }
            return hasDigits && ch !== "_";
          }
          if (ch === "x") {
            index++;
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_") continue;
              if (!isHexCode(data.charCodeAt(index))) return false;
              hasDigits = true;
            }
            return hasDigits && ch !== "_";
          }
          if (ch === "o") {
            index++;
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_") continue;
              if (!isOctCode(data.charCodeAt(index))) return false;
              hasDigits = true;
            }
            return hasDigits && ch !== "_";
          }
        }
        if (ch === "_") return false;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isDecCode(data.charCodeAt(index))) {
            return false;
          }
          hasDigits = true;
        }
        if (!hasDigits || ch === "_") return false;
        return true;
      }
      function constructYamlInteger(data) {
        var value = data, sign = 1, ch;
        if (value.indexOf("_") !== -1) {
          value = value.replace(/_/g, "");
        }
        ch = value[0];
        if (ch === "-" || ch === "+") {
          if (ch === "-") sign = -1;
          value = value.slice(1);
          ch = value[0];
        }
        if (value === "0") return 0;
        if (ch === "0") {
          if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
          if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
          if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
        }
        return sign * parseInt(value, 10);
      }
      function isInteger(object) {
        return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
      }
      module.exports = new Type("tag:yaml.org,2002:int", {
        kind: "scalar",
        resolve: resolveYamlInteger,
        construct: constructYamlInteger,
        predicate: isInteger,
        represent: {
          binary: function(obj) {
            return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
          },
          octal: function(obj) {
            return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
          },
          decimal: function(obj) {
            return obj.toString(10);
          },
          /* eslint-disable max-len */
          hexadecimal: function(obj) {
            return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
          }
        },
        defaultStyle: "decimal",
        styleAliases: {
          binary: [2, "bin"],
          octal: [8, "oct"],
          decimal: [10, "dec"],
          hexadecimal: [16, "hex"]
        }
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/float.js
  var require_float = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/float.js"(exports, module) {
      "use strict";
      var common = require_common2();
      var Type = require_type();
      var YAML_FLOAT_PATTERN = new RegExp(
        // 2.5e4, 2.5 and integers
        "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
      );
      function resolveYamlFloat(data) {
        if (data === null) return false;
        if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
        // Probably should update regexp & check speed
        data[data.length - 1] === "_") {
          return false;
        }
        return true;
      }
      function constructYamlFloat(data) {
        var value, sign;
        value = data.replace(/_/g, "").toLowerCase();
        sign = value[0] === "-" ? -1 : 1;
        if ("+-".indexOf(value[0]) >= 0) {
          value = value.slice(1);
        }
        if (value === ".inf") {
          return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
        } else if (value === ".nan") {
          return NaN;
        }
        return sign * parseFloat(value, 10);
      }
      var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
      function representYamlFloat(object, style) {
        var res;
        if (isNaN(object)) {
          switch (style) {
            case "lowercase":
              return ".nan";
            case "uppercase":
              return ".NAN";
            case "camelcase":
              return ".NaN";
          }
        } else if (Number.POSITIVE_INFINITY === object) {
          switch (style) {
            case "lowercase":
              return ".inf";
            case "uppercase":
              return ".INF";
            case "camelcase":
              return ".Inf";
          }
        } else if (Number.NEGATIVE_INFINITY === object) {
          switch (style) {
            case "lowercase":
              return "-.inf";
            case "uppercase":
              return "-.INF";
            case "camelcase":
              return "-.Inf";
          }
        } else if (common.isNegativeZero(object)) {
          return "-0.0";
        }
        res = object.toString(10);
        return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
      }
      function isFloat(object) {
        return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
      }
      module.exports = new Type("tag:yaml.org,2002:float", {
        kind: "scalar",
        resolve: resolveYamlFloat,
        construct: constructYamlFloat,
        predicate: isFloat,
        represent: representYamlFloat,
        defaultStyle: "lowercase"
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/schema/json.js
  var require_json = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/schema/json.js"(exports, module) {
      "use strict";
      module.exports = require_failsafe().extend({
        implicit: [
          require_null(),
          require_bool(),
          require_int(),
          require_float()
        ]
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/schema/core.js
  var require_core = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/schema/core.js"(exports, module) {
      "use strict";
      module.exports = require_json();
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/timestamp.js
  var require_timestamp = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/timestamp.js"(exports, module) {
      "use strict";
      var Type = require_type();
      var YAML_DATE_REGEXP = new RegExp(
        "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
      );
      var YAML_TIMESTAMP_REGEXP = new RegExp(
        "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
      );
      function resolveYamlTimestamp(data) {
        if (data === null) return false;
        if (YAML_DATE_REGEXP.exec(data) !== null) return true;
        if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
        return false;
      }
      function constructYamlTimestamp(data) {
        var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
        match = YAML_DATE_REGEXP.exec(data);
        if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
        if (match === null) throw new Error("Date resolve error");
        year = +match[1];
        month = +match[2] - 1;
        day = +match[3];
        if (!match[4]) {
          return new Date(Date.UTC(year, month, day));
        }
        hour = +match[4];
        minute = +match[5];
        second = +match[6];
        if (match[7]) {
          fraction = match[7].slice(0, 3);
          while (fraction.length < 3) {
            fraction += "0";
          }
          fraction = +fraction;
        }
        if (match[9]) {
          tz_hour = +match[10];
          tz_minute = +(match[11] || 0);
          delta = (tz_hour * 60 + tz_minute) * 6e4;
          if (match[9] === "-") delta = -delta;
        }
        date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
        if (delta) date.setTime(date.getTime() - delta);
        return date;
      }
      function representYamlTimestamp(object) {
        return object.toISOString();
      }
      module.exports = new Type("tag:yaml.org,2002:timestamp", {
        kind: "scalar",
        resolve: resolveYamlTimestamp,
        construct: constructYamlTimestamp,
        instanceOf: Date,
        represent: representYamlTimestamp
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/merge.js
  var require_merge = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/merge.js"(exports, module) {
      "use strict";
      var Type = require_type();
      function resolveYamlMerge(data) {
        return data === "<<" || data === null;
      }
      module.exports = new Type("tag:yaml.org,2002:merge", {
        kind: "scalar",
        resolve: resolveYamlMerge
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/binary.js
  var require_binary = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/binary.js"(exports, module) {
      "use strict";
      var Type = require_type();
      var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
      function resolveYamlBinary(data) {
        if (data === null) return false;
        var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
        for (idx = 0; idx < max; idx++) {
          code = map.indexOf(data.charAt(idx));
          if (code > 64) continue;
          if (code < 0) return false;
          bitlen += 6;
        }
        return bitlen % 8 === 0;
      }
      function constructYamlBinary(data) {
        var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
        for (idx = 0; idx < max; idx++) {
          if (idx % 4 === 0 && idx) {
            result.push(bits >> 16 & 255);
            result.push(bits >> 8 & 255);
            result.push(bits & 255);
          }
          bits = bits << 6 | map.indexOf(input.charAt(idx));
        }
        tailbits = max % 4 * 6;
        if (tailbits === 0) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        } else if (tailbits === 18) {
          result.push(bits >> 10 & 255);
          result.push(bits >> 2 & 255);
        } else if (tailbits === 12) {
          result.push(bits >> 4 & 255);
        }
        return new Uint8Array(result);
      }
      function representYamlBinary(object) {
        var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
        for (idx = 0; idx < max; idx++) {
          if (idx % 3 === 0 && idx) {
            result += map[bits >> 18 & 63];
            result += map[bits >> 12 & 63];
            result += map[bits >> 6 & 63];
            result += map[bits & 63];
          }
          bits = (bits << 8) + object[idx];
        }
        tail = max % 3;
        if (tail === 0) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        } else if (tail === 2) {
          result += map[bits >> 10 & 63];
          result += map[bits >> 4 & 63];
          result += map[bits << 2 & 63];
          result += map[64];
        } else if (tail === 1) {
          result += map[bits >> 2 & 63];
          result += map[bits << 4 & 63];
          result += map[64];
          result += map[64];
        }
        return result;
      }
      function isBinary(obj) {
        return Object.prototype.toString.call(obj) === "[object Uint8Array]";
      }
      module.exports = new Type("tag:yaml.org,2002:binary", {
        kind: "scalar",
        resolve: resolveYamlBinary,
        construct: constructYamlBinary,
        predicate: isBinary,
        represent: representYamlBinary
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/omap.js
  var require_omap = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/omap.js"(exports, module) {
      "use strict";
      var Type = require_type();
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      var _toString = Object.prototype.toString;
      function resolveYamlOmap(data) {
        if (data === null) return true;
        var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index];
          pairHasKey = false;
          if (_toString.call(pair) !== "[object Object]") return false;
          for (pairKey in pair) {
            if (_hasOwnProperty.call(pair, pairKey)) {
              if (!pairHasKey) pairHasKey = true;
              else return false;
            }
          }
          if (!pairHasKey) return false;
          if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
          else return false;
        }
        return true;
      }
      function constructYamlOmap(data) {
        return data !== null ? data : [];
      }
      module.exports = new Type("tag:yaml.org,2002:omap", {
        kind: "sequence",
        resolve: resolveYamlOmap,
        construct: constructYamlOmap
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/pairs.js
  var require_pairs = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/pairs.js"(exports, module) {
      "use strict";
      var Type = require_type();
      var _toString = Object.prototype.toString;
      function resolveYamlPairs(data) {
        if (data === null) return true;
        var index, length, pair, keys, result, object = data;
        result = new Array(object.length);
        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index];
          if (_toString.call(pair) !== "[object Object]") return false;
          keys = Object.keys(pair);
          if (keys.length !== 1) return false;
          result[index] = [keys[0], pair[keys[0]]];
        }
        return true;
      }
      function constructYamlPairs(data) {
        if (data === null) return [];
        var index, length, pair, keys, result, object = data;
        result = new Array(object.length);
        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index];
          keys = Object.keys(pair);
          result[index] = [keys[0], pair[keys[0]]];
        }
        return result;
      }
      module.exports = new Type("tag:yaml.org,2002:pairs", {
        kind: "sequence",
        resolve: resolveYamlPairs,
        construct: constructYamlPairs
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/set.js
  var require_set = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/type/set.js"(exports, module) {
      "use strict";
      var Type = require_type();
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      function resolveYamlSet(data) {
        if (data === null) return true;
        var key, object = data;
        for (key in object) {
          if (_hasOwnProperty.call(object, key)) {
            if (object[key] !== null) return false;
          }
        }
        return true;
      }
      function constructYamlSet(data) {
        return data !== null ? data : {};
      }
      module.exports = new Type("tag:yaml.org,2002:set", {
        kind: "mapping",
        resolve: resolveYamlSet,
        construct: constructYamlSet
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/schema/default.js
  var require_default = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/schema/default.js"(exports, module) {
      "use strict";
      module.exports = require_core().extend({
        implicit: [
          require_timestamp(),
          require_merge()
        ],
        explicit: [
          require_binary(),
          require_omap(),
          require_pairs(),
          require_set()
        ]
      });
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/loader.js
  var require_loader = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/loader.js"(exports, module) {
      "use strict";
      var common = require_common2();
      var YAMLException = require_exception();
      var makeSnippet = require_snippet();
      var DEFAULT_SCHEMA = require_default();
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      var CONTEXT_FLOW_IN = 1;
      var CONTEXT_FLOW_OUT = 2;
      var CONTEXT_BLOCK_IN = 3;
      var CONTEXT_BLOCK_OUT = 4;
      var CHOMPING_CLIP = 1;
      var CHOMPING_STRIP = 2;
      var CHOMPING_KEEP = 3;
      var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
      var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
      var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
      var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
      function _class(obj) {
        return Object.prototype.toString.call(obj);
      }
      function is_EOL(c) {
        return c === 10 || c === 13;
      }
      function is_WHITE_SPACE(c) {
        return c === 9 || c === 32;
      }
      function is_WS_OR_EOL(c) {
        return c === 9 || c === 32 || c === 10 || c === 13;
      }
      function is_FLOW_INDICATOR(c) {
        return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
      }
      function fromHexCode(c) {
        var lc;
        if (48 <= c && c <= 57) {
          return c - 48;
        }
        lc = c | 32;
        if (97 <= lc && lc <= 102) {
          return lc - 97 + 10;
        }
        return -1;
      }
      function escapedHexLen(c) {
        if (c === 120) {
          return 2;
        }
        if (c === 117) {
          return 4;
        }
        if (c === 85) {
          return 8;
        }
        return 0;
      }
      function fromDecimalCode(c) {
        if (48 <= c && c <= 57) {
          return c - 48;
        }
        return -1;
      }
      function simpleEscapeSequence(c) {
        return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
      }
      function charFromCodepoint(c) {
        if (c <= 65535) {
          return String.fromCharCode(c);
        }
        return String.fromCharCode(
          (c - 65536 >> 10) + 55296,
          (c - 65536 & 1023) + 56320
        );
      }
      function setProperty(object, key, value) {
        if (key === "__proto__") {
          Object.defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            writable: true,
            value
          });
        } else {
          object[key] = value;
        }
      }
      var simpleEscapeCheck = new Array(256);
      var simpleEscapeMap = new Array(256);
      for (i = 0; i < 256; i++) {
        simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
        simpleEscapeMap[i] = simpleEscapeSequence(i);
      }
      var i;
      function State(input, options) {
        this.input = input;
        this.filename = options["filename"] || null;
        this.schema = options["schema"] || DEFAULT_SCHEMA;
        this.onWarning = options["onWarning"] || null;
        this.legacy = options["legacy"] || false;
        this.json = options["json"] || false;
        this.listener = options["listener"] || null;
        this.implicitTypes = this.schema.compiledImplicit;
        this.typeMap = this.schema.compiledTypeMap;
        this.length = input.length;
        this.position = 0;
        this.line = 0;
        this.lineStart = 0;
        this.lineIndent = 0;
        this.firstTabInLine = -1;
        this.documents = [];
      }
      function generateError(state, message) {
        var mark = {
          name: state.filename,
          buffer: state.input.slice(0, -1),
          // omit trailing \0
          position: state.position,
          line: state.line,
          column: state.position - state.lineStart
        };
        mark.snippet = makeSnippet(mark);
        return new YAMLException(message, mark);
      }
      function throwError(state, message) {
        throw generateError(state, message);
      }
      function throwWarning(state, message) {
        if (state.onWarning) {
          state.onWarning.call(null, generateError(state, message));
        }
      }
      var directiveHandlers = {
        YAML: function handleYamlDirective(state, name, args) {
          var match, major, minor;
          if (state.version !== null) {
            throwError(state, "duplication of %YAML directive");
          }
          if (args.length !== 1) {
            throwError(state, "YAML directive accepts exactly one argument");
          }
          match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
          if (match === null) {
            throwError(state, "ill-formed argument of the YAML directive");
          }
          major = parseInt(match[1], 10);
          minor = parseInt(match[2], 10);
          if (major !== 1) {
            throwError(state, "unacceptable YAML version of the document");
          }
          state.version = args[0];
          state.checkLineBreaks = minor < 2;
          if (minor !== 1 && minor !== 2) {
            throwWarning(state, "unsupported YAML version of the document");
          }
        },
        TAG: function handleTagDirective(state, name, args) {
          var handle, prefix;
          if (args.length !== 2) {
            throwError(state, "TAG directive accepts exactly two arguments");
          }
          handle = args[0];
          prefix = args[1];
          if (!PATTERN_TAG_HANDLE.test(handle)) {
            throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
          }
          if (_hasOwnProperty.call(state.tagMap, handle)) {
            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
          }
          if (!PATTERN_TAG_URI.test(prefix)) {
            throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
          }
          try {
            prefix = decodeURIComponent(prefix);
          } catch (err) {
            throwError(state, "tag prefix is malformed: " + prefix);
          }
          state.tagMap[handle] = prefix;
        }
      };
      function captureSegment(state, start, end, checkJson) {
        var _position, _length, _character, _result;
        if (start < end) {
          _result = state.input.slice(start, end);
          if (checkJson) {
            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
              _character = _result.charCodeAt(_position);
              if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
                throwError(state, "expected valid JSON character");
              }
            }
          } else if (PATTERN_NON_PRINTABLE.test(_result)) {
            throwError(state, "the stream contains non-printable characters");
          }
          state.result += _result;
        }
      }
      function mergeMappings(state, destination, source, overridableKeys) {
        var sourceKeys, key, index, quantity;
        if (!common.isObject(source)) {
          throwError(state, "cannot merge mappings; the provided source object is unacceptable");
        }
        sourceKeys = Object.keys(source);
        for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
          key = sourceKeys[index];
          if (!_hasOwnProperty.call(destination, key)) {
            setProperty(destination, key, source[key]);
            overridableKeys[key] = true;
          }
        }
      }
      function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
        var index, quantity;
        if (Array.isArray(keyNode)) {
          keyNode = Array.prototype.slice.call(keyNode);
          for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
            if (Array.isArray(keyNode[index])) {
              throwError(state, "nested arrays are not supported inside keys");
            }
            if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
              keyNode[index] = "[object Object]";
            }
          }
        }
        if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
          keyNode = "[object Object]";
        }
        keyNode = String(keyNode);
        if (_result === null) {
          _result = {};
        }
        if (keyTag === "tag:yaml.org,2002:merge") {
          if (Array.isArray(valueNode)) {
            for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
              mergeMappings(state, _result, valueNode[index], overridableKeys);
            }
          } else {
            mergeMappings(state, _result, valueNode, overridableKeys);
          }
        } else {
          if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
            state.line = startLine || state.line;
            state.lineStart = startLineStart || state.lineStart;
            state.position = startPos || state.position;
            throwError(state, "duplicated mapping key");
          }
          setProperty(_result, keyNode, valueNode);
          delete overridableKeys[keyNode];
        }
        return _result;
      }
      function readLineBreak(state) {
        var ch;
        ch = state.input.charCodeAt(state.position);
        if (ch === 10) {
          state.position++;
        } else if (ch === 13) {
          state.position++;
          if (state.input.charCodeAt(state.position) === 10) {
            state.position++;
          }
        } else {
          throwError(state, "a line break is expected");
        }
        state.line += 1;
        state.lineStart = state.position;
        state.firstTabInLine = -1;
      }
      function skipSeparationSpace(state, allowComments, checkIndent) {
        var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            if (ch === 9 && state.firstTabInLine === -1) {
              state.firstTabInLine = state.position;
            }
            ch = state.input.charCodeAt(++state.position);
          }
          if (allowComments && ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 10 && ch !== 13 && ch !== 0);
          }
          if (is_EOL(ch)) {
            readLineBreak(state);
            ch = state.input.charCodeAt(state.position);
            lineBreaks++;
            state.lineIndent = 0;
            while (ch === 32) {
              state.lineIndent++;
              ch = state.input.charCodeAt(++state.position);
            }
          } else {
            break;
          }
        }
        if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
          throwWarning(state, "deficient indentation");
        }
        return lineBreaks;
      }
      function testDocumentSeparator(state) {
        var _position = state.position, ch;
        ch = state.input.charCodeAt(_position);
        if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
          _position += 3;
          ch = state.input.charCodeAt(_position);
          if (ch === 0 || is_WS_OR_EOL(ch)) {
            return true;
          }
        }
        return false;
      }
      function writeFoldedLines(state, count) {
        if (count === 1) {
          state.result += " ";
        } else if (count > 1) {
          state.result += common.repeat("\n", count - 1);
        }
      }
      function readPlainScalar(state, nodeIndent, withinFlowCollection) {
        var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
        ch = state.input.charCodeAt(state.position);
        if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
          return false;
        }
        if (ch === 63 || ch === 45) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            return false;
          }
        }
        state.kind = "scalar";
        state.result = "";
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
        while (ch !== 0) {
          if (ch === 58) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
              break;
            }
          } else if (ch === 35) {
            preceding = state.input.charCodeAt(state.position - 1);
            if (is_WS_OR_EOL(preceding)) {
              break;
            }
          } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
            break;
          } else if (is_EOL(ch)) {
            _line = state.line;
            _lineStart = state.lineStart;
            _lineIndent = state.lineIndent;
            skipSeparationSpace(state, false, -1);
            if (state.lineIndent >= nodeIndent) {
              hasPendingContent = true;
              ch = state.input.charCodeAt(state.position);
              continue;
            } else {
              state.position = captureEnd;
              state.line = _line;
              state.lineStart = _lineStart;
              state.lineIndent = _lineIndent;
              break;
            }
          }
          if (hasPendingContent) {
            captureSegment(state, captureStart, captureEnd, false);
            writeFoldedLines(state, state.line - _line);
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
          }
          if (!is_WHITE_SPACE(ch)) {
            captureEnd = state.position + 1;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, captureEnd, false);
        if (state.result) {
          return true;
        }
        state.kind = _kind;
        state.result = _result;
        return false;
      }
      function readSingleQuotedScalar(state, nodeIndent) {
        var ch, captureStart, captureEnd;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 39) {
          return false;
        }
        state.kind = "scalar";
        state.result = "";
        state.position++;
        captureStart = captureEnd = state.position;
        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          if (ch === 39) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (ch === 39) {
              captureStart = state.position;
              state.position++;
              captureEnd = state.position;
            } else {
              return true;
            }
          } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, "unexpected end of the document within a single quoted scalar");
          } else {
            state.position++;
            captureEnd = state.position;
          }
        }
        throwError(state, "unexpected end of the stream within a single quoted scalar");
      }
      function readDoubleQuotedScalar(state, nodeIndent) {
        var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 34) {
          return false;
        }
        state.kind = "scalar";
        state.result = "";
        state.position++;
        captureStart = captureEnd = state.position;
        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          if (ch === 34) {
            captureSegment(state, captureStart, state.position, true);
            state.position++;
            return true;
          } else if (ch === 92) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (is_EOL(ch)) {
              skipSeparationSpace(state, false, nodeIndent);
            } else if (ch < 256 && simpleEscapeCheck[ch]) {
              state.result += simpleEscapeMap[ch];
              state.position++;
            } else if ((tmp = escapedHexLen(ch)) > 0) {
              hexLength = tmp;
              hexResult = 0;
              for (; hexLength > 0; hexLength--) {
                ch = state.input.charCodeAt(++state.position);
                if ((tmp = fromHexCode(ch)) >= 0) {
                  hexResult = (hexResult << 4) + tmp;
                } else {
                  throwError(state, "expected hexadecimal character");
                }
              }
              state.result += charFromCodepoint(hexResult);
              state.position++;
            } else {
              throwError(state, "unknown escape sequence");
            }
            captureStart = captureEnd = state.position;
          } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, "unexpected end of the document within a double quoted scalar");
          } else {
            state.position++;
            captureEnd = state.position;
          }
        }
        throwError(state, "unexpected end of the stream within a double quoted scalar");
      }
      function readFlowCollection(state, nodeIndent) {
        var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch === 91) {
          terminator = 93;
          isMapping = false;
          _result = [];
        } else if (ch === 123) {
          terminator = 125;
          isMapping = true;
          _result = {};
        } else {
          return false;
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result;
        }
        ch = state.input.charCodeAt(++state.position);
        while (ch !== 0) {
          skipSeparationSpace(state, true, nodeIndent);
          ch = state.input.charCodeAt(state.position);
          if (ch === terminator) {
            state.position++;
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = isMapping ? "mapping" : "sequence";
            state.result = _result;
            return true;
          } else if (!readNext) {
            throwError(state, "missed comma between flow collection entries");
          } else if (ch === 44) {
            throwError(state, "expected the node content, but found ','");
          }
          keyTag = keyNode = valueNode = null;
          isPair = isExplicitPair = false;
          if (ch === 63) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following)) {
              isPair = isExplicitPair = true;
              state.position++;
              skipSeparationSpace(state, true, nodeIndent);
            }
          }
          _line = state.line;
          _lineStart = state.lineStart;
          _pos = state.position;
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          keyTag = state.tag;
          keyNode = state.result;
          skipSeparationSpace(state, true, nodeIndent);
          ch = state.input.charCodeAt(state.position);
          if ((isExplicitPair || state.line === _line) && ch === 58) {
            isPair = true;
            ch = state.input.charCodeAt(++state.position);
            skipSeparationSpace(state, true, nodeIndent);
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            valueNode = state.result;
          }
          if (isMapping) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
          } else if (isPair) {
            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
          } else {
            _result.push(keyNode);
          }
          skipSeparationSpace(state, true, nodeIndent);
          ch = state.input.charCodeAt(state.position);
          if (ch === 44) {
            readNext = true;
            ch = state.input.charCodeAt(++state.position);
          } else {
            readNext = false;
          }
        }
        throwError(state, "unexpected end of the stream within a flow collection");
      }
      function readBlockScalar(state, nodeIndent) {
        var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch === 124) {
          folding = false;
        } else if (ch === 62) {
          folding = true;
        } else {
          return false;
        }
        state.kind = "scalar";
        state.result = "";
        while (ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
          if (ch === 43 || ch === 45) {
            if (CHOMPING_CLIP === chomping) {
              chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
            } else {
              throwError(state, "repeat of a chomping mode identifier");
            }
          } else if ((tmp = fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) {
              throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
            } else if (!detectedIndent) {
              textIndent = nodeIndent + tmp - 1;
              detectedIndent = true;
            } else {
              throwError(state, "repeat of an indentation width identifier");
            }
          } else {
            break;
          }
        }
        if (is_WHITE_SPACE(ch)) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (is_WHITE_SPACE(ch));
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (!is_EOL(ch) && ch !== 0);
          }
        }
        while (ch !== 0) {
          readLineBreak(state);
          state.lineIndent = 0;
          ch = state.input.charCodeAt(state.position);
          while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
          if (!detectedIndent && state.lineIndent > textIndent) {
            textIndent = state.lineIndent;
          }
          if (is_EOL(ch)) {
            emptyLines++;
            continue;
          }
          if (state.lineIndent < textIndent) {
            if (chomping === CHOMPING_KEEP) {
              state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            } else if (chomping === CHOMPING_CLIP) {
              if (didReadContent) {
                state.result += "\n";
              }
            }
            break;
          }
          if (folding) {
            if (is_WHITE_SPACE(ch)) {
              atMoreIndented = true;
              state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            } else if (atMoreIndented) {
              atMoreIndented = false;
              state.result += common.repeat("\n", emptyLines + 1);
            } else if (emptyLines === 0) {
              if (didReadContent) {
                state.result += " ";
              }
            } else {
              state.result += common.repeat("\n", emptyLines);
            }
          } else {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          }
          didReadContent = true;
          detectedIndent = true;
          emptyLines = 0;
          captureStart = state.position;
          while (!is_EOL(ch) && ch !== 0) {
            ch = state.input.charCodeAt(++state.position);
          }
          captureSegment(state, captureStart, state.position, false);
        }
        return true;
      }
      function readBlockSequence(state, nodeIndent) {
        var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
        if (state.firstTabInLine !== -1) return false;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result;
        }
        ch = state.input.charCodeAt(state.position);
        while (ch !== 0) {
          if (state.firstTabInLine !== -1) {
            state.position = state.firstTabInLine;
            throwError(state, "tab characters must not be used in indentation");
          }
          if (ch !== 45) {
            break;
          }
          following = state.input.charCodeAt(state.position + 1);
          if (!is_WS_OR_EOL(following)) {
            break;
          }
          detected = true;
          state.position++;
          if (skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
              _result.push(null);
              ch = state.input.charCodeAt(state.position);
              continue;
            }
          }
          _line = state.line;
          composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
          _result.push(state.result);
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
          if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
            throwError(state, "bad indentation of a sequence entry");
          } else if (state.lineIndent < nodeIndent) {
            break;
          }
        }
        if (detected) {
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = "sequence";
          state.result = _result;
          return true;
        }
        return false;
      }
      function readBlockMapping(state, nodeIndent, flowIndent) {
        var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
        if (state.firstTabInLine !== -1) return false;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result;
        }
        ch = state.input.charCodeAt(state.position);
        while (ch !== 0) {
          if (!atExplicitKey && state.firstTabInLine !== -1) {
            state.position = state.firstTabInLine;
            throwError(state, "tab characters must not be used in indentation");
          }
          following = state.input.charCodeAt(state.position + 1);
          _line = state.line;
          if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
            if (ch === 63) {
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = true;
              allowCompact = true;
            } else if (atExplicitKey) {
              atExplicitKey = false;
              allowCompact = true;
            } else {
              throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
            }
            state.position += 1;
            ch = following;
          } else {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
            if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
              break;
            }
            if (state.line === _line) {
              ch = state.input.charCodeAt(state.position);
              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (ch === 58) {
                ch = state.input.charCodeAt(++state.position);
                if (!is_WS_OR_EOL(ch)) {
                  throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                }
                if (atExplicitKey) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                  keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = false;
                allowCompact = false;
                keyTag = state.tag;
                keyNode = state.result;
              } else if (detected) {
                throwError(state, "can not read an implicit mapping pair; a colon is missed");
              } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true;
              }
            } else if (detected) {
              throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          }
          if (state.line === _line || state.lineIndent > nodeIndent) {
            if (atExplicitKey) {
              _keyLine = state.line;
              _keyLineStart = state.lineStart;
              _keyPos = state.position;
            }
            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
              if (atExplicitKey) {
                keyNode = state.result;
              } else {
                valueNode = state.result;
              }
            }
            if (!atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
          }
          if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
            throwError(state, "bad indentation of a mapping entry");
          } else if (state.lineIndent < nodeIndent) {
            break;
          }
        }
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
        }
        if (detected) {
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = "mapping";
          state.result = _result;
        }
        return detected;
      }
      function readTagProperty(state) {
        var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 33) return false;
        if (state.tag !== null) {
          throwError(state, "duplication of a tag property");
        }
        ch = state.input.charCodeAt(++state.position);
        if (ch === 60) {
          isVerbatim = true;
          ch = state.input.charCodeAt(++state.position);
        } else if (ch === 33) {
          isNamed = true;
          tagHandle = "!!";
          ch = state.input.charCodeAt(++state.position);
        } else {
          tagHandle = "!";
        }
        _position = state.position;
        if (isVerbatim) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && ch !== 62);
          if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position);
            ch = state.input.charCodeAt(++state.position);
          } else {
            throwError(state, "unexpected end of the stream within a verbatim tag");
          }
        } else {
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            if (ch === 33) {
              if (!isNamed) {
                tagHandle = state.input.slice(_position - 1, state.position + 1);
                if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                  throwError(state, "named tag handle cannot contain such characters");
                }
                isNamed = true;
                _position = state.position + 1;
              } else {
                throwError(state, "tag suffix cannot contain exclamation marks");
              }
            }
            ch = state.input.charCodeAt(++state.position);
          }
          tagName = state.input.slice(_position, state.position);
          if (PATTERN_FLOW_INDICATORS.test(tagName)) {
            throwError(state, "tag suffix cannot contain flow indicator characters");
          }
        }
        if (tagName && !PATTERN_TAG_URI.test(tagName)) {
          throwError(state, "tag name cannot contain such characters: " + tagName);
        }
        try {
          tagName = decodeURIComponent(tagName);
        } catch (err) {
          throwError(state, "tag name is malformed: " + tagName);
        }
        if (isVerbatim) {
          state.tag = tagName;
        } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
          state.tag = state.tagMap[tagHandle] + tagName;
        } else if (tagHandle === "!") {
          state.tag = "!" + tagName;
        } else if (tagHandle === "!!") {
          state.tag = "tag:yaml.org,2002:" + tagName;
        } else {
          throwError(state, 'undeclared tag handle "' + tagHandle + '"');
        }
        return true;
      }
      function readAnchorProperty(state) {
        var _position, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 38) return false;
        if (state.anchor !== null) {
          throwError(state, "duplication of an anchor property");
        }
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (state.position === _position) {
          throwError(state, "name of an anchor node must contain at least one character");
        }
        state.anchor = state.input.slice(_position, state.position);
        return true;
      }
      function readAlias(state) {
        var _position, alias, ch;
        ch = state.input.charCodeAt(state.position);
        if (ch !== 42) return false;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (state.position === _position) {
          throwError(state, "name of an alias node must contain at least one character");
        }
        alias = state.input.slice(_position, state.position);
        if (!_hasOwnProperty.call(state.anchorMap, alias)) {
          throwError(state, 'unidentified alias "' + alias + '"');
        }
        state.result = state.anchorMap[alias];
        skipSeparationSpace(state, true, -1);
        return true;
      }
      function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
        var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
        if (state.listener !== null) {
          state.listener("open", state);
        }
        state.tag = null;
        state.anchor = null;
        state.kind = null;
        state.result = null;
        allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
        if (allowToSeek) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          }
        }
        if (indentStatus === 1) {
          while (readTagProperty(state) || readAnchorProperty(state)) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true;
              allowBlockCollections = allowBlockStyles;
              if (state.lineIndent > parentIndent) {
                indentStatus = 1;
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
              }
            } else {
              allowBlockCollections = false;
            }
          }
        }
        if (allowBlockCollections) {
          allowBlockCollections = atNewLine || allowCompact;
        }
        if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
          if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
            flowIndent = parentIndent;
          } else {
            flowIndent = parentIndent + 1;
          }
          blockIndent = state.position - state.lineStart;
          if (indentStatus === 1) {
            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
              hasContent = true;
            } else {
              if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                hasContent = true;
              } else if (readAlias(state)) {
                hasContent = true;
                if (state.tag !== null || state.anchor !== null) {
                  throwError(state, "alias node should not have any properties");
                }
              } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                hasContent = true;
                if (state.tag === null) {
                  state.tag = "?";
                }
              }
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
            }
          } else if (indentStatus === 0) {
            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
          }
        }
        if (state.tag === null) {
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        } else if (state.tag === "?") {
          if (state.result !== null && state.kind !== "scalar") {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (state.tag !== "!") {
          if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
            type = state.typeMap[state.kind || "fallback"][state.tag];
          } else {
            type = null;
            typeList = state.typeMap.multi[state.kind || "fallback"];
            for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
              if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
                type = typeList[typeIndex];
                break;
              }
            }
          }
          if (!type) {
            throwError(state, "unknown tag !<" + state.tag + ">");
          }
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result, state.tag)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result, state.tag);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        }
        if (state.listener !== null) {
          state.listener("close", state);
        }
        return state.tag !== null || state.anchor !== null || hasContent;
      }
      function readDocument(state) {
        var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
        state.version = null;
        state.checkLineBreaks = state.legacy;
        state.tagMap = /* @__PURE__ */ Object.create(null);
        state.anchorMap = /* @__PURE__ */ Object.create(null);
        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
          if (state.lineIndent > 0 || ch !== 37) {
            break;
          }
          hasDirectives = true;
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveName = state.input.slice(_position, state.position);
          directiveArgs = [];
          if (directiveName.length < 1) {
            throwError(state, "directive name must not be less than one character in length");
          }
          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 35) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 0 && !is_EOL(ch));
              break;
            }
            if (is_EOL(ch)) break;
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            directiveArgs.push(state.input.slice(_position, state.position));
          }
          if (ch !== 0) readLineBreak(state);
          if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
            directiveHandlers[directiveName](state, directiveName, directiveArgs);
          } else {
            throwWarning(state, 'unknown document directive "' + directiveName + '"');
          }
        }
        skipSeparationSpace(state, true, -1);
        if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        } else if (hasDirectives) {
          throwError(state, "directives end mark is expected");
        }
        composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
        skipSeparationSpace(state, true, -1);
        if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
          throwWarning(state, "non-ASCII line breaks are interpreted as content");
        }
        state.documents.push(state.result);
        if (state.position === state.lineStart && testDocumentSeparator(state)) {
          if (state.input.charCodeAt(state.position) === 46) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
          }
          return;
        }
        if (state.position < state.length - 1) {
          throwError(state, "end of the stream or a document separator is expected");
        } else {
          return;
        }
      }
      function loadDocuments(input, options) {
        input = String(input);
        options = options || {};
        if (input.length !== 0) {
          if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
            input += "\n";
          }
          if (input.charCodeAt(0) === 65279) {
            input = input.slice(1);
          }
        }
        var state = new State(input, options);
        var nullpos = input.indexOf("\0");
        if (nullpos !== -1) {
          state.position = nullpos;
          throwError(state, "null byte is not allowed in input");
        }
        state.input += "\0";
        while (state.input.charCodeAt(state.position) === 32) {
          state.lineIndent += 1;
          state.position += 1;
        }
        while (state.position < state.length - 1) {
          readDocument(state);
        }
        return state.documents;
      }
      function loadAll(input, iterator, options) {
        if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
          options = iterator;
          iterator = null;
        }
        var documents = loadDocuments(input, options);
        if (typeof iterator !== "function") {
          return documents;
        }
        for (var index = 0, length = documents.length; index < length; index += 1) {
          iterator(documents[index]);
        }
      }
      function load(input, options) {
        var documents = loadDocuments(input, options);
        if (documents.length === 0) {
          return void 0;
        } else if (documents.length === 1) {
          return documents[0];
        }
        throw new YAMLException("expected a single document in the stream, but found more");
      }
      module.exports.loadAll = loadAll;
      module.exports.load = load;
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/dumper.js
  var require_dumper = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/lib/dumper.js"(exports, module) {
      "use strict";
      var common = require_common2();
      var YAMLException = require_exception();
      var DEFAULT_SCHEMA = require_default();
      var _toString = Object.prototype.toString;
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      var CHAR_BOM = 65279;
      var CHAR_TAB = 9;
      var CHAR_LINE_FEED = 10;
      var CHAR_CARRIAGE_RETURN = 13;
      var CHAR_SPACE = 32;
      var CHAR_EXCLAMATION = 33;
      var CHAR_DOUBLE_QUOTE = 34;
      var CHAR_SHARP = 35;
      var CHAR_PERCENT = 37;
      var CHAR_AMPERSAND = 38;
      var CHAR_SINGLE_QUOTE = 39;
      var CHAR_ASTERISK = 42;
      var CHAR_COMMA = 44;
      var CHAR_MINUS = 45;
      var CHAR_COLON = 58;
      var CHAR_EQUALS = 61;
      var CHAR_GREATER_THAN = 62;
      var CHAR_QUESTION = 63;
      var CHAR_COMMERCIAL_AT = 64;
      var CHAR_LEFT_SQUARE_BRACKET = 91;
      var CHAR_RIGHT_SQUARE_BRACKET = 93;
      var CHAR_GRAVE_ACCENT = 96;
      var CHAR_LEFT_CURLY_BRACKET = 123;
      var CHAR_VERTICAL_LINE = 124;
      var CHAR_RIGHT_CURLY_BRACKET = 125;
      var ESCAPE_SEQUENCES = {};
      ESCAPE_SEQUENCES[0] = "\\0";
      ESCAPE_SEQUENCES[7] = "\\a";
      ESCAPE_SEQUENCES[8] = "\\b";
      ESCAPE_SEQUENCES[9] = "\\t";
      ESCAPE_SEQUENCES[10] = "\\n";
      ESCAPE_SEQUENCES[11] = "\\v";
      ESCAPE_SEQUENCES[12] = "\\f";
      ESCAPE_SEQUENCES[13] = "\\r";
      ESCAPE_SEQUENCES[27] = "\\e";
      ESCAPE_SEQUENCES[34] = '\\"';
      ESCAPE_SEQUENCES[92] = "\\\\";
      ESCAPE_SEQUENCES[133] = "\\N";
      ESCAPE_SEQUENCES[160] = "\\_";
      ESCAPE_SEQUENCES[8232] = "\\L";
      ESCAPE_SEQUENCES[8233] = "\\P";
      var DEPRECATED_BOOLEANS_SYNTAX = [
        "y",
        "Y",
        "yes",
        "Yes",
        "YES",
        "on",
        "On",
        "ON",
        "n",
        "N",
        "no",
        "No",
        "NO",
        "off",
        "Off",
        "OFF"
      ];
      var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
      function compileStyleMap(schema, map) {
        var result, keys, index, length, tag, style, type;
        if (map === null) return {};
        result = {};
        keys = Object.keys(map);
        for (index = 0, length = keys.length; index < length; index += 1) {
          tag = keys[index];
          style = String(map[tag]);
          if (tag.slice(0, 2) === "!!") {
            tag = "tag:yaml.org,2002:" + tag.slice(2);
          }
          type = schema.compiledTypeMap["fallback"][tag];
          if (type && _hasOwnProperty.call(type.styleAliases, style)) {
            style = type.styleAliases[style];
          }
          result[tag] = style;
        }
        return result;
      }
      function encodeHex(character) {
        var string, handle, length;
        string = character.toString(16).toUpperCase();
        if (character <= 255) {
          handle = "x";
          length = 2;
        } else if (character <= 65535) {
          handle = "u";
          length = 4;
        } else if (character <= 4294967295) {
          handle = "U";
          length = 8;
        } else {
          throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
        }
        return "\\" + handle + common.repeat("0", length - string.length) + string;
      }
      var QUOTING_TYPE_SINGLE = 1;
      var QUOTING_TYPE_DOUBLE = 2;
      function State(options) {
        this.schema = options["schema"] || DEFAULT_SCHEMA;
        this.indent = Math.max(1, options["indent"] || 2);
        this.noArrayIndent = options["noArrayIndent"] || false;
        this.skipInvalid = options["skipInvalid"] || false;
        this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
        this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
        this.sortKeys = options["sortKeys"] || false;
        this.lineWidth = options["lineWidth"] || 80;
        this.noRefs = options["noRefs"] || false;
        this.noCompatMode = options["noCompatMode"] || false;
        this.condenseFlow = options["condenseFlow"] || false;
        this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
        this.forceQuotes = options["forceQuotes"] || false;
        this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
        this.implicitTypes = this.schema.compiledImplicit;
        this.explicitTypes = this.schema.compiledExplicit;
        this.tag = null;
        this.result = "";
        this.duplicates = [];
        this.usedDuplicates = null;
      }
      function indentString(string, spaces) {
        var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
        while (position < length) {
          next = string.indexOf("\n", position);
          if (next === -1) {
            line = string.slice(position);
            position = length;
          } else {
            line = string.slice(position, next + 1);
            position = next + 1;
          }
          if (line.length && line !== "\n") result += ind;
          result += line;
        }
        return result;
      }
      function generateNextLine(state, level) {
        return "\n" + common.repeat(" ", state.indent * level);
      }
      function testImplicitResolving(state, str) {
        var index, length, type;
        for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
          type = state.implicitTypes[index];
          if (type.resolve(str)) {
            return true;
          }
        }
        return false;
      }
      function isWhitespace(c) {
        return c === CHAR_SPACE || c === CHAR_TAB;
      }
      function isPrintable(c) {
        return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
      }
      function isNsCharOrWhitespace(c) {
        return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
      }
      function isPlainSafe(c, prev, inblock) {
        var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
        var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
        return (
          // ns-plain-safe
          (inblock ? (
            // c = flow-in
            cIsNsCharOrWhitespace
          ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
        );
      }
      function isPlainSafeFirst(c) {
        return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
      }
      function isPlainSafeLast(c) {
        return !isWhitespace(c) && c !== CHAR_COLON;
      }
      function codePointAt(string, pos) {
        var first = string.charCodeAt(pos), second;
        if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
          second = string.charCodeAt(pos + 1);
          if (second >= 56320 && second <= 57343) {
            return (first - 55296) * 1024 + second - 56320 + 65536;
          }
        }
        return first;
      }
      function needIndentIndicator(string) {
        var leadingSpaceRe = /^\n* /;
        return leadingSpaceRe.test(string);
      }
      var STYLE_PLAIN = 1;
      var STYLE_SINGLE = 2;
      var STYLE_LITERAL = 3;
      var STYLE_FOLDED = 4;
      var STYLE_DOUBLE = 5;
      function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
        var i;
        var char = 0;
        var prevChar = null;
        var hasLineBreak = false;
        var hasFoldableLine = false;
        var shouldTrackWidth = lineWidth !== -1;
        var previousLineBreak = -1;
        var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
        if (singleLineOnly || forceQuotes) {
          for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
            char = codePointAt(string, i);
            if (!isPrintable(char)) {
              return STYLE_DOUBLE;
            }
            plain = plain && isPlainSafe(char, prevChar, inblock);
            prevChar = char;
          }
        } else {
          for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
            char = codePointAt(string, i);
            if (char === CHAR_LINE_FEED) {
              hasLineBreak = true;
              if (shouldTrackWidth) {
                hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
                i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                previousLineBreak = i;
              }
            } else if (!isPrintable(char)) {
              return STYLE_DOUBLE;
            }
            plain = plain && isPlainSafe(char, prevChar, inblock);
            prevChar = char;
          }
          hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
        }
        if (!hasLineBreak && !hasFoldableLine) {
          if (plain && !forceQuotes && !testAmbiguousType(string)) {
            return STYLE_PLAIN;
          }
          return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
        }
        if (indentPerLevel > 9 && needIndentIndicator(string)) {
          return STYLE_DOUBLE;
        }
        if (!forceQuotes) {
          return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      function writeScalar(state, string, level, iskey, inblock) {
        state.dump = (function() {
          if (string.length === 0) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
          }
          if (!state.noCompatMode) {
            if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
              return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
            }
          }
          var indent = state.indent * Math.max(1, level);
          var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
          var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
          function testAmbiguity(string2) {
            return testImplicitResolving(state, string2);
          }
          switch (chooseScalarStyle(
            string,
            singleLineOnly,
            state.indent,
            lineWidth,
            testAmbiguity,
            state.quotingType,
            state.forceQuotes && !iskey,
            inblock
          )) {
            case STYLE_PLAIN:
              return string;
            case STYLE_SINGLE:
              return "'" + string.replace(/'/g, "''") + "'";
            case STYLE_LITERAL:
              return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
            case STYLE_FOLDED:
              return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
            case STYLE_DOUBLE:
              return '"' + escapeString(string, lineWidth) + '"';
            default:
              throw new YAMLException("impossible error: invalid scalar style");
          }
        })();
      }
      function blockHeader(string, indentPerLevel) {
        var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
        var clip = string[string.length - 1] === "\n";
        var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
        var chomp = keep ? "+" : clip ? "" : "-";
        return indentIndicator + chomp + "\n";
      }
      function dropEndingNewline(string) {
        return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
      }
      function foldString(string, width) {
        var lineRe = /(\n+)([^\n]*)/g;
        var result = (function() {
          var nextLF = string.indexOf("\n");
          nextLF = nextLF !== -1 ? nextLF : string.length;
          lineRe.lastIndex = nextLF;
          return foldLine(string.slice(0, nextLF), width);
        })();
        var prevMoreIndented = string[0] === "\n" || string[0] === " ";
        var moreIndented;
        var match;
        while (match = lineRe.exec(string)) {
          var prefix = match[1], line = match[2];
          moreIndented = line[0] === " ";
          result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
          prevMoreIndented = moreIndented;
        }
        return result;
      }
      function foldLine(line, width) {
        if (line === "" || line[0] === " ") return line;
        var breakRe = / [^ ]/g;
        var match;
        var start = 0, end, curr = 0, next = 0;
        var result = "";
        while (match = breakRe.exec(line)) {
          next = match.index;
          if (next - start > width) {
            end = curr > start ? curr : next;
            result += "\n" + line.slice(start, end);
            start = end + 1;
          }
          curr = next;
        }
        result += "\n";
        if (line.length - start > width && curr > start) {
          result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
        } else {
          result += line.slice(start);
        }
        return result.slice(1);
      }
      function escapeString(string) {
        var result = "";
        var char = 0;
        var escapeSeq;
        for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string, i);
          escapeSeq = ESCAPE_SEQUENCES[char];
          if (!escapeSeq && isPrintable(char)) {
            result += string[i];
            if (char >= 65536) result += string[i + 1];
          } else {
            result += escapeSeq || encodeHex(char);
          }
        }
        return result;
      }
      function writeFlowSequence(state, level, object) {
        var _result = "", _tag = state.tag, index, length, value;
        for (index = 0, length = object.length; index < length; index += 1) {
          value = object[index];
          if (state.replacer) {
            value = state.replacer.call(object, String(index), value);
          }
          if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
            if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
            _result += state.dump;
          }
        }
        state.tag = _tag;
        state.dump = "[" + _result + "]";
      }
      function writeBlockSequence(state, level, object, compact) {
        var _result = "", _tag = state.tag, index, length, value;
        for (index = 0, length = object.length; index < length; index += 1) {
          value = object[index];
          if (state.replacer) {
            value = state.replacer.call(object, String(index), value);
          }
          if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
            if (!compact || _result !== "") {
              _result += generateNextLine(state, level);
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              _result += "-";
            } else {
              _result += "- ";
            }
            _result += state.dump;
          }
        }
        state.tag = _tag;
        state.dump = _result || "[]";
      }
      function writeFlowMapping(state, level, object) {
        var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          pairBuffer = "";
          if (_result !== "") pairBuffer += ", ";
          if (state.condenseFlow) pairBuffer += '"';
          objectKey = objectKeyList[index];
          objectValue = object[objectKey];
          if (state.replacer) {
            objectValue = state.replacer.call(object, objectKey, objectValue);
          }
          if (!writeNode(state, level, objectKey, false, false)) {
            continue;
          }
          if (state.dump.length > 1024) pairBuffer += "? ";
          pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
          if (!writeNode(state, level, objectValue, false, false)) {
            continue;
          }
          pairBuffer += state.dump;
          _result += pairBuffer;
        }
        state.tag = _tag;
        state.dump = "{" + _result + "}";
      }
      function writeBlockMapping(state, level, object, compact) {
        var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
        if (state.sortKeys === true) {
          objectKeyList.sort();
        } else if (typeof state.sortKeys === "function") {
          objectKeyList.sort(state.sortKeys);
        } else if (state.sortKeys) {
          throw new YAMLException("sortKeys must be a boolean or a function");
        }
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          pairBuffer = "";
          if (!compact || _result !== "") {
            pairBuffer += generateNextLine(state, level);
          }
          objectKey = objectKeyList[index];
          objectValue = object[objectKey];
          if (state.replacer) {
            objectValue = state.replacer.call(object, objectKey, objectValue);
          }
          if (!writeNode(state, level + 1, objectKey, true, true, true)) {
            continue;
          }
          explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
          if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += "?";
            } else {
              pairBuffer += "? ";
            }
          }
          pairBuffer += state.dump;
          if (explicitPair) {
            pairBuffer += generateNextLine(state, level);
          }
          if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
            continue;
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += ":";
          } else {
            pairBuffer += ": ";
          }
          pairBuffer += state.dump;
          _result += pairBuffer;
        }
        state.tag = _tag;
        state.dump = _result || "{}";
      }
      function detectType(state, object, explicit) {
        var _result, typeList, index, length, type, style;
        typeList = explicit ? state.explicitTypes : state.implicitTypes;
        for (index = 0, length = typeList.length; index < length; index += 1) {
          type = typeList[index];
          if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
            if (explicit) {
              if (type.multi && type.representName) {
                state.tag = type.representName(object);
              } else {
                state.tag = type.tag;
              }
            } else {
              state.tag = "?";
            }
            if (type.represent) {
              style = state.styleMap[type.tag] || type.defaultStyle;
              if (_toString.call(type.represent) === "[object Function]") {
                _result = type.represent(object, style);
              } else if (_hasOwnProperty.call(type.represent, style)) {
                _result = type.represent[style](object, style);
              } else {
                throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
              }
              state.dump = _result;
            }
            return true;
          }
        }
        return false;
      }
      function writeNode(state, level, object, block, compact, iskey, isblockseq) {
        state.tag = null;
        state.dump = object;
        if (!detectType(state, object, false)) {
          detectType(state, object, true);
        }
        var type = _toString.call(state.dump);
        var inblock = block;
        var tagStr;
        if (block) {
          block = state.flowLevel < 0 || state.flowLevel > level;
        }
        var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
        if (objectOrArray) {
          duplicateIndex = state.duplicates.indexOf(object);
          duplicate = duplicateIndex !== -1;
        }
        if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
          compact = false;
        }
        if (duplicate && state.usedDuplicates[duplicateIndex]) {
          state.dump = "*ref_" + duplicateIndex;
        } else {
          if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
            state.usedDuplicates[duplicateIndex] = true;
          }
          if (type === "[object Object]") {
            if (block && Object.keys(state.dump).length !== 0) {
              writeBlockMapping(state, level, state.dump, compact);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + state.dump;
              }
            } else {
              writeFlowMapping(state, level, state.dump);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + " " + state.dump;
              }
            }
          } else if (type === "[object Array]") {
            if (block && state.dump.length !== 0) {
              if (state.noArrayIndent && !isblockseq && level > 0) {
                writeBlockSequence(state, level - 1, state.dump, compact);
              } else {
                writeBlockSequence(state, level, state.dump, compact);
              }
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + state.dump;
              }
            } else {
              writeFlowSequence(state, level, state.dump);
              if (duplicate) {
                state.dump = "&ref_" + duplicateIndex + " " + state.dump;
              }
            }
          } else if (type === "[object String]") {
            if (state.tag !== "?") {
              writeScalar(state, state.dump, level, iskey, inblock);
            }
          } else if (type === "[object Undefined]") {
            return false;
          } else {
            if (state.skipInvalid) return false;
            throw new YAMLException("unacceptable kind of an object to dump " + type);
          }
          if (state.tag !== null && state.tag !== "?") {
            tagStr = encodeURI(
              state.tag[0] === "!" ? state.tag.slice(1) : state.tag
            ).replace(/!/g, "%21");
            if (state.tag[0] === "!") {
              tagStr = "!" + tagStr;
            } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
              tagStr = "!!" + tagStr.slice(18);
            } else {
              tagStr = "!<" + tagStr + ">";
            }
            state.dump = tagStr + " " + state.dump;
          }
        }
        return true;
      }
      function getDuplicateReferences(object, state) {
        var objects = [], duplicatesIndexes = [], index, length;
        inspectNode(object, objects, duplicatesIndexes);
        for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
          state.duplicates.push(objects[duplicatesIndexes[index]]);
        }
        state.usedDuplicates = new Array(length);
      }
      function inspectNode(object, objects, duplicatesIndexes) {
        var objectKeyList, index, length;
        if (object !== null && typeof object === "object") {
          index = objects.indexOf(object);
          if (index !== -1) {
            if (duplicatesIndexes.indexOf(index) === -1) {
              duplicatesIndexes.push(index);
            }
          } else {
            objects.push(object);
            if (Array.isArray(object)) {
              for (index = 0, length = object.length; index < length; index += 1) {
                inspectNode(object[index], objects, duplicatesIndexes);
              }
            } else {
              objectKeyList = Object.keys(object);
              for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
              }
            }
          }
        }
      }
      function dump(input, options) {
        options = options || {};
        var state = new State(options);
        if (!state.noRefs) getDuplicateReferences(input, state);
        var value = input;
        if (state.replacer) {
          value = state.replacer.call({ "": value }, "", value);
        }
        if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
        return "";
      }
      module.exports.dump = dump;
    }
  });

  // node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/index.js
  var require_js_yaml = __commonJS({
    "node_modules/.pnpm/js-yaml@4.1.1/node_modules/js-yaml/index.js"(exports, module) {
      "use strict";
      var loader = require_loader();
      var dumper = require_dumper();
      function renamed(from, to) {
        return function() {
          throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
        };
      }
      module.exports.Type = require_type();
      module.exports.Schema = require_schema();
      module.exports.FAILSAFE_SCHEMA = require_failsafe();
      module.exports.JSON_SCHEMA = require_json();
      module.exports.CORE_SCHEMA = require_core();
      module.exports.DEFAULT_SCHEMA = require_default();
      module.exports.load = loader.load;
      module.exports.loadAll = loader.loadAll;
      module.exports.dump = dumper.dump;
      module.exports.YAMLException = require_exception();
      module.exports.types = {
        binary: require_binary(),
        float: require_float(),
        map: require_map(),
        null: require_null(),
        pairs: require_pairs(),
        set: require_set(),
        timestamp: require_timestamp(),
        bool: require_bool(),
        int: require_int(),
        merge: require_merge(),
        omap: require_omap(),
        seq: require_seq(),
        str: require_str()
      };
      module.exports.safeLoad = renamed("safeLoad", "load");
      module.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
      module.exports.safeDump = renamed("safeDump", "dump");
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/YAMLReader.js
  var require_YAMLReader = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/YAMLReader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.YAMLReader = void 0;
      var ObjectReader_1 = require_ObjectReader();
      var BaseReader_1 = require_BaseReader();
      var js_yaml_1 = require_js_yaml();
      var YAMLReader = class extends BaseReader_1.BaseReader {
        /**
         * Parses the given document representation.
         *
         * @param node - node receive parsed XML nodes
         * @param str - YAML string to parse
         */
        _parse(node, str) {
          const result = (0, js_yaml_1.load)(str);
          if (result === void 0) {
            throw new Error("Unable to parse YAML document.");
          }
          return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, result);
        }
      };
      exports.YAMLReader = YAMLReader;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/index.js
  var require_readers = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/readers/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.YAMLReader = exports.JSONReader = exports.ObjectReader = exports.XMLReader = void 0;
      var XMLReader_1 = require_XMLReader();
      Object.defineProperty(exports, "XMLReader", { enumerable: true, get: function() {
        return XMLReader_1.XMLReader;
      } });
      var ObjectReader_1 = require_ObjectReader();
      Object.defineProperty(exports, "ObjectReader", { enumerable: true, get: function() {
        return ObjectReader_1.ObjectReader;
      } });
      var JSONReader_1 = require_JSONReader();
      Object.defineProperty(exports, "JSONReader", { enumerable: true, get: function() {
        return JSONReader_1.JSONReader;
      } });
      var YAMLReader_1 = require_YAMLReader();
      Object.defineProperty(exports, "YAMLReader", { enumerable: true, get: function() {
        return YAMLReader_1.YAMLReader;
      } });
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/XMLBuilderImpl.js
  var require_XMLBuilderImpl = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/XMLBuilderImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLBuilderImpl = void 0;
      var interfaces_1 = require_interfaces();
      var util_1 = require_lib4();
      var writers_1 = require_writers();
      var interfaces_2 = require_interfaces2();
      var util_2 = require_util2();
      var algorithm_1 = require_algorithm();
      var dom_1 = require_dom2();
      var infra_1 = require_lib5();
      var readers_1 = require_readers();
      var XMLBuilderImpl = class _XMLBuilderImpl {
        /**
         * Initializes a new instance of `XMLBuilderNodeImpl`.
         *
         * @param domNode - the DOM node to wrap
         */
        constructor(domNode) {
          __publicField(this, "_domNode");
          this._domNode = domNode;
        }
        /** @inheritdoc */
        get node() {
          return this._domNode;
        }
        /** @inheritdoc */
        get options() {
          return this._options;
        }
        /** @inheritdoc */
        set(options) {
          this._options = (0, util_1.applyDefaults)(
            (0, util_1.applyDefaults)(this._options, options, true),
            // apply user settings
            interfaces_1.DefaultBuilderOptions
          );
          return this;
        }
        /** @inheritdoc */
        ele(p1, p2, p3) {
          let namespace;
          let name;
          let attributes;
          if ((0, util_1.isObject)(p1)) {
            return new readers_1.ObjectReader(this._options).parse(this, p1);
          } else if ((0, util_1.isString)(p1) && p1 !== null && /^\s*</.test(p1)) {
            return new readers_1.XMLReader(this._options).parse(this, p1);
          } else if ((0, util_1.isString)(p1) && p1 !== null && /^\s*[\{\[]/.test(p1)) {
            return new readers_1.JSONReader(this._options).parse(this, p1);
          } else if ((0, util_1.isString)(p1) && p1 !== null && /^(\s*|(#.*)|(%.*))*---/.test(p1)) {
            return new readers_1.YAMLReader(this._options).parse(this, p1);
          }
          if ((p1 === null || (0, util_1.isString)(p1)) && (0, util_1.isString)(p2)) {
            [namespace, name, attributes] = [p1, p2, p3];
          } else if (p1 !== null) {
            [namespace, name, attributes] = [void 0, p1, (0, util_1.isObject)(p2) ? p2 : void 0];
          } else {
            throw new Error("Element name cannot be null. " + this._debugInfo());
          }
          if (attributes) {
            attributes = (0, util_1.getValue)(attributes);
          }
          [namespace, name] = this._extractNamespace((0, dom_1.sanitizeInput)(namespace, this._options.invalidCharReplacement), (0, dom_1.sanitizeInput)(name, this._options.invalidCharReplacement), true);
          if (namespace === void 0) {
            const [prefix] = (0, algorithm_1.namespace_extractQName)(name);
            namespace = this.node.lookupNamespaceURI(prefix);
          }
          const childNode = namespace !== void 0 && namespace !== null ? this._doc.createElementNS(namespace, name) : this._doc.createElement(name);
          this.node.appendChild(childNode);
          const builder = new _XMLBuilderImpl(childNode);
          const oldDocType = this._doc.doctype;
          if (childNode === this._doc.documentElement && oldDocType !== null) {
            const docType = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, oldDocType.publicId, oldDocType.systemId);
            this._doc.replaceChild(docType, oldDocType);
          }
          if (attributes && !(0, util_1.isEmpty)(attributes)) {
            builder.att(attributes);
          }
          return builder;
        }
        /** @inheritdoc */
        remove() {
          const parent = this.up();
          parent.node.removeChild(this.node);
          return parent;
        }
        /** @inheritdoc */
        att(p1, p2, p3) {
          if ((0, util_1.isMap)(p1) || (0, util_1.isObject)(p1)) {
            (0, util_1.forEachObject)(p1, (attName, attValue) => this.att(attName, attValue), this);
            return this;
          }
          if (p1 !== void 0 && p1 !== null)
            p1 = (0, util_1.getValue)(p1 + "");
          if (p2 !== void 0 && p2 !== null)
            p2 = (0, util_1.getValue)(p2 + "");
          if (p3 !== void 0 && p3 !== null)
            p3 = (0, util_1.getValue)(p3 + "");
          let namespace;
          let name;
          let value;
          if ((p1 === null || (0, util_1.isString)(p1)) && (0, util_1.isString)(p2) && (p3 === null || (0, util_1.isString)(p3))) {
            [namespace, name, value] = [p1, p2, p3];
          } else if ((0, util_1.isString)(p1) && (p2 == null || (0, util_1.isString)(p2))) {
            [namespace, name, value] = [void 0, p1, p2];
          } else {
            throw new Error("Attribute name and value not specified. " + this._debugInfo());
          }
          if (this._options.keepNullAttributes && value == null) {
            value = "";
          } else if (value == null) {
            return this;
          }
          if (!util_2.Guard.isElementNode(this.node)) {
            throw new Error("An attribute can only be assigned to an element node.");
          }
          let ele = this.node;
          [namespace, name] = this._extractNamespace(namespace, name, false);
          name = (0, dom_1.sanitizeInput)(name, this._options.invalidCharReplacement);
          namespace = (0, dom_1.sanitizeInput)(namespace, this._options.invalidCharReplacement);
          value = (0, dom_1.sanitizeInput)(value, this._options.invalidCharReplacement);
          const [prefix, localName] = (0, algorithm_1.namespace_extractQName)(name);
          const [elePrefix] = (0, algorithm_1.namespace_extractQName)(ele.prefix ? ele.prefix + ":" + ele.localName : ele.localName);
          let eleNamespace = null;
          if (prefix === "xmlns") {
            namespace = infra_1.namespace.XMLNS;
            if (ele.namespaceURI === null && elePrefix === localName) {
              eleNamespace = value;
            }
          } else if (prefix === null && localName === "xmlns" && elePrefix === null) {
            namespace = infra_1.namespace.XMLNS;
            eleNamespace = value;
          }
          if (eleNamespace !== null) {
            this._updateNamespace(eleNamespace);
            ele = this.node;
          }
          if (namespace !== void 0) {
            ele.setAttributeNS(namespace, name, value);
          } else {
            ele.setAttribute(name, value);
          }
          return this;
        }
        /** @inheritdoc */
        removeAtt(p1, p2) {
          if (!util_2.Guard.isElementNode(this.node)) {
            throw new Error("An attribute can only be removed from an element node.");
          }
          p1 = (0, util_1.getValue)(p1);
          if (p2 !== void 0) {
            p2 = (0, util_1.getValue)(p2);
          }
          let namespace;
          let name;
          if (p1 !== null && p2 === void 0) {
            name = p1;
          } else if ((p1 === null || (0, util_1.isString)(p1)) && p2 !== void 0) {
            namespace = p1;
            name = p2;
          } else {
            throw new Error("Attribute namespace must be a string. " + this._debugInfo());
          }
          if ((0, util_1.isArray)(name) || (0, util_1.isSet)(name)) {
            (0, util_1.forEachArray)(name, (attName) => namespace === void 0 ? this.removeAtt(attName) : this.removeAtt(namespace, attName), this);
          } else if (namespace !== void 0) {
            name = (0, dom_1.sanitizeInput)(name, this._options.invalidCharReplacement);
            namespace = (0, dom_1.sanitizeInput)(namespace, this._options.invalidCharReplacement);
            this.node.removeAttributeNS(namespace, name);
          } else {
            name = (0, dom_1.sanitizeInput)(name, this._options.invalidCharReplacement);
            this.node.removeAttribute(name);
          }
          return this;
        }
        /** @inheritdoc */
        txt(content) {
          if (content === null || content === void 0) {
            if (this._options.keepNullNodes) {
              content = "";
            } else {
              return this;
            }
          }
          const child = this._doc.createTextNode((0, dom_1.sanitizeInput)(content, this._options.invalidCharReplacement));
          this.node.appendChild(child);
          return this;
        }
        /** @inheritdoc */
        com(content) {
          if (content === null || content === void 0) {
            if (this._options.keepNullNodes) {
              content = "";
            } else {
              return this;
            }
          }
          const child = this._doc.createComment((0, dom_1.sanitizeInput)(content, this._options.invalidCharReplacement));
          this.node.appendChild(child);
          return this;
        }
        /** @inheritdoc */
        dat(content) {
          if (content === null || content === void 0) {
            if (this._options.keepNullNodes) {
              content = "";
            } else {
              return this;
            }
          }
          const child = this._doc.createCDATASection((0, dom_1.sanitizeInput)(content, this._options.invalidCharReplacement));
          this.node.appendChild(child);
          return this;
        }
        /** @inheritdoc */
        ins(target, content = "") {
          if (content === null || content === void 0) {
            if (this._options.keepNullNodes) {
              content = "";
            } else {
              return this;
            }
          }
          if ((0, util_1.isArray)(target) || (0, util_1.isSet)(target)) {
            (0, util_1.forEachArray)(target, (item) => {
              item += "";
              const insIndex = item.indexOf(" ");
              const insTarget = insIndex === -1 ? item : item.substr(0, insIndex);
              const insValue = insIndex === -1 ? "" : item.substr(insIndex + 1);
              this.ins(insTarget, insValue);
            }, this);
          } else if ((0, util_1.isMap)(target) || (0, util_1.isObject)(target)) {
            (0, util_1.forEachObject)(target, (insTarget, insValue) => this.ins(insTarget, insValue), this);
          } else {
            const child = this._doc.createProcessingInstruction((0, dom_1.sanitizeInput)(target, this._options.invalidCharReplacement), (0, dom_1.sanitizeInput)(content, this._options.invalidCharReplacement));
            this.node.appendChild(child);
          }
          return this;
        }
        /** @inheritdoc */
        dec(options) {
          this._options.version = options.version || "1.0";
          this._options.encoding = options.encoding;
          this._options.standalone = options.standalone;
          return this;
        }
        /** @inheritdoc */
        dtd(options) {
          const name = (0, dom_1.sanitizeInput)(options && options.name || (this._doc.documentElement ? this._doc.documentElement.tagName : "ROOT"), this._options.invalidCharReplacement);
          const pubID = (0, dom_1.sanitizeInput)(options && options.pubID || "", this._options.invalidCharReplacement);
          const sysID = (0, dom_1.sanitizeInput)(options && options.sysID || "", this._options.invalidCharReplacement);
          if (this._doc.documentElement !== null && name !== this._doc.documentElement.tagName) {
            throw new Error("DocType name does not match document element name.");
          }
          const docType = this._doc.implementation.createDocumentType(name, pubID, sysID);
          if (this._doc.doctype !== null) {
            this._doc.replaceChild(docType, this._doc.doctype);
          } else {
            this._doc.insertBefore(docType, this._doc.documentElement);
          }
          return this;
        }
        /** @inheritdoc */
        import(node) {
          const hostNode = this._domNode;
          const hostDoc = this._doc;
          const importedNode = node.node;
          const updateImportedNodeNs = (clone) => {
            if (!clone._namespace) {
              const [prefix] = (0, algorithm_1.namespace_extractQName)(clone.prefix ? clone.prefix + ":" + clone.localName : clone.localName);
              const namespace = hostNode.lookupNamespaceURI(prefix);
              new _XMLBuilderImpl(clone)._updateNamespace(namespace);
            }
          };
          if (util_2.Guard.isDocumentNode(importedNode)) {
            const elementNode = importedNode.documentElement;
            if (elementNode === null) {
              throw new Error("Imported document has no document element node. " + this._debugInfo());
            }
            const clone = hostDoc.importNode(elementNode, true);
            hostNode.appendChild(clone);
            updateImportedNodeNs(clone);
          } else if (util_2.Guard.isDocumentFragmentNode(importedNode)) {
            for (const childNode of importedNode.childNodes) {
              const clone = hostDoc.importNode(childNode, true);
              hostNode.appendChild(clone);
              if (util_2.Guard.isElementNode(clone)) {
                updateImportedNodeNs(clone);
              }
            }
          } else {
            const clone = hostDoc.importNode(importedNode, true);
            hostNode.appendChild(clone);
            if (util_2.Guard.isElementNode(clone)) {
              updateImportedNodeNs(clone);
            }
          }
          return this;
        }
        /** @inheritdoc */
        doc() {
          if (this._doc._isFragment) {
            let node = this.node;
            while (node && node.nodeType !== interfaces_2.NodeType.DocumentFragment) {
              node = node.parentNode;
            }
            if (node === null) {
              throw new Error("Node has no parent node while searching for document fragment ancestor. " + this._debugInfo());
            }
            return new _XMLBuilderImpl(node);
          } else {
            return new _XMLBuilderImpl(this._doc);
          }
        }
        /** @inheritdoc */
        root() {
          const ele = this._doc.documentElement;
          if (!ele) {
            throw new Error("Document root element is null. " + this._debugInfo());
          }
          return new _XMLBuilderImpl(ele);
        }
        /** @inheritdoc */
        up() {
          const parent = this._domNode.parentNode;
          if (!parent) {
            throw new Error("Parent node is null. " + this._debugInfo());
          }
          return new _XMLBuilderImpl(parent);
        }
        /** @inheritdoc */
        prev() {
          const node = this._domNode.previousSibling;
          if (!node) {
            throw new Error("Previous sibling node is null. " + this._debugInfo());
          }
          return new _XMLBuilderImpl(node);
        }
        /** @inheritdoc */
        next() {
          const node = this._domNode.nextSibling;
          if (!node) {
            throw new Error("Next sibling node is null. " + this._debugInfo());
          }
          return new _XMLBuilderImpl(node);
        }
        /** @inheritdoc */
        first() {
          const node = this._domNode.firstChild;
          if (!node) {
            throw new Error("First child node is null. " + this._debugInfo());
          }
          return new _XMLBuilderImpl(node);
        }
        /** @inheritdoc */
        last() {
          const node = this._domNode.lastChild;
          if (!node) {
            throw new Error("Last child node is null. " + this._debugInfo());
          }
          return new _XMLBuilderImpl(node);
        }
        /** @inheritdoc */
        each(callback, self2 = false, recursive = false, thisArg) {
          let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
          while (result[0]) {
            const nextResult = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
            callback.call(thisArg, new _XMLBuilderImpl(result[0]), result[1], result[2]);
            result = nextResult;
          }
          return this;
        }
        /** @inheritdoc */
        map(callback, self2 = false, recursive = false, thisArg) {
          let result = [];
          this.each((node, index, level) => result.push(callback.call(thisArg, node, index, level)), self2, recursive);
          return result;
        }
        /** @inheritdoc */
        reduce(callback, initialValue, self2 = false, recursive = false, thisArg) {
          let value = initialValue;
          this.each((node, index, level) => value = callback.call(thisArg, value, node, index, level), self2, recursive);
          return value;
        }
        /** @inheritdoc */
        find(predicate, self2 = false, recursive = false, thisArg) {
          let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
          while (result[0]) {
            const builder = new _XMLBuilderImpl(result[0]);
            if (predicate.call(thisArg, builder, result[1], result[2])) {
              return builder;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
          }
          return void 0;
        }
        /** @inheritdoc */
        filter(predicate, self2 = false, recursive = false, thisArg) {
          let result = [];
          this.each((node, index, level) => {
            if (predicate.call(thisArg, node, index, level)) {
              result.push(node);
            }
          }, self2, recursive);
          return result;
        }
        /** @inheritdoc */
        every(predicate, self2 = false, recursive = false, thisArg) {
          let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
          while (result[0]) {
            const builder = new _XMLBuilderImpl(result[0]);
            if (!predicate.call(thisArg, builder, result[1], result[2])) {
              return false;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
          }
          return true;
        }
        /** @inheritdoc */
        some(predicate, self2 = false, recursive = false, thisArg) {
          let result = this._getFirstDescendantNode(this._domNode, self2, recursive);
          while (result[0]) {
            const builder = new _XMLBuilderImpl(result[0]);
            if (predicate.call(thisArg, builder, result[1], result[2])) {
              return true;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
          }
          return false;
        }
        /** @inheritdoc */
        toArray(self2 = false, recursive = false) {
          let result = [];
          this.each((node) => result.push(node), self2, recursive);
          return result;
        }
        /** @inheritdoc */
        toString(writerOptions) {
          writerOptions = writerOptions || {};
          if (writerOptions.format === void 0) {
            writerOptions.format = "xml";
          }
          return this._serialize(writerOptions);
        }
        /** @inheritdoc */
        toObject(writerOptions) {
          writerOptions = writerOptions || {};
          if (writerOptions.format === void 0) {
            writerOptions.format = "object";
          }
          return this._serialize(writerOptions);
        }
        /** @inheritdoc */
        end(writerOptions) {
          writerOptions = writerOptions || {};
          if (writerOptions.format === void 0) {
            writerOptions.format = "xml";
          }
          return this.doc()._serialize(writerOptions);
        }
        /**
         * Gets the next descendant of the given node of the tree rooted at `root`
         * in depth-first pre-order. Returns a three-tuple with
         * [descendant, descendant_index, descendant_level].
         *
         * @param root - root node of the tree
         * @param self - whether to visit the current node along with child nodes
         * @param recursive - whether to visit all descendant nodes in tree-order or
         * only the immediate child nodes
         */
        _getFirstDescendantNode(root, self2, recursive) {
          if (self2)
            return [this._domNode, 0, 0];
          else if (recursive)
            return this._getNextDescendantNode(root, root, recursive, 0, 0);
          else
            return [this._domNode.firstChild, 0, 1];
        }
        /**
         * Gets the next descendant of the given node of the tree rooted at `root`
         * in depth-first pre-order. Returns a three-tuple with
         * [descendant, descendant_index, descendant_level].
         *
         * @param root - root node of the tree
         * @param node - current node
         * @param recursive - whether to visit all descendant nodes in tree-order or
         * only the immediate child nodes
         * @param index - child node index
         * @param level - current depth of the XML tree
         */
        _getNextDescendantNode(root, node, recursive, index, level) {
          if (recursive) {
            if (node.firstChild)
              return [node.firstChild, 0, level + 1];
            if (node === root)
              return [null, -1, -1];
            if (node.nextSibling)
              return [node.nextSibling, index + 1, level];
            let parent = node.parentNode;
            while (parent && parent !== root) {
              if (parent.nextSibling)
                return [parent.nextSibling, (0, algorithm_1.tree_index)(parent.nextSibling), level - 1];
              parent = parent.parentNode;
              level--;
            }
          } else {
            if (root === node)
              return [node.firstChild, 0, level + 1];
            else
              return [node.nextSibling, index + 1, level];
          }
          return [null, -1, -1];
        }
        /**
         * Converts the node into its string or object representation.
         *
         * @param options - serialization options
         */
        _serialize(writerOptions) {
          if (writerOptions.format === "xml") {
            const writer = new writers_1.XMLWriter(this._options, writerOptions);
            return writer.serialize(this.node);
          } else if (writerOptions.format === "map") {
            const writer = new writers_1.MapWriter(this._options, writerOptions);
            return writer.serialize(this.node);
          } else if (writerOptions.format === "object") {
            const writer = new writers_1.ObjectWriter(this._options, writerOptions);
            return writer.serialize(this.node);
          } else if (writerOptions.format === "json") {
            const writer = new writers_1.JSONWriter(this._options, writerOptions);
            return writer.serialize(this.node);
          } else if (writerOptions.format === "yaml") {
            const writer = new writers_1.YAMLWriter(this._options, writerOptions);
            return writer.serialize(this.node);
          } else {
            throw new Error("Invalid writer format: " + writerOptions.format + ". " + this._debugInfo());
          }
        }
        /**
         * Extracts a namespace and name from the given string.
         *
         * @param namespace - namespace
         * @param name - a string containing both a name and namespace separated by an
         * `'@'` character
         * @param ele - `true` if this is an element namespace; otherwise `false`
         */
        _extractNamespace(namespace, name, ele) {
          const atIndex = name.indexOf("@");
          if (atIndex > 0) {
            if (namespace === void 0)
              namespace = name.slice(atIndex + 1);
            name = name.slice(0, atIndex);
          }
          if (namespace === void 0) {
            namespace = ele ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att;
          } else if (namespace !== null && namespace[0] === "@") {
            const alias = namespace.slice(1);
            namespace = this._options.namespaceAlias[alias];
            if (namespace === void 0) {
              throw new Error("Namespace alias `" + alias + "` is not defined. " + this._debugInfo());
            }
          }
          return [namespace, name];
        }
        /**
         * Updates the element's namespace.
         *
         * @param ns - new namespace
         */
        _updateNamespace(ns) {
          const ele = this._domNode;
          if (util_2.Guard.isElementNode(ele) && ns !== null && ele.namespaceURI !== ns) {
            const [elePrefix, eleLocalName] = (0, algorithm_1.namespace_extractQName)(ele.prefix ? ele.prefix + ":" + ele.localName : ele.localName);
            const newEle = (0, algorithm_1.create_element)(this._doc, eleLocalName, ns, elePrefix);
            for (const attr of ele.attributes) {
              const attrQName = attr.prefix ? attr.prefix + ":" + attr.localName : attr.localName;
              const [attrPrefix] = (0, algorithm_1.namespace_extractQName)(attrQName);
              let newAttrNS = attr.namespaceURI;
              if (newAttrNS === null && attrPrefix !== null) {
                newAttrNS = ele.lookupNamespaceURI(attrPrefix);
              }
              if (newAttrNS === null) {
                newEle.setAttribute(attrQName, attr.value);
              } else {
                newEle.setAttributeNS(newAttrNS, attrQName, attr.value);
              }
            }
            const parent = ele.parentNode;
            if (parent === null) {
              throw new Error("Parent node is null." + this._debugInfo());
            }
            parent.replaceChild(newEle, ele);
            this._domNode = newEle;
            for (const childNode of ele.childNodes) {
              const newChildNode = childNode.cloneNode(true);
              newEle.appendChild(newChildNode);
              if (util_2.Guard.isElementNode(newChildNode) && !newChildNode._namespace) {
                const [newChildNodePrefix] = (0, algorithm_1.namespace_extractQName)(newChildNode.prefix ? newChildNode.prefix + ":" + newChildNode.localName : newChildNode.localName);
                const newChildNodeNS = newEle.lookupNamespaceURI(newChildNodePrefix);
                new _XMLBuilderImpl(newChildNode)._updateNamespace(newChildNodeNS);
              }
            }
          }
        }
        /**
         * Returns the document owning this node.
         */
        get _doc() {
          const node = this.node;
          if (util_2.Guard.isDocumentNode(node)) {
            return node;
          } else {
            const docNode = node.ownerDocument;
            if (!docNode)
              throw new Error("Owner document is null. " + this._debugInfo());
            return docNode;
          }
        }
        /**
         * Returns debug information for this node.
         *
         * @param name - node name
         */
        _debugInfo(name) {
          const node = this.node;
          const parentNode = node.parentNode;
          name = name || node.nodeName;
          const parentName = parentNode ? parentNode.nodeName : "";
          if (!parentName) {
            return "node: <" + name + ">";
          } else {
            return "node: <" + name + ">, parent: <" + parentName + ">";
          }
        }
        /**
         * Gets or sets builder options.
         */
        get _options() {
          const doc = this._doc;
          if (doc._xmlBuilderOptions === void 0) {
            throw new Error("Builder options is not set.");
          }
          return doc._xmlBuilderOptions;
        }
        set _options(value) {
          const doc = this._doc;
          doc._xmlBuilderOptions = value;
        }
      };
      exports.XMLBuilderImpl = XMLBuilderImpl;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/BuilderFunctions.js
  var require_BuilderFunctions = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/BuilderFunctions.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.builder = builder;
      exports.create = create2;
      exports.fragment = fragment3;
      exports.convert = convert;
      var interfaces_1 = require_interfaces();
      var util_1 = require_lib4();
      var util_2 = require_util2();
      var _1 = require_builder();
      var dom_1 = require_dom2();
      function builder(p1, p2) {
        const options = formatBuilderOptions(isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
        const nodes = util_2.Guard.isNode(p1) || (0, util_1.isArray)(p1) ? p1 : p2;
        if (nodes === void 0) {
          throw new Error("Invalid arguments.");
        }
        if ((0, util_1.isArray)(nodes)) {
          const builders = [];
          for (let i = 0; i < nodes.length; i++) {
            const builder2 = new _1.XMLBuilderImpl(nodes[i]);
            builder2.set(options);
            builders.push(builder2);
          }
          return builders;
        } else {
          const builder2 = new _1.XMLBuilderImpl(nodes);
          builder2.set(options);
          return builder2;
        }
      }
      function create2(p1, p2) {
        const options = formatBuilderOptions(p1 === void 0 || isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
        const contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
        const doc = (0, dom_1.createDocument)();
        setOptions(doc, options);
        const builder2 = new _1.XMLBuilderImpl(doc);
        if (contents !== void 0) {
          builder2.ele(contents);
        }
        return builder2;
      }
      function fragment3(p1, p2) {
        const options = formatBuilderOptions(p1 === void 0 || isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
        const contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
        const doc = (0, dom_1.createDocument)();
        setOptions(doc, options, true);
        const builder2 = new _1.XMLBuilderImpl(doc.createDocumentFragment());
        if (contents !== void 0) {
          builder2.ele(contents);
        }
        return builder2;
      }
      function convert(p1, p2, p3) {
        let builderOptions;
        let contents;
        let convertOptions;
        if (isXMLBuilderCreateOptions(p1) && p2 !== void 0) {
          builderOptions = p1;
          contents = p2;
          convertOptions = p3;
        } else {
          builderOptions = interfaces_1.DefaultBuilderOptions;
          contents = p1;
          convertOptions = p2 || void 0;
        }
        return create2(builderOptions, contents).end(convertOptions);
      }
      function isXMLBuilderCreateOptions(obj) {
        if (!(0, util_1.isPlainObject)(obj))
          return false;
        for (const key in obj) {
          if (obj.hasOwnProperty(key)) {
            if (!interfaces_1.XMLBuilderOptionKeys.has(key))
              return false;
          }
        }
        return true;
      }
      function formatBuilderOptions(createOptions = {}) {
        const options = (0, util_1.applyDefaults)(createOptions, interfaces_1.DefaultBuilderOptions);
        if (options.convert.att.length === 0 || options.convert.ins.length === 0 || options.convert.text.length === 0 || options.convert.cdata.length === 0 || options.convert.comment.length === 0) {
          throw new Error("JS object converter strings cannot be zero length.");
        }
        return options;
      }
      function setOptions(doc, options, isFragment) {
        const docWithSettings = doc;
        docWithSettings._xmlBuilderOptions = options;
        docWithSettings._isFragment = isFragment;
      }
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/BaseCBWriter.js
  var require_BaseCBWriter = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/BaseCBWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseCBWriter = void 0;
      var BaseCBWriter = class {
        /**
         * Initializes a new instance of `BaseCBWriter`.
         *
         * @param builderOptions - XML builder options
         */
        constructor(builderOptions) {
          __publicField(this, "_builderOptions");
          __publicField(this, "_writerOptions");
          /**
           * Gets the current depth of the XML tree.
           */
          __publicField(this, "level", 0);
          /**
           * Determines whether any data has been written.
           */
          __publicField(this, "hasData");
          this._builderOptions = builderOptions;
          this._writerOptions = builderOptions;
        }
      };
      exports.BaseCBWriter = BaseCBWriter;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/XMLCBWriter.js
  var require_XMLCBWriter = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/XMLCBWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLCBWriter = void 0;
      var BaseCBWriter_1 = require_BaseCBWriter();
      var XMLCBWriter = class extends BaseCBWriter_1.BaseCBWriter {
        /**
         * Initializes a new instance of `XMLCBWriter`.
         *
         * @param builderOptions - XML builder options
         */
        constructor(builderOptions) {
          super(builderOptions);
          __publicField(this, "_lineLength", 0);
        }
        /** @inheritdoc */
        frontMatter() {
          return "";
        }
        /** @inheritdoc */
        declaration(version, encoding, standalone) {
          let markup = this._beginLine() + "<?xml";
          markup += ' version="' + version + '"';
          if (encoding !== void 0) {
            markup += ' encoding="' + encoding + '"';
          }
          if (standalone !== void 0) {
            markup += ' standalone="' + (standalone ? "yes" : "no") + '"';
          }
          markup += "?>";
          return markup;
        }
        /** @inheritdoc */
        docType(name, publicId, systemId) {
          let markup = this._beginLine();
          if (publicId && systemId) {
            markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '" "' + systemId + '">';
          } else if (publicId) {
            markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '">';
          } else if (systemId) {
            markup += "<!DOCTYPE " + name + ' SYSTEM "' + systemId + '">';
          } else {
            markup += "<!DOCTYPE " + name + ">";
          }
          return markup;
        }
        /** @inheritdoc */
        comment(data) {
          return this._beginLine() + "<!--" + data + "-->";
        }
        /** @inheritdoc */
        text(data) {
          return data;
        }
        /** @inheritdoc */
        instruction(target, data) {
          if (data) {
            return this._beginLine() + "<?" + target + " " + data + "?>";
          } else {
            return this._beginLine() + "<?" + target + "?>";
          }
        }
        /** @inheritdoc */
        cdata(data) {
          return this._beginLine() + "<![CDATA[" + data + "]]>";
        }
        /** @inheritdoc */
        openTagBegin(name) {
          this._lineLength += 1 + name.length;
          return this._beginLine() + "<" + name;
        }
        /** @inheritdoc */
        openTagEnd(name, selfClosing, voidElement) {
          if (voidElement) {
            return " />";
          } else if (selfClosing) {
            if (this._writerOptions.allowEmptyTags) {
              return "></" + name + ">";
            } else if (this._writerOptions.spaceBeforeSlash) {
              return " />";
            } else {
              return "/>";
            }
          } else {
            return ">";
          }
        }
        /** @inheritdoc */
        closeTag(name, hasTextPayload) {
          const ending = hasTextPayload ? "" : this._beginLine();
          return ending + "</" + name + ">";
        }
        /** @inheritdoc */
        attribute(name, value) {
          let str = name + '="' + value + '"';
          if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._lineLength + 1 + str.length > this._writerOptions.width) {
            str = this._beginLine() + this._indent(1) + str;
            this._lineLength = str.length;
            return str;
          } else {
            this._lineLength += 1 + str.length;
            return " " + str;
          }
        }
        /** @inheritdoc */
        beginElement(name) {
        }
        /** @inheritdoc */
        endElement(name) {
        }
        /**
         * Produces characters to be prepended to a line of string in pretty-print
         * mode.
         */
        _beginLine() {
          if (this._writerOptions.prettyPrint) {
            const str = (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level);
            this._lineLength = str.length;
            return str;
          } else {
            return "";
          }
        }
        /**
         * Produces an indentation string.
         *
         * @param level - depth of the tree
         */
        _indent(level) {
          if (level <= 0) {
            return "";
          } else {
            return this._writerOptions.indent.repeat(level);
          }
        }
      };
      exports.XMLCBWriter = XMLCBWriter;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/JSONCBWriter.js
  var require_JSONCBWriter = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/JSONCBWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.JSONCBWriter = void 0;
      var BaseCBWriter_1 = require_BaseCBWriter();
      var JSONCBWriter = class extends BaseCBWriter_1.BaseCBWriter {
        /**
         * Initializes a new instance of `JSONCBWriter`.
         *
         * @param builderOptions - XML builder options
         */
        constructor(builderOptions) {
          super(builderOptions);
          __publicField(this, "_hasChildren", []);
          __publicField(this, "_additionalLevel", 0);
        }
        /** @inheritdoc */
        frontMatter() {
          return "";
        }
        /** @inheritdoc */
        declaration(version, encoding, standalone) {
          return "";
        }
        /** @inheritdoc */
        docType(name, publicId, systemId) {
          return "";
        }
        /** @inheritdoc */
        comment(data) {
          return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.comment) + this._sep() + this._val(data) + this._sep() + "}";
        }
        /** @inheritdoc */
        text(data) {
          return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.text) + this._sep() + this._val(data) + this._sep() + "}";
        }
        /** @inheritdoc */
        instruction(target, data) {
          return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.ins) + this._sep() + this._val(data ? target + " " + data : target) + this._sep() + "}";
        }
        /** @inheritdoc */
        cdata(data) {
          return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.cdata) + this._sep() + this._val(data) + this._sep() + "}";
        }
        /** @inheritdoc */
        attribute(name, value) {
          return this._comma() + this._beginLine(1) + "{" + this._sep() + this._key(this._builderOptions.convert.att + name) + this._sep() + this._val(value) + this._sep() + "}";
        }
        /** @inheritdoc */
        openTagBegin(name) {
          let str = this._comma() + this._beginLine() + "{" + this._sep() + this._key(name) + this._sep() + "{";
          this._additionalLevel++;
          this.hasData = true;
          str += this._beginLine() + this._key(this._builderOptions.convert.text) + this._sep() + "[";
          this._hasChildren.push(false);
          return str;
        }
        /** @inheritdoc */
        openTagEnd(name, selfClosing, voidElement) {
          if (selfClosing) {
            let str = this._sep() + "]";
            this._additionalLevel--;
            str += this._beginLine() + "}" + this._sep() + "}";
            return str;
          } else {
            return "";
          }
        }
        /** @inheritdoc */
        closeTag(name) {
          let str = this._beginLine() + "]";
          this._additionalLevel--;
          str += this._beginLine() + "}" + this._sep() + "}";
          return str;
        }
        /** @inheritdoc */
        beginElement(name) {
        }
        /** @inheritdoc */
        endElement(name) {
          this._hasChildren.pop();
        }
        /**
         * Produces characters to be prepended to a line of string in pretty-print
         * mode.
         */
        _beginLine(additionalOffset = 0) {
          if (this._writerOptions.prettyPrint) {
            return (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level + additionalOffset);
          } else {
            return "";
          }
        }
        /**
         * Produces an indentation string.
         *
         * @param level - depth of the tree
         */
        _indent(level) {
          if (level + this._additionalLevel <= 0) {
            return "";
          } else {
            return this._writerOptions.indent.repeat(level + this._additionalLevel);
          }
        }
        /**
         * Produces a comma before a child node if it has previous siblings.
         */
        _comma() {
          const str = this._hasChildren[this._hasChildren.length - 1] ? "," : "";
          if (this._hasChildren.length > 0) {
            this._hasChildren[this._hasChildren.length - 1] = true;
          }
          return str;
        }
        /**
         * Produces a separator string.
         */
        _sep() {
          return this._writerOptions.prettyPrint ? " " : "";
        }
        /**
         * Produces a JSON key string delimited with double quotes.
         */
        _key(key) {
          return '"' + key + '":';
        }
        /**
         * Produces a JSON value string delimited with double quotes.
         */
        _val(val) {
          return JSON.stringify(val);
        }
      };
      exports.JSONCBWriter = JSONCBWriter;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/YAMLCBWriter.js
  var require_YAMLCBWriter = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/writers/YAMLCBWriter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.YAMLCBWriter = void 0;
      var BaseCBWriter_1 = require_BaseCBWriter();
      var YAMLCBWriter = class extends BaseCBWriter_1.BaseCBWriter {
        /**
         * Initializes a new instance of `BaseCBWriter`.
         *
         * @param builderOptions - XML builder options
         */
        constructor(builderOptions) {
          super(builderOptions);
          __publicField(this, "_rootWritten", false);
          __publicField(this, "_additionalLevel", 0);
          if (builderOptions.indent.length < 2) {
            throw new Error("YAML indententation string must be at least two characters long.");
          }
          if (builderOptions.offset < 0) {
            throw new Error("YAML offset should be zero or a positive number.");
          }
        }
        /** @inheritdoc */
        frontMatter() {
          return this._beginLine() + "---";
        }
        /** @inheritdoc */
        declaration(version, encoding, standalone) {
          return "";
        }
        /** @inheritdoc */
        docType(name, publicId, systemId) {
          return "";
        }
        /** @inheritdoc */
        comment(data) {
          return this._beginLine() + this._key(this._builderOptions.convert.comment) + " " + this._val(data);
        }
        /** @inheritdoc */
        text(data) {
          return this._beginLine() + this._key(this._builderOptions.convert.text) + " " + this._val(data);
        }
        /** @inheritdoc */
        instruction(target, data) {
          return this._beginLine() + this._key(this._builderOptions.convert.ins) + " " + this._val(data ? target + " " + data : target);
        }
        /** @inheritdoc */
        cdata(data) {
          return this._beginLine() + this._key(this._builderOptions.convert.cdata) + " " + this._val(data);
        }
        /** @inheritdoc */
        attribute(name, value) {
          this._additionalLevel++;
          const str = this._beginLine() + this._key(this._builderOptions.convert.att + name) + " " + this._val(value);
          this._additionalLevel--;
          return str;
        }
        /** @inheritdoc */
        openTagBegin(name) {
          let str = this._beginLine() + this._key(name);
          if (!this._rootWritten) {
            this._rootWritten = true;
          }
          this.hasData = true;
          this._additionalLevel++;
          str += this._beginLine(true) + this._key(this._builderOptions.convert.text);
          return str;
        }
        /** @inheritdoc */
        openTagEnd(name, selfClosing, voidElement) {
          if (selfClosing) {
            return " " + this._val("");
          }
          return "";
        }
        /** @inheritdoc */
        closeTag(name) {
          this._additionalLevel--;
          return "";
        }
        /** @inheritdoc */
        beginElement(name) {
        }
        /** @inheritdoc */
        endElement(name) {
        }
        /**
         * Produces characters to be prepended to a line of string in pretty-print
         * mode.
         */
        _beginLine(suppressArray = false) {
          return (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level, suppressArray);
        }
        /**
         * Produces an indentation string.
         *
         * @param level - depth of the tree
         * @param suppressArray - whether the suppress array marker
         */
        _indent(level, suppressArray) {
          if (level + this._additionalLevel <= 0) {
            return "";
          } else {
            const chars = this._writerOptions.indent.repeat(level + this._additionalLevel);
            if (!suppressArray && this._rootWritten) {
              return chars.substr(0, chars.length - 2) + "-" + chars.substr(-1, 1);
            }
            return chars;
          }
        }
        /**
         * Produces a YAML key string delimited with double quotes.
         */
        _key(key) {
          return '"' + key + '":';
        }
        /**
         * Produces a YAML value string delimited with double quotes.
         */
        _val(val) {
          return JSON.stringify(val);
        }
      };
      exports.YAMLCBWriter = YAMLCBWriter;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/XMLBuilderCBImpl.js
  var require_XMLBuilderCBImpl = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/XMLBuilderCBImpl.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XMLBuilderCBImpl = void 0;
      var interfaces_1 = require_interfaces();
      var util_1 = require_lib4();
      var BuilderFunctions_1 = require_BuilderFunctions();
      var algorithm_1 = require_algorithm();
      var infra_1 = require_lib5();
      var NamespacePrefixMap_1 = require_NamespacePrefixMap();
      var LocalNameSet_1 = require_LocalNameSet();
      var util_2 = require_util2();
      var XMLCBWriter_1 = require_XMLCBWriter();
      var JSONCBWriter_1 = require_JSONCBWriter();
      var YAMLCBWriter_1 = require_YAMLCBWriter();
      var events_1 = __require("events");
      var _XMLBuilderCBImpl = class _XMLBuilderCBImpl extends events_1.EventEmitter {
        /**
         * Initializes a new instance of `XMLStream`.
         *
         * @param options - stream writer options
         * @param fragment - whether to create fragment stream or a document stream
         *
         * @returns XML stream
         */
        constructor(options, fragment3 = false) {
          super();
          __publicField(this, "_options");
          __publicField(this, "_builderOptions");
          __publicField(this, "_writer");
          __publicField(this, "_fragment");
          __publicField(this, "_hasDeclaration", false);
          __publicField(this, "_docTypeName", "");
          __publicField(this, "_hasDocumentElement", false);
          __publicField(this, "_currentElement");
          __publicField(this, "_currentElementSerialized", false);
          __publicField(this, "_openTags", []);
          __publicField(this, "_prefixMap");
          __publicField(this, "_prefixIndex");
          __publicField(this, "_ended", false);
          this._fragment = fragment3;
          this._options = (0, util_1.applyDefaults)(options || {}, interfaces_1.DefaultXMLBuilderCBOptions);
          this._builderOptions = {
            defaultNamespace: this._options.defaultNamespace,
            namespaceAlias: this._options.namespaceAlias
          };
          if (this._options.format === "json") {
            this._writer = new JSONCBWriter_1.JSONCBWriter(this._options);
          } else if (this._options.format === "yaml") {
            this._writer = new YAMLCBWriter_1.YAMLCBWriter(this._options);
          } else {
            this._writer = new XMLCBWriter_1.XMLCBWriter(this._options);
          }
          if (this._options.data !== void 0) {
            this.on("data", this._options.data);
          }
          if (this._options.end !== void 0) {
            this.on("end", this._options.end);
          }
          if (this._options.error !== void 0) {
            this.on("error", this._options.error);
          }
          this._prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
          this._prefixMap.set("xml", infra_1.namespace.XML);
          this._prefixIndex = { value: 1 };
          this._push(this._writer.frontMatter());
        }
        /** @inheritdoc */
        ele(p1, p2, p3) {
          if ((0, util_1.isObject)(p1) || (0, util_1.isString)(p1) && (/^\s*</.test(p1) || /^\s*[\{\[]/.test(p1) || /^(\s*|(#.*)|(%.*))*---/.test(p1))) {
            const frag = (0, BuilderFunctions_1.fragment)().set(this._options);
            try {
              frag.ele(p1);
            } catch (err) {
              this.emit("error", err);
              return this;
            }
            for (const node of frag.node.childNodes) {
              this._fromNode(node);
            }
            return this;
          }
          this._serializeOpenTag(true);
          if (!this._fragment && this._hasDocumentElement && this._writer.level === 0) {
            this.emit("error", new Error("Document cannot have multiple document element nodes."));
            return this;
          }
          try {
            this._currentElement = (0, BuilderFunctions_1.fragment)(this._builderOptions).ele(p1, p2, p3);
          } catch (err) {
            this.emit("error", err);
            return this;
          }
          if (!this._fragment && !this._hasDocumentElement && this._docTypeName !== "" && this._currentElement.node._qualifiedName !== this._docTypeName) {
            this.emit("error", new Error("Document element name does not match DocType declaration name."));
            return this;
          }
          this._currentElementSerialized = false;
          if (!this._fragment) {
            this._hasDocumentElement = true;
          }
          return this;
        }
        /** @inheritdoc */
        att(p1, p2, p3) {
          if (this._currentElement === void 0) {
            this.emit("error", new Error("Cannot insert an attribute node as child of a document node."));
            return this;
          }
          try {
            this._currentElement.att(p1, p2, p3);
          } catch (err) {
            this.emit("error", err);
            return this;
          }
          return this;
        }
        /** @inheritdoc */
        com(content) {
          this._serializeOpenTag(true);
          let node;
          try {
            node = (0, BuilderFunctions_1.fragment)(this._builderOptions).com(content).first().node;
          } catch (err) {
            this.emit("error", err);
            return this;
          }
          if (this._options.wellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            this.emit("error", new Error("Comment data contains invalid characters (well-formed required)."));
            return this;
          }
          this._push(this._writer.comment(node.data));
          return this;
        }
        /** @inheritdoc */
        txt(content) {
          if (!this._fragment && this._currentElement === void 0) {
            this.emit("error", new Error("Cannot insert a text node as child of a document node."));
            return this;
          }
          this._serializeOpenTag(true);
          let node;
          try {
            node = (0, BuilderFunctions_1.fragment)(this._builderOptions).txt(content).first().node;
          } catch (err) {
            this.emit("error", err);
            return this;
          }
          if (this._options.wellFormed && !(0, algorithm_1.xml_isLegalChar)(node.data)) {
            this.emit("error", new Error("Text data contains invalid characters (well-formed required)."));
            return this;
          }
          const markup = node.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          this._push(this._writer.text(markup));
          const lastEl = this._openTags[this._openTags.length - 1];
          if (lastEl) {
            lastEl[lastEl.length - 1] = true;
          }
          return this;
        }
        /** @inheritdoc */
        ins(target, content = "") {
          this._serializeOpenTag(true);
          let node;
          try {
            node = (0, BuilderFunctions_1.fragment)(this._builderOptions).ins(target, content).first().node;
          } catch (err) {
            this.emit("error", err);
            return this;
          }
          if (this._options.wellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
            this.emit("error", new Error("Processing instruction target contains invalid characters (well-formed required)."));
            return this;
          }
          if (this._options.wellFormed && !(0, algorithm_1.xml_isLegalChar)(node.data)) {
            this.emit("error", Error("Processing instruction data contains invalid characters (well-formed required)."));
            return this;
          }
          this._push(this._writer.instruction(node.target, node.data));
          return this;
        }
        /** @inheritdoc */
        dat(content) {
          this._serializeOpenTag(true);
          let node;
          try {
            node = (0, BuilderFunctions_1.fragment)(this._builderOptions).dat(content).first().node;
          } catch (err) {
            this.emit("error", err);
            return this;
          }
          this._push(this._writer.cdata(node.data));
          return this;
        }
        /** @inheritdoc */
        dec(options = { version: "1.0" }) {
          if (this._fragment) {
            this.emit("error", Error("Cannot insert an XML declaration into a document fragment."));
            return this;
          }
          if (this._hasDeclaration) {
            this.emit("error", Error("XML declaration is already inserted."));
            return this;
          }
          this._push(this._writer.declaration(options.version || "1.0", options.encoding, options.standalone));
          this._hasDeclaration = true;
          return this;
        }
        /** @inheritdoc */
        dtd(options) {
          if (this._fragment) {
            this.emit("error", Error("Cannot insert a DocType declaration into a document fragment."));
            return this;
          }
          if (this._docTypeName !== "") {
            this.emit("error", new Error("DocType declaration is already inserted."));
            return this;
          }
          if (this._hasDocumentElement) {
            this.emit("error", new Error("Cannot insert DocType declaration after document element."));
            return this;
          }
          let node;
          try {
            node = (0, BuilderFunctions_1.create)().dtd(options).first().node;
          } catch (err) {
            this.emit("error", err);
            return this;
          }
          if (this._options.wellFormed && !(0, algorithm_1.xml_isPubidChar)(node.publicId)) {
            this.emit("error", new Error("DocType public identifier does not match PubidChar construct (well-formed required)."));
            return this;
          }
          if (this._options.wellFormed && (!(0, algorithm_1.xml_isLegalChar)(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
            this.emit("error", new Error("DocType system identifier contains invalid characters (well-formed required)."));
            return this;
          }
          this._docTypeName = options.name;
          this._push(this._writer.docType(options.name, node.publicId, node.systemId));
          return this;
        }
        /** @inheritdoc */
        import(node) {
          const frag = (0, BuilderFunctions_1.fragment)().set(this._options);
          try {
            frag.import(node);
          } catch (err) {
            this.emit("error", err);
            return this;
          }
          for (const node2 of frag.node.childNodes) {
            this._fromNode(node2);
          }
          return this;
        }
        /** @inheritdoc */
        up() {
          this._serializeOpenTag(false);
          this._serializeCloseTag();
          return this;
        }
        /** @inheritdoc */
        end() {
          this._serializeOpenTag(false);
          while (this._openTags.length > 0) {
            this._serializeCloseTag();
          }
          this._push(null);
          return this;
        }
        /**
         * Serializes the opening tag of an element node.
         *
         * @param hasChildren - whether the element node has child nodes
         */
        _serializeOpenTag(hasChildren) {
          if (this._currentElementSerialized)
            return;
          if (this._currentElement === void 0)
            return;
          const node = this._currentElement.node;
          if (this._options.wellFormed && (node.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(node.localName))) {
            this.emit("error", new Error("Node local name contains invalid characters (well-formed required)."));
            return;
          }
          let qualifiedName = "";
          let ignoreNamespaceDefinitionAttribute = false;
          let map = this._prefixMap.copy();
          let localPrefixesMap = {};
          let localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
          let inheritedNS = this._openTags.length === 0 ? null : this._openTags[this._openTags.length - 1][1];
          let ns = node.namespaceURI;
          if (ns === null)
            ns = inheritedNS;
          if (inheritedNS === ns) {
            if (localDefaultNamespace !== null) {
              ignoreNamespaceDefinitionAttribute = true;
            }
            if (ns === infra_1.namespace.XML) {
              qualifiedName = "xml:" + node.localName;
            } else {
              qualifiedName = node.localName;
            }
            this._writer.beginElement(qualifiedName);
            this._push(this._writer.openTagBegin(qualifiedName));
          } else {
            let prefix = node.prefix;
            let candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
              candidatePrefix = map.get(prefix, ns);
            }
            if (prefix === "xmlns") {
              if (this._options.wellFormed) {
                this.emit("error", new Error("An element cannot have the 'xmlns' prefix (well-formed required)."));
                return;
              }
              candidatePrefix = prefix;
            }
            if (candidatePrefix !== null) {
              qualifiedName = candidatePrefix + ":" + node.localName;
              if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                inheritedNS = localDefaultNamespace || null;
              }
              this._writer.beginElement(qualifiedName);
              this._push(this._writer.openTagBegin(qualifiedName));
            } else if (prefix !== null) {
              if (prefix in localPrefixesMap) {
                prefix = this._generatePrefix(ns, map, this._prefixIndex);
              }
              map.set(prefix, ns);
              qualifiedName += prefix + ":" + node.localName;
              this._writer.beginElement(qualifiedName);
              this._push(this._writer.openTagBegin(qualifiedName));
              this._push(this._writer.attribute("xmlns:" + prefix, this._serializeAttributeValue(ns, this._options.wellFormed)));
              if (localDefaultNamespace !== null) {
                inheritedNS = localDefaultNamespace || null;
              }
            } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
              ignoreNamespaceDefinitionAttribute = true;
              qualifiedName += node.localName;
              inheritedNS = ns;
              this._writer.beginElement(qualifiedName);
              this._push(this._writer.openTagBegin(qualifiedName));
              this._push(this._writer.attribute("xmlns", this._serializeAttributeValue(ns, this._options.wellFormed)));
            } else {
              qualifiedName += node.localName;
              inheritedNS = ns;
              this._writer.beginElement(qualifiedName);
              this._push(this._writer.openTagBegin(qualifiedName));
            }
          }
          this._serializeAttributes(node, map, this._prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, this._options.wellFormed);
          const isHTML = ns === infra_1.namespace.HTML;
          if (isHTML && !hasChildren && _XMLBuilderCBImpl._VoidElementNames.has(node.localName)) {
            this._push(this._writer.openTagEnd(qualifiedName, true, true));
            this._writer.endElement(qualifiedName);
          } else if (!isHTML && !hasChildren) {
            this._push(this._writer.openTagEnd(qualifiedName, true, false));
            this._writer.endElement(qualifiedName);
          } else {
            this._push(this._writer.openTagEnd(qualifiedName, false, false));
          }
          this._currentElementSerialized = true;
          this._openTags.push([qualifiedName, inheritedNS, this._prefixMap, hasChildren, void 0]);
          if (this._isPrefixMapModified(this._prefixMap, map)) {
            this._prefixMap = map;
          }
          this._writer.level++;
        }
        /**
         * Serializes the closing tag of an element node.
         */
        _serializeCloseTag() {
          this._writer.level--;
          const lastEle = this._openTags.pop();
          if (lastEle === void 0) {
            this.emit("error", new Error("Last element is undefined."));
            return;
          }
          const [qualifiedName, ns, map, hasChildren, hasTextPayload] = lastEle;
          this._prefixMap = map;
          if (!hasChildren)
            return;
          this._push(this._writer.closeTag(qualifiedName, hasTextPayload));
          this._writer.endElement(qualifiedName);
        }
        /**
         * Pushes data to internal buffer.
         *
         * @param data - data
         */
        _push(data) {
          if (data === null) {
            this._ended = true;
            this.emit("end");
          } else if (this._ended) {
            this.emit("error", new Error("Cannot push to ended stream."));
          } else if (data.length !== 0) {
            this._writer.hasData = true;
            this.emit("data", data, this._writer.level);
          }
        }
        /**
         * Reads and serializes an XML tree.
         *
         * @param node - root node
         */
        _fromNode(node) {
          if (util_2.Guard.isElementNode(node)) {
            const name = node.prefix ? node.prefix + ":" + node.localName : node.localName;
            if (node.namespaceURI !== null) {
              this.ele(node.namespaceURI, name);
            } else {
              this.ele(name);
            }
            for (const attr of node.attributes) {
              const name2 = attr.prefix ? attr.prefix + ":" + attr.localName : attr.localName;
              if (attr.namespaceURI !== null) {
                this.att(attr.namespaceURI, name2, attr.value);
              } else {
                this.att(name2, attr.value);
              }
            }
            for (const child of node.childNodes) {
              this._fromNode(child);
            }
            this.up();
          } else if (util_2.Guard.isExclusiveTextNode(node) && node.data) {
            this.txt(node.data);
          } else if (util_2.Guard.isCommentNode(node)) {
            this.com(node.data);
          } else if (util_2.Guard.isCDATASectionNode(node)) {
            this.dat(node.data);
          } else if (util_2.Guard.isProcessingInstructionNode(node)) {
            this.ins(node.target, node.data);
          }
        }
        /**
         * Produces an XML serialization of the attributes of an element node.
         *
         * @param node - node to serialize
         * @param map - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         * @param localPrefixesMap - local prefixes map
         * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
         * attributes
         * @param requireWellFormed - whether to check conformance
         */
        _serializeAttributes(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
          const localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : void 0;
          for (const attr of node.attributes) {
            if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
              this._push(this._writer.attribute(attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
              continue;
            }
            if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
              this.emit("error", new Error("Element contains duplicate attributes (well-formed required)."));
              return;
            }
            if (requireWellFormed && localNameSet)
              localNameSet.set(attr.namespaceURI, attr.localName);
            let attributeNamespace = attr.namespaceURI;
            let candidatePrefix = null;
            if (attributeNamespace !== null) {
              candidatePrefix = map.get(attr.prefix, attributeNamespace);
              if (attributeNamespace === infra_1.namespace.XMLNS) {
                if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value))
                  continue;
                if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                  this.emit("error", new Error("XMLNS namespace is reserved (well-formed required)."));
                  return;
                }
                if (requireWellFormed && attr.value === "") {
                  this.emit("error", new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required)."));
                  return;
                }
                if (attr.prefix === "xmlns")
                  candidatePrefix = "xmlns";
              } else if (candidatePrefix === null) {
                if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
                  candidatePrefix = attr.prefix;
                } else {
                  candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                }
                this._push(this._writer.attribute("xmlns:" + candidatePrefix, this._serializeAttributeValue(attributeNamespace, this._options.wellFormed)));
              }
            }
            if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !(0, algorithm_1.xml_isName)(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
              this.emit("error", new Error("Attribute local name contains invalid characters (well-formed required)."));
              return;
            }
            this._push(this._writer.attribute((candidatePrefix !== null ? candidatePrefix + ":" : "") + attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
          }
        }
        /**
         * Produces an XML serialization of an attribute value.
         *
         * @param value - attribute value
         * @param requireWellFormed - whether to check conformance
         */
        _serializeAttributeValue(value, requireWellFormed) {
          if (requireWellFormed && value !== null && !(0, algorithm_1.xml_isLegalChar)(value)) {
            this.emit("error", new Error("Invalid characters in attribute value."));
            return "";
          }
          if (value === null)
            return "";
          return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
        }
        /**
         * Records namespace information for the given element and returns the
         * default namespace attribute value.
         *
         * @param node - element node to process
         * @param map - namespace prefix map
         * @param localPrefixesMap - local prefixes map
         */
        _recordNamespaceInformation(node, map, localPrefixesMap) {
          let defaultNamespaceAttrValue = null;
          for (const attr of node.attributes) {
            let attributeNamespace = attr.namespaceURI;
            let attributePrefix = attr.prefix;
            if (attributeNamespace === infra_1.namespace.XMLNS) {
              if (attributePrefix === null) {
                defaultNamespaceAttrValue = attr.value;
                continue;
              } else {
                let prefixDefinition = attr.localName;
                let namespaceDefinition = attr.value;
                if (namespaceDefinition === infra_1.namespace.XML) {
                  continue;
                }
                if (namespaceDefinition === "") {
                  namespaceDefinition = null;
                }
                if (map.has(prefixDefinition, namespaceDefinition)) {
                  continue;
                }
                map.set(prefixDefinition, namespaceDefinition);
                localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
              }
            }
          }
          return defaultNamespaceAttrValue;
        }
        /**
         * Generates a new prefix for the given namespace.
         *
         * @param newNamespace - a namespace to generate prefix for
         * @param prefixMap - namespace prefix map
         * @param prefixIndex - generated namespace prefix index
         */
        _generatePrefix(newNamespace, prefixMap, prefixIndex) {
          let generatedPrefix = "ns" + prefixIndex.value;
          prefixIndex.value++;
          prefixMap.set(generatedPrefix, newNamespace);
          return generatedPrefix;
        }
        /**
         * Determines if the namespace prefix map was modified from its original.
         *
         * @param originalMap - original namespace prefix map
         * @param newMap - new namespace prefix map
         */
        _isPrefixMapModified(originalMap, newMap) {
          const items1 = originalMap._items;
          const items2 = newMap._items;
          const nullItems1 = originalMap._nullItems;
          const nullItems2 = newMap._nullItems;
          for (const key in items2) {
            const arr1 = items1[key];
            if (arr1 === void 0)
              return true;
            const arr2 = items2[key];
            if (arr1.length !== arr2.length)
              return true;
            for (let i = 0; i < arr1.length; i++) {
              if (arr1[i] !== arr2[i])
                return true;
            }
          }
          if (nullItems1.length !== nullItems2.length)
            return true;
          for (let i = 0; i < nullItems1.length; i++) {
            if (nullItems1[i] !== nullItems2[i])
              return true;
          }
          return false;
        }
      };
      __publicField(_XMLBuilderCBImpl, "_VoidElementNames", /* @__PURE__ */ new Set([
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "menuitem",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]));
      var XMLBuilderCBImpl = _XMLBuilderCBImpl;
      exports.XMLBuilderCBImpl = XMLBuilderCBImpl;
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/BuilderFunctionsCB.js
  var require_BuilderFunctionsCB = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/BuilderFunctionsCB.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createCB = createCB;
      exports.fragmentCB = fragmentCB;
      var _1 = require_builder();
      function createCB(options) {
        return new _1.XMLBuilderCBImpl(options);
      }
      function fragmentCB(options) {
        return new _1.XMLBuilderCBImpl(options, true);
      }
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/index.js
  var require_builder = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/builder/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fragmentCB = exports.createCB = exports.convert = exports.fragment = exports.create = exports.builder = exports.XMLBuilderCBImpl = exports.XMLBuilderImpl = void 0;
      var XMLBuilderImpl_1 = require_XMLBuilderImpl();
      Object.defineProperty(exports, "XMLBuilderImpl", { enumerable: true, get: function() {
        return XMLBuilderImpl_1.XMLBuilderImpl;
      } });
      var XMLBuilderCBImpl_1 = require_XMLBuilderCBImpl();
      Object.defineProperty(exports, "XMLBuilderCBImpl", { enumerable: true, get: function() {
        return XMLBuilderCBImpl_1.XMLBuilderCBImpl;
      } });
      var BuilderFunctions_1 = require_BuilderFunctions();
      Object.defineProperty(exports, "builder", { enumerable: true, get: function() {
        return BuilderFunctions_1.builder;
      } });
      Object.defineProperty(exports, "create", { enumerable: true, get: function() {
        return BuilderFunctions_1.create;
      } });
      Object.defineProperty(exports, "fragment", { enumerable: true, get: function() {
        return BuilderFunctions_1.fragment;
      } });
      Object.defineProperty(exports, "convert", { enumerable: true, get: function() {
        return BuilderFunctions_1.convert;
      } });
      var BuilderFunctionsCB_1 = require_BuilderFunctionsCB();
      Object.defineProperty(exports, "createCB", { enumerable: true, get: function() {
        return BuilderFunctionsCB_1.createCB;
      } });
      Object.defineProperty(exports, "fragmentCB", { enumerable: true, get: function() {
        return BuilderFunctionsCB_1.fragmentCB;
      } });
    }
  });

  // node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/index.js
  var require_lib7 = __commonJS({
    "node_modules/.pnpm/xmlbuilder2@4.0.3/node_modules/xmlbuilder2/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fragmentCB = exports.createCB = exports.convert = exports.fragment = exports.create = exports.builder = void 0;
      var builder_1 = require_builder();
      Object.defineProperty(exports, "builder", { enumerable: true, get: function() {
        return builder_1.builder;
      } });
      Object.defineProperty(exports, "create", { enumerable: true, get: function() {
        return builder_1.create;
      } });
      Object.defineProperty(exports, "fragment", { enumerable: true, get: function() {
        return builder_1.fragment;
      } });
      Object.defineProperty(exports, "convert", { enumerable: true, get: function() {
        return builder_1.convert;
      } });
      Object.defineProperty(exports, "createCB", { enumerable: true, get: function() {
        return builder_1.createCB;
      } });
      Object.defineProperty(exports, "fragmentCB", { enumerable: true, get: function() {
        return builder_1.fragmentCB;
      } });
    }
  });

  // src/pptxgen.ts
  var pptxgen_exports = {};
  __export(pptxgen_exports, {
    SHADOW_PRESETS: () => SHADOW_PRESETS,
    darkenColor: () => darkenColor,
    default: () => PptxGenJS,
    interpolateColor: () => interpolateColor,
    interpolateColors: () => interpolateColors,
    lightenColor: () => lightenColor,
    parseHexColorToRgb: () => parseHexColorToRgb,
    resolveShadowPreset: () => resolveShadowPreset,
    rgbToHexColor: () => rgbToHexColor,
    textStyle: () => textStyle
  });
  var import_jszip2 = __toESM(require_lib3(), 1);

  // src/core-enums.ts
  var EMU = 914400;
  var ONEPT = 12700;
  var CRLF = "\r\n";
  var LAYOUT_IDX_SERIES_BASE = 2147483649;
  var REGEX_HEX_COLOR = /^[0-9a-fA-F]{6}$/;
  var LINEH_MODIFIER = 1.67;
  var DEF_BULLET_MARGIN = 27;
  var DEF_CELL_BORDER = { type: "solid", color: "666666", pt: 1 };
  var DEF_CELL_MARGIN_IN = [0.05, 0.1, 0.05, 0.1];
  var DEF_CHART_BORDER = { type: "solid", color: "363636", pt: 1 };
  var DEF_CHART_GRIDLINE = { color: "888888", style: "solid", size: 1, cap: "flat" };
  var DEF_FONT_COLOR = "000000";
  var DEF_FONT_SIZE = 12;
  var DEF_FONT_TITLE_SIZE = 18;
  var DEF_PRES_LAYOUT = "LAYOUT_16x9";
  var DEF_PRES_LAYOUT_NAME = "DEFAULT";
  var DEF_SHAPE_LINE_COLOR = "333333";
  var DEF_SHAPE_SHADOW = { type: "outer", blur: 3, offset: 23e3 / 12700, angle: 90, color: "000000", opacity: 0.35, rotateWithShape: true };
  var DEF_SLIDE_MARGIN_IN = [0.5, 0.5, 0.5, 0.5];
  var DEF_TEXT_SHADOW = { type: "outer", blur: 8, offset: 4, angle: 270, color: "000000", opacity: 0.75 };
  var DEF_TEXT_GLOW = { size: 8, color: "FFFFFF", opacity: 0.75 };
  var AXIS_ID_VALUE_PRIMARY = "2094734552";
  var AXIS_ID_VALUE_SECONDARY = "2094734553";
  var AXIS_ID_CATEGORY_PRIMARY = "2094734554";
  var AXIS_ID_CATEGORY_SECONDARY = "2094734555";
  var AXIS_ID_SERIES_PRIMARY = "2094734556";
  var LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
  var BARCHART_COLORS = [
    "C0504D",
    "4F81BD",
    "9BBB59",
    "8064A2",
    "4BACC6",
    "F79646",
    "628FC6",
    "C86360",
    "C0504D",
    "4F81BD",
    "9BBB59",
    "8064A2",
    "4BACC6",
    "F79646",
    "628FC6",
    "C86360"
  ];
  var PIECHART_COLORS = [
    "5DA5DA",
    "FAA43A",
    "60BD68",
    "F17CB0",
    "B2912F",
    "B276B2",
    "DECF3F",
    "F15854",
    "A7A7A7",
    "5DA5DA",
    "FAA43A",
    "60BD68",
    "F17CB0",
    "B2912F",
    "B276B2",
    "DECF3F",
    "F15854",
    "A7A7A7"
  ];
  var SLDNUMFLDID = "{F7021451-1387-4CA6-816F-3879F97B5CBC}";
  var OutputType = /* @__PURE__ */ ((OutputType2) => {
    OutputType2["arraybuffer"] = "arraybuffer";
    OutputType2["base64"] = "base64";
    OutputType2["binarystring"] = "binarystring";
    OutputType2["blob"] = "blob";
    OutputType2["nodebuffer"] = "nodebuffer";
    OutputType2["uint8array"] = "uint8array";
    return OutputType2;
  })(OutputType || {});
  var ChartType = /* @__PURE__ */ ((ChartType2) => {
    ChartType2["area"] = "area";
    ChartType2["bar"] = "bar";
    ChartType2["bar3d"] = "bar3D";
    ChartType2["bubble"] = "bubble";
    ChartType2["bubble3d"] = "bubble3D";
    ChartType2["doughnut"] = "doughnut";
    ChartType2["line"] = "line";
    ChartType2["pie"] = "pie";
    ChartType2["radar"] = "radar";
    ChartType2["scatter"] = "scatter";
    return ChartType2;
  })(ChartType || {});
  var ShapeType = /* @__PURE__ */ ((ShapeType2) => {
    ShapeType2["accentBorderCallout1"] = "accentBorderCallout1";
    ShapeType2["accentBorderCallout2"] = "accentBorderCallout2";
    ShapeType2["accentBorderCallout3"] = "accentBorderCallout3";
    ShapeType2["accentCallout1"] = "accentCallout1";
    ShapeType2["accentCallout2"] = "accentCallout2";
    ShapeType2["accentCallout3"] = "accentCallout3";
    ShapeType2["actionButtonBackPrevious"] = "actionButtonBackPrevious";
    ShapeType2["actionButtonBeginning"] = "actionButtonBeginning";
    ShapeType2["actionButtonBlank"] = "actionButtonBlank";
    ShapeType2["actionButtonDocument"] = "actionButtonDocument";
    ShapeType2["actionButtonEnd"] = "actionButtonEnd";
    ShapeType2["actionButtonForwardNext"] = "actionButtonForwardNext";
    ShapeType2["actionButtonHelp"] = "actionButtonHelp";
    ShapeType2["actionButtonHome"] = "actionButtonHome";
    ShapeType2["actionButtonInformation"] = "actionButtonInformation";
    ShapeType2["actionButtonMovie"] = "actionButtonMovie";
    ShapeType2["actionButtonReturn"] = "actionButtonReturn";
    ShapeType2["actionButtonSound"] = "actionButtonSound";
    ShapeType2["arc"] = "arc";
    ShapeType2["bentArrow"] = "bentArrow";
    ShapeType2["bentUpArrow"] = "bentUpArrow";
    ShapeType2["bevel"] = "bevel";
    ShapeType2["blockArc"] = "blockArc";
    ShapeType2["borderCallout1"] = "borderCallout1";
    ShapeType2["borderCallout2"] = "borderCallout2";
    ShapeType2["borderCallout3"] = "borderCallout3";
    ShapeType2["bracePair"] = "bracePair";
    ShapeType2["bracketPair"] = "bracketPair";
    ShapeType2["callout1"] = "callout1";
    ShapeType2["callout2"] = "callout2";
    ShapeType2["callout3"] = "callout3";
    ShapeType2["can"] = "can";
    ShapeType2["chartPlus"] = "chartPlus";
    ShapeType2["chartStar"] = "chartStar";
    ShapeType2["chartX"] = "chartX";
    ShapeType2["chevron"] = "chevron";
    ShapeType2["chord"] = "chord";
    ShapeType2["circularArrow"] = "circularArrow";
    ShapeType2["cloud"] = "cloud";
    ShapeType2["cloudCallout"] = "cloudCallout";
    ShapeType2["corner"] = "corner";
    ShapeType2["cornerTabs"] = "cornerTabs";
    ShapeType2["cube"] = "cube";
    ShapeType2["curvedDownArrow"] = "curvedDownArrow";
    ShapeType2["curvedLeftArrow"] = "curvedLeftArrow";
    ShapeType2["curvedRightArrow"] = "curvedRightArrow";
    ShapeType2["curvedUpArrow"] = "curvedUpArrow";
    ShapeType2["custGeom"] = "custGeom";
    ShapeType2["decagon"] = "decagon";
    ShapeType2["diagStripe"] = "diagStripe";
    ShapeType2["diamond"] = "diamond";
    ShapeType2["dodecagon"] = "dodecagon";
    ShapeType2["donut"] = "donut";
    ShapeType2["doubleWave"] = "doubleWave";
    ShapeType2["downArrow"] = "downArrow";
    ShapeType2["downArrowCallout"] = "downArrowCallout";
    ShapeType2["ellipse"] = "ellipse";
    ShapeType2["ellipseRibbon"] = "ellipseRibbon";
    ShapeType2["ellipseRibbon2"] = "ellipseRibbon2";
    ShapeType2["flowChartAlternateProcess"] = "flowChartAlternateProcess";
    ShapeType2["flowChartCollate"] = "flowChartCollate";
    ShapeType2["flowChartConnector"] = "flowChartConnector";
    ShapeType2["flowChartDecision"] = "flowChartDecision";
    ShapeType2["flowChartDelay"] = "flowChartDelay";
    ShapeType2["flowChartDisplay"] = "flowChartDisplay";
    ShapeType2["flowChartDocument"] = "flowChartDocument";
    ShapeType2["flowChartExtract"] = "flowChartExtract";
    ShapeType2["flowChartInputOutput"] = "flowChartInputOutput";
    ShapeType2["flowChartInternalStorage"] = "flowChartInternalStorage";
    ShapeType2["flowChartMagneticDisk"] = "flowChartMagneticDisk";
    ShapeType2["flowChartMagneticDrum"] = "flowChartMagneticDrum";
    ShapeType2["flowChartMagneticTape"] = "flowChartMagneticTape";
    ShapeType2["flowChartManualInput"] = "flowChartManualInput";
    ShapeType2["flowChartManualOperation"] = "flowChartManualOperation";
    ShapeType2["flowChartMerge"] = "flowChartMerge";
    ShapeType2["flowChartMultidocument"] = "flowChartMultidocument";
    ShapeType2["flowChartOfflineStorage"] = "flowChartOfflineStorage";
    ShapeType2["flowChartOffpageConnector"] = "flowChartOffpageConnector";
    ShapeType2["flowChartOnlineStorage"] = "flowChartOnlineStorage";
    ShapeType2["flowChartOr"] = "flowChartOr";
    ShapeType2["flowChartPredefinedProcess"] = "flowChartPredefinedProcess";
    ShapeType2["flowChartPreparation"] = "flowChartPreparation";
    ShapeType2["flowChartProcess"] = "flowChartProcess";
    ShapeType2["flowChartPunchedCard"] = "flowChartPunchedCard";
    ShapeType2["flowChartPunchedTape"] = "flowChartPunchedTape";
    ShapeType2["flowChartSort"] = "flowChartSort";
    ShapeType2["flowChartSummingJunction"] = "flowChartSummingJunction";
    ShapeType2["flowChartTerminator"] = "flowChartTerminator";
    ShapeType2["folderCorner"] = "folderCorner";
    ShapeType2["frame"] = "frame";
    ShapeType2["funnel"] = "funnel";
    ShapeType2["gear6"] = "gear6";
    ShapeType2["gear9"] = "gear9";
    ShapeType2["halfFrame"] = "halfFrame";
    ShapeType2["heart"] = "heart";
    ShapeType2["heptagon"] = "heptagon";
    ShapeType2["hexagon"] = "hexagon";
    ShapeType2["homePlate"] = "homePlate";
    ShapeType2["horizontalScroll"] = "horizontalScroll";
    ShapeType2["irregularSeal1"] = "irregularSeal1";
    ShapeType2["irregularSeal2"] = "irregularSeal2";
    ShapeType2["leftArrow"] = "leftArrow";
    ShapeType2["leftArrowCallout"] = "leftArrowCallout";
    ShapeType2["leftBrace"] = "leftBrace";
    ShapeType2["leftBracket"] = "leftBracket";
    ShapeType2["leftCircularArrow"] = "leftCircularArrow";
    ShapeType2["leftRightArrow"] = "leftRightArrow";
    ShapeType2["leftRightArrowCallout"] = "leftRightArrowCallout";
    ShapeType2["leftRightCircularArrow"] = "leftRightCircularArrow";
    ShapeType2["leftRightRibbon"] = "leftRightRibbon";
    ShapeType2["leftRightUpArrow"] = "leftRightUpArrow";
    ShapeType2["leftUpArrow"] = "leftUpArrow";
    ShapeType2["lightningBolt"] = "lightningBolt";
    ShapeType2["line"] = "line";
    ShapeType2["lineInv"] = "lineInv";
    ShapeType2["mathDivide"] = "mathDivide";
    ShapeType2["mathEqual"] = "mathEqual";
    ShapeType2["mathMinus"] = "mathMinus";
    ShapeType2["mathMultiply"] = "mathMultiply";
    ShapeType2["mathNotEqual"] = "mathNotEqual";
    ShapeType2["mathPlus"] = "mathPlus";
    ShapeType2["moon"] = "moon";
    ShapeType2["noSmoking"] = "noSmoking";
    ShapeType2["nonIsoscelesTrapezoid"] = "nonIsoscelesTrapezoid";
    ShapeType2["notchedRightArrow"] = "notchedRightArrow";
    ShapeType2["octagon"] = "octagon";
    ShapeType2["parallelogram"] = "parallelogram";
    ShapeType2["pentagon"] = "pentagon";
    ShapeType2["pie"] = "pie";
    ShapeType2["pieWedge"] = "pieWedge";
    ShapeType2["plaque"] = "plaque";
    ShapeType2["plaqueTabs"] = "plaqueTabs";
    ShapeType2["plus"] = "plus";
    ShapeType2["quadArrow"] = "quadArrow";
    ShapeType2["quadArrowCallout"] = "quadArrowCallout";
    ShapeType2["rect"] = "rect";
    ShapeType2["ribbon"] = "ribbon";
    ShapeType2["ribbon2"] = "ribbon2";
    ShapeType2["rightArrow"] = "rightArrow";
    ShapeType2["rightArrowCallout"] = "rightArrowCallout";
    ShapeType2["rightBrace"] = "rightBrace";
    ShapeType2["rightBracket"] = "rightBracket";
    ShapeType2["round1Rect"] = "round1Rect";
    ShapeType2["round2DiagRect"] = "round2DiagRect";
    ShapeType2["round2SameRect"] = "round2SameRect";
    ShapeType2["roundRect"] = "roundRect";
    ShapeType2["rtTriangle"] = "rtTriangle";
    ShapeType2["smileyFace"] = "smileyFace";
    ShapeType2["snip1Rect"] = "snip1Rect";
    ShapeType2["snip2DiagRect"] = "snip2DiagRect";
    ShapeType2["snip2SameRect"] = "snip2SameRect";
    ShapeType2["snipRoundRect"] = "snipRoundRect";
    ShapeType2["squareTabs"] = "squareTabs";
    ShapeType2["star10"] = "star10";
    ShapeType2["star12"] = "star12";
    ShapeType2["star16"] = "star16";
    ShapeType2["star24"] = "star24";
    ShapeType2["star32"] = "star32";
    ShapeType2["star4"] = "star4";
    ShapeType2["star5"] = "star5";
    ShapeType2["star6"] = "star6";
    ShapeType2["star7"] = "star7";
    ShapeType2["star8"] = "star8";
    ShapeType2["stripedRightArrow"] = "stripedRightArrow";
    ShapeType2["sun"] = "sun";
    ShapeType2["swooshArrow"] = "swooshArrow";
    ShapeType2["teardrop"] = "teardrop";
    ShapeType2["trapezoid"] = "trapezoid";
    ShapeType2["triangle"] = "triangle";
    ShapeType2["upArrow"] = "upArrow";
    ShapeType2["upArrowCallout"] = "upArrowCallout";
    ShapeType2["upDownArrow"] = "upDownArrow";
    ShapeType2["upDownArrowCallout"] = "upDownArrowCallout";
    ShapeType2["uturnArrow"] = "uturnArrow";
    ShapeType2["verticalScroll"] = "verticalScroll";
    ShapeType2["wave"] = "wave";
    ShapeType2["wedgeEllipseCallout"] = "wedgeEllipseCallout";
    ShapeType2["wedgeRectCallout"] = "wedgeRectCallout";
    ShapeType2["wedgeRoundRectCallout"] = "wedgeRoundRectCallout";
    return ShapeType2;
  })(ShapeType || {});
  var SchemeColor = /* @__PURE__ */ ((SchemeColor2) => {
    SchemeColor2["text1"] = "tx1";
    SchemeColor2["text2"] = "tx2";
    SchemeColor2["background1"] = "bg1";
    SchemeColor2["background2"] = "bg2";
    SchemeColor2["accent1"] = "accent1";
    SchemeColor2["accent2"] = "accent2";
    SchemeColor2["accent3"] = "accent3";
    SchemeColor2["accent4"] = "accent4";
    SchemeColor2["accent5"] = "accent5";
    SchemeColor2["accent6"] = "accent6";
    return SchemeColor2;
  })(SchemeColor || {});
  var AlignH = /* @__PURE__ */ ((AlignH2) => {
    AlignH2["left"] = "left";
    AlignH2["center"] = "center";
    AlignH2["right"] = "right";
    AlignH2["justify"] = "justify";
    return AlignH2;
  })(AlignH || {});
  var AlignV = /* @__PURE__ */ ((AlignV2) => {
    AlignV2["top"] = "top";
    AlignV2["middle"] = "middle";
    AlignV2["bottom"] = "bottom";
    return AlignV2;
  })(AlignV || {});
  var SHAPE_TYPE = /* @__PURE__ */ ((SHAPE_TYPE2) => {
    SHAPE_TYPE2["ACTION_BUTTON_BACK_OR_PREVIOUS"] = "actionButtonBackPrevious";
    SHAPE_TYPE2["ACTION_BUTTON_BEGINNING"] = "actionButtonBeginning";
    SHAPE_TYPE2["ACTION_BUTTON_CUSTOM"] = "actionButtonBlank";
    SHAPE_TYPE2["ACTION_BUTTON_DOCUMENT"] = "actionButtonDocument";
    SHAPE_TYPE2["ACTION_BUTTON_END"] = "actionButtonEnd";
    SHAPE_TYPE2["ACTION_BUTTON_FORWARD_OR_NEXT"] = "actionButtonForwardNext";
    SHAPE_TYPE2["ACTION_BUTTON_HELP"] = "actionButtonHelp";
    SHAPE_TYPE2["ACTION_BUTTON_HOME"] = "actionButtonHome";
    SHAPE_TYPE2["ACTION_BUTTON_INFORMATION"] = "actionButtonInformation";
    SHAPE_TYPE2["ACTION_BUTTON_MOVIE"] = "actionButtonMovie";
    SHAPE_TYPE2["ACTION_BUTTON_RETURN"] = "actionButtonReturn";
    SHAPE_TYPE2["ACTION_BUTTON_SOUND"] = "actionButtonSound";
    SHAPE_TYPE2["ARC"] = "arc";
    SHAPE_TYPE2["BALLOON"] = "wedgeRoundRectCallout";
    SHAPE_TYPE2["BENT_ARROW"] = "bentArrow";
    SHAPE_TYPE2["BENT_UP_ARROW"] = "bentUpArrow";
    SHAPE_TYPE2["BEVEL"] = "bevel";
    SHAPE_TYPE2["BLOCK_ARC"] = "blockArc";
    SHAPE_TYPE2["CAN"] = "can";
    SHAPE_TYPE2["CHART_PLUS"] = "chartPlus";
    SHAPE_TYPE2["CHART_STAR"] = "chartStar";
    SHAPE_TYPE2["CHART_X"] = "chartX";
    SHAPE_TYPE2["CHEVRON"] = "chevron";
    SHAPE_TYPE2["CHORD"] = "chord";
    SHAPE_TYPE2["CIRCULAR_ARROW"] = "circularArrow";
    SHAPE_TYPE2["CLOUD"] = "cloud";
    SHAPE_TYPE2["CLOUD_CALLOUT"] = "cloudCallout";
    SHAPE_TYPE2["CORNER"] = "corner";
    SHAPE_TYPE2["CORNER_TABS"] = "cornerTabs";
    SHAPE_TYPE2["CROSS"] = "plus";
    SHAPE_TYPE2["CUBE"] = "cube";
    SHAPE_TYPE2["CURVED_DOWN_ARROW"] = "curvedDownArrow";
    SHAPE_TYPE2["CURVED_DOWN_RIBBON"] = "ellipseRibbon";
    SHAPE_TYPE2["CURVED_LEFT_ARROW"] = "curvedLeftArrow";
    SHAPE_TYPE2["CURVED_RIGHT_ARROW"] = "curvedRightArrow";
    SHAPE_TYPE2["CURVED_UP_ARROW"] = "curvedUpArrow";
    SHAPE_TYPE2["CURVED_UP_RIBBON"] = "ellipseRibbon2";
    SHAPE_TYPE2["CUSTOM_GEOMETRY"] = "custGeom";
    SHAPE_TYPE2["DECAGON"] = "decagon";
    SHAPE_TYPE2["DIAGONAL_STRIPE"] = "diagStripe";
    SHAPE_TYPE2["DIAMOND"] = "diamond";
    SHAPE_TYPE2["DODECAGON"] = "dodecagon";
    SHAPE_TYPE2["DONUT"] = "donut";
    SHAPE_TYPE2["DOUBLE_BRACE"] = "bracePair";
    SHAPE_TYPE2["DOUBLE_BRACKET"] = "bracketPair";
    SHAPE_TYPE2["DOUBLE_WAVE"] = "doubleWave";
    SHAPE_TYPE2["DOWN_ARROW"] = "downArrow";
    SHAPE_TYPE2["DOWN_ARROW_CALLOUT"] = "downArrowCallout";
    SHAPE_TYPE2["DOWN_RIBBON"] = "ribbon";
    SHAPE_TYPE2["EXPLOSION1"] = "irregularSeal1";
    SHAPE_TYPE2["EXPLOSION2"] = "irregularSeal2";
    SHAPE_TYPE2["FLOWCHART_ALTERNATE_PROCESS"] = "flowChartAlternateProcess";
    SHAPE_TYPE2["FLOWCHART_CARD"] = "flowChartPunchedCard";
    SHAPE_TYPE2["FLOWCHART_COLLATE"] = "flowChartCollate";
    SHAPE_TYPE2["FLOWCHART_CONNECTOR"] = "flowChartConnector";
    SHAPE_TYPE2["FLOWCHART_DATA"] = "flowChartInputOutput";
    SHAPE_TYPE2["FLOWCHART_DECISION"] = "flowChartDecision";
    SHAPE_TYPE2["FLOWCHART_DELAY"] = "flowChartDelay";
    SHAPE_TYPE2["FLOWCHART_DIRECT_ACCESS_STORAGE"] = "flowChartMagneticDrum";
    SHAPE_TYPE2["FLOWCHART_DISPLAY"] = "flowChartDisplay";
    SHAPE_TYPE2["FLOWCHART_DOCUMENT"] = "flowChartDocument";
    SHAPE_TYPE2["FLOWCHART_EXTRACT"] = "flowChartExtract";
    SHAPE_TYPE2["FLOWCHART_INTERNAL_STORAGE"] = "flowChartInternalStorage";
    SHAPE_TYPE2["FLOWCHART_MAGNETIC_DISK"] = "flowChartMagneticDisk";
    SHAPE_TYPE2["FLOWCHART_MANUAL_INPUT"] = "flowChartManualInput";
    SHAPE_TYPE2["FLOWCHART_MANUAL_OPERATION"] = "flowChartManualOperation";
    SHAPE_TYPE2["FLOWCHART_MERGE"] = "flowChartMerge";
    SHAPE_TYPE2["FLOWCHART_MULTIDOCUMENT"] = "flowChartMultidocument";
    SHAPE_TYPE2["FLOWCHART_OFFLINE_STORAGE"] = "flowChartOfflineStorage";
    SHAPE_TYPE2["FLOWCHART_OFFPAGE_CONNECTOR"] = "flowChartOffpageConnector";
    SHAPE_TYPE2["FLOWCHART_OR"] = "flowChartOr";
    SHAPE_TYPE2["FLOWCHART_PREDEFINED_PROCESS"] = "flowChartPredefinedProcess";
    SHAPE_TYPE2["FLOWCHART_PREPARATION"] = "flowChartPreparation";
    SHAPE_TYPE2["FLOWCHART_PROCESS"] = "flowChartProcess";
    SHAPE_TYPE2["FLOWCHART_PUNCHED_TAPE"] = "flowChartPunchedTape";
    SHAPE_TYPE2["FLOWCHART_SEQUENTIAL_ACCESS_STORAGE"] = "flowChartMagneticTape";
    SHAPE_TYPE2["FLOWCHART_SORT"] = "flowChartSort";
    SHAPE_TYPE2["FLOWCHART_STORED_DATA"] = "flowChartOnlineStorage";
    SHAPE_TYPE2["FLOWCHART_SUMMING_JUNCTION"] = "flowChartSummingJunction";
    SHAPE_TYPE2["FLOWCHART_TERMINATOR"] = "flowChartTerminator";
    SHAPE_TYPE2["FOLDED_CORNER"] = "folderCorner";
    SHAPE_TYPE2["FRAME"] = "frame";
    SHAPE_TYPE2["FUNNEL"] = "funnel";
    SHAPE_TYPE2["GEAR_6"] = "gear6";
    SHAPE_TYPE2["GEAR_9"] = "gear9";
    SHAPE_TYPE2["HALF_FRAME"] = "halfFrame";
    SHAPE_TYPE2["HEART"] = "heart";
    SHAPE_TYPE2["HEPTAGON"] = "heptagon";
    SHAPE_TYPE2["HEXAGON"] = "hexagon";
    SHAPE_TYPE2["HORIZONTAL_SCROLL"] = "horizontalScroll";
    SHAPE_TYPE2["ISOSCELES_TRIANGLE"] = "triangle";
    SHAPE_TYPE2["LEFT_ARROW"] = "leftArrow";
    SHAPE_TYPE2["LEFT_ARROW_CALLOUT"] = "leftArrowCallout";
    SHAPE_TYPE2["LEFT_BRACE"] = "leftBrace";
    SHAPE_TYPE2["LEFT_BRACKET"] = "leftBracket";
    SHAPE_TYPE2["LEFT_CIRCULAR_ARROW"] = "leftCircularArrow";
    SHAPE_TYPE2["LEFT_RIGHT_ARROW"] = "leftRightArrow";
    SHAPE_TYPE2["LEFT_RIGHT_ARROW_CALLOUT"] = "leftRightArrowCallout";
    SHAPE_TYPE2["LEFT_RIGHT_CIRCULAR_ARROW"] = "leftRightCircularArrow";
    SHAPE_TYPE2["LEFT_RIGHT_RIBBON"] = "leftRightRibbon";
    SHAPE_TYPE2["LEFT_RIGHT_UP_ARROW"] = "leftRightUpArrow";
    SHAPE_TYPE2["LEFT_UP_ARROW"] = "leftUpArrow";
    SHAPE_TYPE2["LIGHTNING_BOLT"] = "lightningBolt";
    SHAPE_TYPE2["LINE_CALLOUT_1"] = "borderCallout1";
    SHAPE_TYPE2["LINE_CALLOUT_1_ACCENT_BAR"] = "accentCallout1";
    SHAPE_TYPE2["LINE_CALLOUT_1_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout1";
    SHAPE_TYPE2["LINE_CALLOUT_1_NO_BORDER"] = "callout1";
    SHAPE_TYPE2["LINE_CALLOUT_2"] = "borderCallout2";
    SHAPE_TYPE2["LINE_CALLOUT_2_ACCENT_BAR"] = "accentCallout2";
    SHAPE_TYPE2["LINE_CALLOUT_2_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout2";
    SHAPE_TYPE2["LINE_CALLOUT_2_NO_BORDER"] = "callout2";
    SHAPE_TYPE2["LINE_CALLOUT_3"] = "borderCallout3";
    SHAPE_TYPE2["LINE_CALLOUT_3_ACCENT_BAR"] = "accentCallout3";
    SHAPE_TYPE2["LINE_CALLOUT_3_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout3";
    SHAPE_TYPE2["LINE_CALLOUT_3_NO_BORDER"] = "callout3";
    SHAPE_TYPE2["LINE_CALLOUT_4"] = "borderCallout4";
    SHAPE_TYPE2["LINE_CALLOUT_4_ACCENT_BAR"] = "accentCallout3=4";
    SHAPE_TYPE2["LINE_CALLOUT_4_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout4";
    SHAPE_TYPE2["LINE_CALLOUT_4_NO_BORDER"] = "callout4";
    SHAPE_TYPE2["LINE"] = "line";
    SHAPE_TYPE2["LINE_INVERSE"] = "lineInv";
    SHAPE_TYPE2["MATH_DIVIDE"] = "mathDivide";
    SHAPE_TYPE2["MATH_EQUAL"] = "mathEqual";
    SHAPE_TYPE2["MATH_MINUS"] = "mathMinus";
    SHAPE_TYPE2["MATH_MULTIPLY"] = "mathMultiply";
    SHAPE_TYPE2["MATH_NOT_EQUAL"] = "mathNotEqual";
    SHAPE_TYPE2["MATH_PLUS"] = "mathPlus";
    SHAPE_TYPE2["MOON"] = "moon";
    SHAPE_TYPE2["NON_ISOSCELES_TRAPEZOID"] = "nonIsoscelesTrapezoid";
    SHAPE_TYPE2["NOTCHED_RIGHT_ARROW"] = "notchedRightArrow";
    SHAPE_TYPE2["NO_SYMBOL"] = "noSmoking";
    SHAPE_TYPE2["OCTAGON"] = "octagon";
    SHAPE_TYPE2["OVAL"] = "ellipse";
    SHAPE_TYPE2["OVAL_CALLOUT"] = "wedgeEllipseCallout";
    SHAPE_TYPE2["PARALLELOGRAM"] = "parallelogram";
    SHAPE_TYPE2["PENTAGON"] = "homePlate";
    SHAPE_TYPE2["PIE"] = "pie";
    SHAPE_TYPE2["PIE_WEDGE"] = "pieWedge";
    SHAPE_TYPE2["PLAQUE"] = "plaque";
    SHAPE_TYPE2["PLAQUE_TABS"] = "plaqueTabs";
    SHAPE_TYPE2["QUAD_ARROW"] = "quadArrow";
    SHAPE_TYPE2["QUAD_ARROW_CALLOUT"] = "quadArrowCallout";
    SHAPE_TYPE2["RECTANGLE"] = "rect";
    SHAPE_TYPE2["RECTANGULAR_CALLOUT"] = "wedgeRectCallout";
    SHAPE_TYPE2["REGULAR_PENTAGON"] = "pentagon";
    SHAPE_TYPE2["RIGHT_ARROW"] = "rightArrow";
    SHAPE_TYPE2["RIGHT_ARROW_CALLOUT"] = "rightArrowCallout";
    SHAPE_TYPE2["RIGHT_BRACE"] = "rightBrace";
    SHAPE_TYPE2["RIGHT_BRACKET"] = "rightBracket";
    SHAPE_TYPE2["RIGHT_TRIANGLE"] = "rtTriangle";
    SHAPE_TYPE2["ROUNDED_RECTANGLE"] = "roundRect";
    SHAPE_TYPE2["ROUNDED_RECTANGULAR_CALLOUT"] = "wedgeRoundRectCallout";
    SHAPE_TYPE2["ROUND_1_RECTANGLE"] = "round1Rect";
    SHAPE_TYPE2["ROUND_2_DIAG_RECTANGLE"] = "round2DiagRect";
    SHAPE_TYPE2["ROUND_2_SAME_RECTANGLE"] = "round2SameRect";
    SHAPE_TYPE2["SMILEY_FACE"] = "smileyFace";
    SHAPE_TYPE2["SNIP_1_RECTANGLE"] = "snip1Rect";
    SHAPE_TYPE2["SNIP_2_DIAG_RECTANGLE"] = "snip2DiagRect";
    SHAPE_TYPE2["SNIP_2_SAME_RECTANGLE"] = "snip2SameRect";
    SHAPE_TYPE2["SNIP_ROUND_RECTANGLE"] = "snipRoundRect";
    SHAPE_TYPE2["SQUARE_TABS"] = "squareTabs";
    SHAPE_TYPE2["STAR_10_POINT"] = "star10";
    SHAPE_TYPE2["STAR_12_POINT"] = "star12";
    SHAPE_TYPE2["STAR_16_POINT"] = "star16";
    SHAPE_TYPE2["STAR_24_POINT"] = "star24";
    SHAPE_TYPE2["STAR_32_POINT"] = "star32";
    SHAPE_TYPE2["STAR_4_POINT"] = "star4";
    SHAPE_TYPE2["STAR_5_POINT"] = "star5";
    SHAPE_TYPE2["STAR_6_POINT"] = "star6";
    SHAPE_TYPE2["STAR_7_POINT"] = "star7";
    SHAPE_TYPE2["STAR_8_POINT"] = "star8";
    SHAPE_TYPE2["STRIPED_RIGHT_ARROW"] = "stripedRightArrow";
    SHAPE_TYPE2["SUN"] = "sun";
    SHAPE_TYPE2["SWOOSH_ARROW"] = "swooshArrow";
    SHAPE_TYPE2["TEAR"] = "teardrop";
    SHAPE_TYPE2["TRAPEZOID"] = "trapezoid";
    SHAPE_TYPE2["UP_ARROW"] = "upArrow";
    SHAPE_TYPE2["UP_ARROW_CALLOUT"] = "upArrowCallout";
    SHAPE_TYPE2["UP_DOWN_ARROW"] = "upDownArrow";
    SHAPE_TYPE2["UP_DOWN_ARROW_CALLOUT"] = "upDownArrowCallout";
    SHAPE_TYPE2["UP_RIBBON"] = "ribbon2";
    SHAPE_TYPE2["U_TURN_ARROW"] = "uturnArrow";
    SHAPE_TYPE2["VERTICAL_SCROLL"] = "verticalScroll";
    SHAPE_TYPE2["WAVE"] = "wave";
    return SHAPE_TYPE2;
  })(SHAPE_TYPE || {});
  var CHART_TYPE = /* @__PURE__ */ ((CHART_TYPE2) => {
    CHART_TYPE2["AREA"] = "area";
    CHART_TYPE2["BAR"] = "bar";
    CHART_TYPE2["BAR3D"] = "bar3D";
    CHART_TYPE2["BUBBLE"] = "bubble";
    CHART_TYPE2["BUBBLE3D"] = "bubble3D";
    CHART_TYPE2["DOUGHNUT"] = "doughnut";
    CHART_TYPE2["LINE"] = "line";
    CHART_TYPE2["PIE"] = "pie";
    CHART_TYPE2["RADAR"] = "radar";
    CHART_TYPE2["SCATTER"] = "scatter";
    return CHART_TYPE2;
  })(CHART_TYPE || {});
  var SCHEME_COLOR_NAMES = /* @__PURE__ */ ((SCHEME_COLOR_NAMES2) => {
    SCHEME_COLOR_NAMES2["TEXT1"] = "tx1";
    SCHEME_COLOR_NAMES2["TEXT2"] = "tx2";
    SCHEME_COLOR_NAMES2["BACKGROUND1"] = "bg1";
    SCHEME_COLOR_NAMES2["BACKGROUND2"] = "bg2";
    SCHEME_COLOR_NAMES2["ACCENT1"] = "accent1";
    SCHEME_COLOR_NAMES2["ACCENT2"] = "accent2";
    SCHEME_COLOR_NAMES2["ACCENT3"] = "accent3";
    SCHEME_COLOR_NAMES2["ACCENT4"] = "accent4";
    SCHEME_COLOR_NAMES2["ACCENT5"] = "accent5";
    SCHEME_COLOR_NAMES2["ACCENT6"] = "accent6";
    return SCHEME_COLOR_NAMES2;
  })(SCHEME_COLOR_NAMES || {});
  var MASTER_OBJECTS = /* @__PURE__ */ ((MASTER_OBJECTS2) => {
    MASTER_OBJECTS2["chart"] = "chart";
    MASTER_OBJECTS2["image"] = "image";
    MASTER_OBJECTS2["line"] = "line";
    MASTER_OBJECTS2["rect"] = "rect";
    MASTER_OBJECTS2["text"] = "text";
    MASTER_OBJECTS2["placeholder"] = "placeholder";
    return MASTER_OBJECTS2;
  })(MASTER_OBJECTS || {});
  var PLACEHOLDER_TYPES = /* @__PURE__ */ ((PLACEHOLDER_TYPES2) => {
    PLACEHOLDER_TYPES2["title"] = "title";
    PLACEHOLDER_TYPES2["body"] = "body";
    PLACEHOLDER_TYPES2["image"] = "pic";
    PLACEHOLDER_TYPES2["chart"] = "chart";
    PLACEHOLDER_TYPES2["table"] = "tbl";
    PLACEHOLDER_TYPES2["media"] = "media";
    return PLACEHOLDER_TYPES2;
  })(PLACEHOLDER_TYPES || {});
  var ANIMATION_PRESETS = {
    // Entrance effects (presetClass: 'entr')
    "appear": { presetId: 1, presetClass: "entr" },
    "fly-in": { presetId: 2, presetClass: "entr" },
    "blinds": { presetId: 3, presetClass: "entr" },
    "box": { presetId: 4, presetClass: "entr" },
    "checkerboard": { presetId: 5, presetClass: "entr" },
    "circle": { presetId: 6, presetClass: "entr" },
    "crawl": { presetId: 7, presetClass: "entr" },
    "diamond": { presetId: 8, presetClass: "entr" },
    "dissolve": { presetId: 9, presetClass: "entr" },
    "fade": { presetId: 10, presetClass: "entr" },
    "flash-once": { presetId: 11, presetClass: "entr" },
    "float": { presetId: 12, presetClass: "entr" },
    "glide": { presetId: 13, presetClass: "entr" },
    "grow-and-turn": { presetId: 14, presetClass: "entr" },
    "newsflash": { presetId: 15, presetClass: "entr" },
    "peek": { presetId: 16, presetClass: "entr" },
    "pinwheel": { presetId: 17, presetClass: "entr" },
    "plus": { presetId: 18, presetClass: "entr" },
    "random-bars": { presetId: 19, presetClass: "entr" },
    "random": { presetId: 20, presetClass: "entr" },
    "spiral": { presetId: 21, presetClass: "entr" },
    "split": { presetId: 22, presetClass: "entr" },
    "stretch": { presetId: 23, presetClass: "entr" },
    "strips": { presetId: 24, presetClass: "entr" },
    "swivel": { presetId: 25, presetClass: "entr" },
    "wedge": { presetId: 26, presetClass: "entr" },
    "wheel": { presetId: 27, presetClass: "entr" },
    "wipe": { presetId: 28, presetClass: "entr" },
    "zoom": { presetId: 29, presetClass: "entr" },
    "bounce": { presetId: 30, presetClass: "entr" },
    "expand": { presetId: 31, presetClass: "entr" },
    // Exit effects (presetClass: 'exit')
    "disappear": { presetId: 1, presetClass: "exit" },
    "fly-out": { presetId: 2, presetClass: "exit" },
    "fade-out": { presetId: 10, presetClass: "exit" },
    "zoom-out": { presetId: 29, presetClass: "exit" },
    // Emphasis effects (presetClass: 'emph')
    "pulse": { presetId: 1, presetClass: "emph" },
    "color-pulse": { presetId: 2, presetClass: "emph" },
    "teeter": { presetId: 3, presetClass: "emph" },
    "spin": { presetId: 4, presetClass: "emph" },
    "grow-shrink": { presetId: 5, presetClass: "emph" }
  };
  var ANIMATION_DIRECTIONS = {
    "from-bottom": 1,
    "from-bottom-left": 2,
    "from-left": 3,
    "from-top-left": 4,
    "from-top": 5,
    "from-top-right": 6,
    "from-right": 7,
    "from-bottom-right": 8,
    "horizontal": 9,
    "vertical": 10,
    "in": 16,
    "out": 32,
    "in-horizontal": 17,
    "in-vertical": 18,
    "out-horizontal": 33,
    "out-vertical": 34
  };
  var IMG_BROKEN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAB3CAYAAAD1oOVhAAAGAUlEQVR4Xu2dT0xcRRzHf7tAYSsc0EBSIq2xEg8mtTGebVzEqOVIolz0siRE4gGTStqKwdpWsXoyGhMuyAVJOHBgqyvLNgonDkabeCBYW/8kTUr0wsJC+Wfm0bfuvn37Znbem9mR9303mJnf/Pb7ed95M7PDI5JIJPYJV5EC7e3t1N/fT62trdqViQCIu+bVgpIHEo/Hqbe3V/sdYVKHyWSSZmZm8ilVA0oeyNjYmEnaVC2Xvr6+qg5fAOJAz4DU1dURGzFSqZRVqtMpAFIGyMjICC0vL9PExIRWKADiAYTNshYWFrRCARAOEFZcCKWtrY0GBgaUTYkBRACIE4rKZwqACALR5RQAqQCIDqcASIVAVDsFQCSAqHQKgEgCUeUUAPEBRIVTAMQnEBvK5OQkbW9vk991CoAEAMQJxc86BUACAhKUUwAkQCBBOAVAAgbi1ykAogCIH6cAiCIgsk4BEIVAZJwCIIqBVLqiBxANQFgXS0tLND4+zl08AogmIG5OSSQS1gGKwgtANAIRcQqAaAbCe6YASBWA2E6xDyeyDUl7+AKQMkDYYevm5mZHabA/Li4uUiaTsYLau8QA4gLE/hU7wajyYtv1hReDAiAOxQcHBymbzark4BkbQKom/X8dp9Npmpqasn4BIAYAYSnYp+4BBEAMUcCwNOCQsAKZnp62NtQOw8WmwT09PUo+ijaHsOMx7GppaaH6+nolH0Z10K2tLVpdXbW6UfV3mNqBdHd3U1NTk2rtlMRfW1uj2dlZAFGirkRQAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAGHqrm8caPzQ0WC1logbeiC7X3xJm0PvUmRzh45cuki1588FAmVn9BO6P3yF9utrqGH0MtW82S8UN9RA9v/4k7InjhcJFTs/TLVXLwmJV67S7vD7tHF5pKi46fYdosdOcOOGG8j1OcqefbFEJD9Q3GCwDhqT31HklS4A8VRgfYM2Op6k3bt/BQJl58J7lPvwg5JYNccepaMry0LPqFA7hCm39+NNyp2J0172b19QysGINj5CsRtpij57musOViH0QPJQXn6J9u7dlYJSFkbrMYolrwvDAJAC+WWdEpQz7FTgECeUCpzi6YxvvqXoM6eEhqnCSgDikEzUKUE7Aw7xuHctKB5OYU3dZlNR9syQdAaAcAYTC0pXF+39c09o2Ik+3EqxVKqiB7hbYAxZkk4pbBaEM+AQofv+wTrFwylBOQNABIGwavdfe4O2pg5elO+86l99nY58/VUF0byrYsjiSFluNlXYrOHcBar7+EogUADEQ0YRGHbzoKAASBkg2+9cpM1rV0tK2QOcXW7bLEFAARAXIF4w2DrDWoeUWaf4hQIgDiA8GPZ2iNfi0Q8UACkAIgrDbrJ385eDxaPLLrEsFAB5oG6lMPJQPLZZZKAACBGVhcG2Q+bmuLu2nk55e4jqPv1IeEoceiBeX7s2zCa5MAqdstl91vfXwaEGsv/rb5TtOFk6tWXOuJGh6KmnhO9sayrMninPx103JBtXblHkice58cINZP4Hyr5wpkgkdiChEmc4FWazLzenNKa/p0jncwDiqcD6BuWePk07t1asatZGoYQzSqA4nFJ7soNiP/+EUyfc25GI2GG53dHPrKo1g/1Cw4pIXLrzO+1c+/wg7tBbFDle/EbQcjFCPWQJCau5EoBoFpzXHYDwFNJcDiCaBed1ByA8hTSXA4hmwXndAQhPIc3lAKJZcF53AMJTSHM5gGgWnNcdgPAU0lwOIJoF53UHIDyFNJcfSiCdnZ0Ui8U0SxlMd7lcjubn561gh+Y1scFIU/0o/3sgeLO12E2k7UXKYumgFoAYdg8ACIAYpoBh6cAhAGKYAoalA4cAiGEKGJYOHAIghilgWDpwCIAYpoBh6cAhAGKYAoalA4cAiGEKGJYOHAIghilgWDpwCIAYpoBh6ZQ4JB6PKzviYthnNy4d9h+1M5mMlVckkUjsG5dhiBMCEMPg/wuOfrZZ/RSywQAAAABJRU5ErkJggg==";
  var IMG_PLAYBTN = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAVnCAYAAACzfHDVAAAAYHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjaVcjJDYAwDEXBu6ughBfH+YnLQSwSHVA+Yrkwx7HtPHabHuEWrQ+lBBAZ6TMweBWoCwUH8quZH6VWFXVT696zxp12ARkVFEqn8wB8AAAACXBIWXMAAC4jAAAuIwF4pT92AADZLklEQVR42uzdd5hV9Z0/8M+dmcsUZmDovYOhKCiKYhR7JJuoSTCWGFI0WUxijBoTTXazVlyza4maYm9rTRSJigVsqCDNQhHBAogKCEgRMjMMU+7vj93sL8kqClLmnPt6PY+PeXZM9vP9vO8jZ+Y955xMfJLjorBrRMuSgmiViyjN1Ee2oSCyucbIBAAAAAAAAADbXaYgcoWNUZcrirpMbdRsysa69wbF+rggGrf439vSF7seF12aFUTnxvoosGIAAAAAAACAXacgoqEgF++/VRgr4r5o+Kh/pvD//F8uiII+LaPrum/EXzqui2b1ddHGKgEAAAAAAAB2rVxEQWMmWrQtjHZlA6N2w2tR84//zP8pgHu3ib6NBdG+zdqorK6KVUXZaB85j3sGAAAAAAAAaAoaG6OwIBdtyneP2PBabPzbr/1dAdx3VHRtyESHiIhcYzQrLo7WmVzkcjmPgAYAAAAAAABoSgpy0eIfS+D/LYD7fy3abC6Inn/7X2hsjELlLwAAAAAAAEDT9D8lcM1fHwddFBFxyAVR9M686PVp/gfqayKiJiLqLBMAAAAAAABgh8hGRGlEUekn/6PFEb3ikNgQk6O+KCJi6dzoksv83/cB/1X9xoiaJdmoWxlRV1dk2QAAAAAAAAA7QTZbH9muERX96v7n9t7/q6Exinq3i86LI94pjOOisHUu+uYykfmof7h+Y8Sa6aVRt74gGhs9DRoAAAAAAABgZ2lsLIi69QWxeUUmSjs0/vedwR8hk4uydSfE+wVd6qOyMfMx7/mtj9jwUtbjngEAAAAAAAB2obrqolg7IxtR/9Ffb4wo7P5GtCwobRaVH/c/UvNmNuqqPfIZAAAAAAAAYFerqy6KmjezH/v1ktpoVZBr/PgCeMN7yl8AAAAAAACApmJLHW5jUVQWNDSP+Q3ZeLco4i9/+8X6teHRzwAAAAAAAABNSd3/dLn/oLAoqqIuVhXFxhhSGB/xqGjlLwAAAAAAAECTU1eTjaK/KXSLIv7SWB+bc5ko9YxnAAAAAAAAgATJFv393bz1EeV//c8F1gMAAAAAAACQDgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKREkRUAAACwrUpLSwuGDRvWfMCAAS26du3avKysrLiioqKkZcuWzZs1a1bcvHnz0tLS0rJsNtusuLi4ebNmzUoLCgo+8/eijY2N9Zs3b66pra2tqqur21xTU1NdVVVVs2nTptqNGzdWbdiwoeYvf/nL5hUrVlQtWLBgw6xZs6pqamoaJQYAAEDaKYABAACIiIghQ4aUHnTQQW379u3bql27dq3at2/fpkWLFq2bN29eWVpa2qpZs2bNCwsLm2ez2fLCwsLyoqKi8sLCwtKknK+hoaG6vr6+qqGh4S91dXV/aWhoqNq8eXNVTU3NuqqqqvUbNmxYu2rVqjWrV69e99Zbb6177rnnPpgzZ06NTwYAAABJogAGAADIA8OGDWt+xBFHdBwwYECnLl26dGjdunXHFi1adCgtLe1YUlLSvlmzZq0KCgqK07yDwsLCssLCwrKIaPdp/zuNjY21mzdvXrdp06ZVNTU172/YsGHl2rVr31+2bNnKBQsWrHjyySffnzVrVpVPGAAAAE1Fpuexsd9HfaF+ZcSal0ptCAAAIAE6deqUPf744zvtueeeXbp3796lbdu2XSorKzuXlpZ2KS0t7VBYWFhhSztGQ0PDxpqampU1NTXL169fv+yDDz5Y9s477yybPXv2sj/96U8rVqxYUWdLAAAAbE9t9q6Jog4f/TUFMAAAQEJks9nMt7/97Y4jRozo1bdv397t2rXrXl5e3rWsrKxzcXFx+4gosKUmp7G2tnZVTU3Nso0bNy5btWrV0tdff/2tJ598cvG999672noAAADYFgpgAACAhPne977X6a9Fb/v27Xu1bNmyV1lZWa8kvXOXLauvr9/wl7/8ZdG6desWL1u2bNHChQsX/fGPf1w8derUjbYDAADAliiAAQAAmqhsNps59dRTuxx66KH9+/Tp87n27dv3Ly8v719UVOSRzXlq06ZNKzZu3Pj6+++//8abb775xqOPPvrG3XffvcpmAAAA+CsFMAAAQBNx6qmndvniF784qHfv3v3btWv3uYqKis8VFhaW2wxbUl9fv37Dhg1vfPDBB68vXrz4jccee2z+jTfeuNxmAAAA8pMCGAAAYBc45phjWn/rW9/aq3///kPatGnTv6Kiop9HOLO9NDQ0VG/cuPGtNWvWLFy4cOGcO+6445WHHnporc0AAACknwIYAABgJzjjjDO6f+lLX9qrV69eg1u3bj2orKysR0RkbIadJFddXb103bp18xcvXjz30UcffeXqq69+x1oAAADSRwEMAACwnZWWlhb86le/2u3QQw8d1r17931btmw5qLCwsMxmaEoaGhqqP/zww/nvvPPOzGeeeWbW2LFj36ipqWm0GQAAgGRTAAMAAGwHP/7xj7t+9atf3bdXr15D27Ztu1c2m21jKyRJXV3dmg8++OCVRYsWvfznP/95xh/+8IdltgIAAJA8CmAAAIBtcOKJJ7Y75ZRTDujXr9+w1q1bD81ms61shTSpq6tbt3bt2pfffPPNWbfccsvUe++9d7WtAAAANH0KYAAAgE+hoqKi4IILLhg0YsSI/bp27bpfy5YtB2YymUKbIR/kcrmGDz/8cP6777474/nnn59x4YUXvrZx40aPiwYAAGiCFMAAAAAf4/jjj2/7/e9//8D+/fsf2Lp1630KCgpKbAUiGhsbN61fv37eW2+9NeWGG2545u67715lKwAAAE2DAhgAAOB/ZLPZzAUXXPC5I4888sDu3bsfWFFRsVtEFNgMbFl1dfWSd999d8qsWbNmnnvuuS+vW7euwVYAAAB2DQUwAACQ10pLSwsuvfTSQYcccsjBXbt2HVFWVtbDVmDb1dbWrnr//fdfmDp16uRf/vKXL65evbreVgAAAHYeBTAAAJB3Bg0aVHrBBRd8fs899zywQ4cOBxQVFbWwFdj+Ghsba9euXTtrzpw5T59//vmTX3755WpbAQAA2LEUwAAAQF4YNmxY8/POO+/gIUOGHOZ9vrDz/W0ZfNFFFz07a9asKlsBAADY/hTAAABAarVq1arwyiuv3HfEiBEjO3TocFBhYWGZrcCu19DQUP3+++8/O2XKlIk/+clPZm7cuLHRVgAAALYPBTAAAJAqrVq1Kvztb3+7/3777Xd4x44dRxQWFpbbCjRdDQ0NG99///0pM2bMeOqHP/zhC8pgAACAz0YBDAAApMJZZ53V45vf/OaRvXr1GllaWtrVRiB5ampq3l28ePHEO++8c9LVV1/9jo0AAABsPQUwAACQWMOHDy+/6KKLvjB48OCjW7RoMdBGID0+/PDDV+fNmzfhvPPOe3L69Ol/sREAAIBPRwEMAAAkSqtWrQpvuOGGQ/bbb79/atOmzX6ZTCZrK5BeuVyubs2aNTNmzJjx2JgxYyavW7euwVYAAAA+ngIYAABIhB//+Mddv/e9732lZ8+e/1RcXNzWRiD/1NbWfvD2228/dssttzz029/+9l0bAQAA+L8UwAAAQJNVUVFRcO21137+4IMPPrZ169b7ZTKZAlsBIqJxzZo1M59//vnxp5122hR3BQMAAPx/CmAAAKDJOeWUUzqefvrpx/bu3ftL2Wy2jY0AH6e+vn7j0qVLH/vd7373x+uvv36ZjQAAAPlOAQwAADQJ2Ww2c+uttx5wyCGHnNC6deu9I8LdvsDWaFy7du1L06ZN+/OPfvSjZ1evXl1vJQAAQD5SAAMAALtU//79S6655pp/2nPPPY8tLy/vayPAZ1VTU7NswYIF488999wHp06dutFGAACAfKIABgAAdomf//znPU855ZQTu3btemRhYWGZjQDbW2NjY92KFSuevOWWW+689NJLF9kIAACQDxTAAADATuMxz8Cusn79+rlPP/30f5188slT6+rqcjYCAACklQIYAADY4fr27Vv8hz/84a+Pee5nI8CuUlNT8+68efPu/8EPfvDgwoULN9kIAACQNgpgAABghxkyZEjpNddc89XBgwefWFxc3MFGgKaitrZ21dy5c+/5yU9+8uc5c+bU2AgAAJAWWyqAPYoNAADYJqNHj+4wb968n06ZMuXRYcOGnaH8BZqa4uLi9sOGDTtjypQpj86bN++nJ510UntbAQAA0s4dwAAAwFY599xze33/+9//dufOnY/IZDJZGwGSIpfL1S1fvvzJG2644fbLLrvsbRsBAACSyiOgAQCAz+y8887r+53vfOfbHTt2PDyTyRTaCJBUuVyuYcWKFU/cdNNN//XrX/96sY0AAABJowAGAAC22WWXXTboG9/4xg9at249zDaAtFm7du2su++++9pzzjnnNdsAAACSQgEMAABsNcUvkE8UwQAAQJIogAEAgE9N8Qvks7Vr18665557rvv5z38+3zYAAICmaksFcGHlwOj6UV9orIqoWZG1PQAAyBO/+MUvet9xxx3nHHrooT8pLS3tYiNAPiotLe2y7777HvP973+/X1lZ2ZIpU6assxUAAKCpKetcHwXlH/01BTAAAOS5M844o/u99957zpe//OWflZeX94qIjK0AeS5TXl7e8+CDDx71/e9/v3dEvDVjxowPrQUAAGgqFMAAAMD/ceKJJ7a77777fjJq1Kh/KS8v7xOKX4B/lCkvL+99+OGHj/rWt77VfvXq1Qvnz59fbS0AAMCutqUC2DuAAQAgzwwdOrTs+uuvP6l///4nFRYWltkI20NjY2Ns2rQpqquro6amJurr62PTpk2xefPmqK+vj+rq6qivr4/NmzfHpk2boqGhYZv/fxUWFkZJSUk0a9YsioqKoqysLIqKiqJZs2ZRUlISRUVFUVpa+r9/FRQUCIjtoqGhoeq11167a8yYMffMmTOnxkYAAIBdZUvvAFYAAwBAnujUqVP2nnvuGbXXXnudnM1mK22Ej9PQ0BAbN26MDRs2/J+/Nm7cGBs3boyamprYtGlTbNq0KWpqaqK2trbJnqe4uDhKSkqitLT0f/9eUVERFRUV0aJFi//zV0VFRRQWFvog8LHq6urWvvjii7eceOKJf169enW9jQAAADubAhgAAPLcXXfdddAXv/jF00tLS7vZRn7L5XKxYcOGWLt2baxbty7Wrl37d3+tW7cuNmzYkPd7atGiRbRu3TpatWoVrVu3jjZt2vzvf27dunW0aNHCh4morq5e+sgjj1zzne98Z6ptAAAAO5MCGAAA8tTVV189+MQTTzyzoqJioG3kj8bGxli5cmUsX748Pvjgg1i9evX//n3t2rXR2NhoSZ9RYWFhtGrVKtq1axdt27b937937tw5OnTo4LHTeWbDhg3z77333qvOPPPMebYBAADsDApgAADIM1/72tfaXHrppad27979qIjQRKVUQ0NDrFq1KlasWBHvv//+//595cqVTfqRzGlXXFwcHTp0iI4dO0bnzp2jY8eO0alTp2jXrp1HS6dYLpdrfOeddx76+c9/fv2ECRPW2QgAALAjKYABACBP9OrVq9ldd931jT322OM7hYWFZTaSHh9++GG88847sXTp0njvvfdixYoVsXr16mhoaLCchCgsLIz27dtHp06dolu3btG9e/fo3r27x0mnTENDQ9W8efNu++Y3v/nHJUuWbLYRAABgR1AAAwBAHrjrrrtG/NM//dOZJSUlXWwj2davXx9Lly6Nd955539L3w8//NBiUqqysvJ/y+C//tWqVSuLSbiamppljz322G9Gjx49xTYAAIDtTQEMAAAp9qtf/arPD3/4w5+1atVqL9tIno0bN8aSJUvirbfeikWLFsV7770XmzZtspg8V1JSEl27do0+ffpE3759o3fv3lFeXm4xCbRu3bqXr7322ivGjh27yDYAAIDtRQEMAAApNGjQoNI77rjju7vttttJBQUFWRtJhtWrV8ebb74ZixcvjiVLlsTy5cujsbHRYtiigoKC6Ny5c/Tu3Tt69+4d/fr1i7Zt21pMQjQ2Nta98cYbd33rW9+6ff78+TU2AgAAfFYKYAAASJHS0tKCBx988Jj99tvvn7PZbBsbaboaGhri7bffjrfeeisWLFgQS5YscXcv201FRUX06tUr+vbtG3379o2ePXtGYWGhxTRhdXV1a2bMmHHjV77ylYdqamr85gcAALDNFMAAAJASp59+erdf/vKX51ZWVu5jG03T6tWr47XXXouFCxfGm2++GRs3brQUdooWLVpE3759Y8CAATFw4EB3CDdh69evf/E//uM//vPqq69+xzYAAIBtoQAGAICEGzRoUOm99977w969ex+byWTc4teErF+/PubNmxcLFiyIN954Q+FLk9GiRYvo169fDBgwIPbYY4+orKy0lCYkl8s1LF68eNyJJ554rcdCAwAAW0sBDAAACXbNNdcMOemkk35RVlbWyzZ2vVwuF++++27MnTs3XnvttViyZIl3+NLkFRQURK9evWLQoEExePDg6Natm6U0EdXV1UvuvvvuX//kJz+ZYxsAAMCnpQAGAIAEOuqoo1r99re//VmHDh0Ot41da9OmTTF79uyYO3duLFy4MKqqqiyFRGvevHn0798/Bg8eHHvuuWeUlJRYyi62cuXKp04//fTLJ0yYsM42AACAT6IABgCAhBk3btwRRxxxxFnZbLaNbewaVVVVMXfu3Jg7d27Mnz8/amtrLYVUKi4ujoEDB8bgwYNj8ODBUV5ebim7SF1d3ZqnnnrqqlGjRj1hGwAAwJYogAEAICFOOeWUjhdddNEvW7duvZ9t7HwrV66MWbNmxdy5c+Odd96JXC5nKeSdzp07x9577x3Dhg2LDh06WMgusHbt2hnnnXfepbfccsv7tgEAAHwUBTAAADRxpaWlBU899dQ3Bw8e/L2CggLPYt2JVqxYES+99FK89NJLsXz5cguBv/HXMnjvvfeOTp06WchO1NjYuGnu3Lk3H3744XfV1NR40TgAAPB3FMAAANCEjR49usOll176yzZt2gy3jZ1j/fr18eKLL8bMmTNj6dKlFgKfQs+ePWPfffeNYcOGRYsWLSxkJ1mzZs0L55577q/vvvvuVbYBAAD8lQIYAACaoIqKioKJEyd+c/Dgwd8vKCgotpEda8OGDfHiiy/G9OnTlb7wGfXo0SOGDx8ew4YNi4qKCgvZwdwNDAAA/CMFMAAANDGnnHJKx7Fjx/5rZWXlMNvYcerr6+PVV1+NGTNmxLx586Kurs5SYDvKZrMxZMiQ2HfffWP33XePwsJCS9mB1q5dO+MXv/jFv995550rbQMAAPKbAhgAAJqIbDabeeKJJ47fZ599fuSu3x0jl8vFwoULY/r06TF79uzYtGmTpcBOUFpaGkOGDInhw4fHgAEDLGQHaWhoqJ42bdo1Rx555J9tAwAA8pcCGAAAmoDjjz++7ZVXXvmr1q1be9fvDrBmzZqYNm1azJw5M1audHMc7EodO3aMz3/+87H//vt7X/CO+3fetDPPPPOScePGfWAbAACQfxTAAACwi9100037HXvssf9WXFzc1ja2n1wuF6+99lo8//zzMW/evKivr7cUaEKKiopizz33jBEjRsTnPve5yGQylrId1dbWrvrjH/948Q9+8INZtgEAAPlFAQwAALvIkCFDSu+///5zunTp8k+2sf2sXbs2Jk+eHNOnT48PP/zQQiABKisrY8SIEXHIIYdEeXm5hWxHy5Yte+zrX//6f86ZM6fGNgAAID9sqQAurBwYXT/qC41VETUrsrYHAADb6IILLtjt97///VVt2rQZZhvbx+LFi2P8+PFx9913xxtvvBG1tbWWAgmxadOmeOONN+LZZ5+NtWvXRps2bTweejtp0aJFv5NOOumg0tLSuc8+++xaGwEAgPQr61wfBR/zu7XuAAYAgO0sm81mJk2a9PVhw4b9pKCgwG9VfkZ1dXUxY8aMeOaZZ+K9996zEEiRfv36xSGHHBJDhw6NgoICC/mMGhsbN8+YMeOaL37xi+Pq6upyNgIAAOnlEdAAALCTHH/88W2vuuqqCyorK/exjc9mzZo18dRTT8XUqVNj06ZNFgIpVlFREZ///OfjsMMOi8rKSgv5jNavXz/r9NNPv3DcuHEf2AYAAKSTAhgAAHaC22677fNf+9rXzstms5W2se0WLVoUjz/+eMybNy9yOTewQT4pKiqKIUOGxBFHHBG9e/e2kM+grq5u3QMPPHDRySefPM02AAAgfRTAAACwA1VUVBQ8/fTTpwwcOPCUTCbjGabbIJfLxauvvhpPPvlkLFy40EIgz2UymRgwYEAcccQRMWjQIAvZ9n+3Ns6fP/+Www8//JaNGzc22ggAAKTHlgrgwsqB0fWjvtBYFVGzwuvKAABgS0488cR2EyZMuLx79+5fzmQyGRvZOo2NjTFr1qy49dZb48knn4wPPvC0UuC/rV69OmbMmBFz5syJ0tLS6NSpU/jX7NbJZDKZ9u3bD/3+978/dPny5TNfffXValsBAIB0KOtcHwXlH/O9gDuAAQBg29x66637H3vssRcWFRW1sI2tU1NTE0899VQ8++yzsWHDBgsBPlGLFi3i4IMPjsMPPzxKS/28YmvV19d/OG7cuPNPPvnk6bYBAADJ5xHQAACwHWWz2cyzzz77rSFDhvzAI5+3zqZNm2Ly5Mnx1FNPKX6BbdKiRYs47LDD4pBDDlEEb6VcLtfwyiuvXHfooYfeWVdX5yXrAACQYApgAADYTo455pjW11133cWVlZV728ant2HDhnj88cdjypQpUVtbayHAZ1ZcXBwHHnhgfPGLX4wWLTyIYWusWbNm2re//e3zn3nmGb+JAwAACeUdwAAAsB1cfvnlu1900UW/LS8v72cbn05VVVVMmDAhbrnllnjzzTejoaHBUoDtoqGhIZYsWRLPPfdc1NTURI8ePSKb9XOMT6OsrKzb17/+9SPbtm0774knnlhtIwAAkMDreu8ABgCAz+bhhx/+8qGHHnpOQUFBsW18sk2bNsUzzzwTTzzxRFRVVVkIsMOVl5fHkUceGYccckgUF/tX9afR2Ni46emnn/71Mccc87htAABAsngENAAAbKN27doVTZ48+YxevXodZxufrK6uLp5++umYOHGi4hfYJSoqKuKLX/xiHHzwwe4I/pQWLVr0x4MOOuiadevWeUwDAAAkhEdAAwDANjj22GPbPvzww7/p2LHjobaxZXV1dfHkk0/GddddF3Pnzo26ujpLAXaJzZs3x2uvvRbPPfdcRET06NEjCgsLLWYLWrduvfv3vve9fd9+++1pCxYsqLYRAABo+rb0CGgFMAAAfITLL7989wsuuOB3zZs372UbH6+xsTGmTJkS119/fbzyyiuKX6DJ2Lx5cyxYsCCmT58excXF0a1bt8hkMhbzMUpKSjp8+ctfPrJt27ZzvBcYAACaPu8ABgCArTB+/Pgjv/CFL/xLQUFBiW18vAULFsT48eNj6dKllgE0eT169IivfOUrMWjQIMvYgsbGxpqJEydecuyxxz5pGwAA0HR5BzAAAHwK7dq1K3ruued+1qNHj6/axsdbtGhR3H///bF48WLLABKnV69ecdxxx0WfPn0sYwuWLl3654MOOujy1atX19sGAAA0Pd4BDAAAn2DYsGHNn3766V936tTpC7bx0TZs2BD33Xdf/PGPf4y1a9daCJBI69evj2nTpsW6deuiZ8+eUVLiYQ8fpbKysv+3v/3t/lOmTJmyfPlyz/cHAIAmxjuAAQBgC372s5/1uP76669t0aKF54J+hJqamhg/fnzcfPPN8fbbb0cul7MUINFyuVy888478cwzz0RVVVX07t07slk/A/lHZWVl3U488cTD6+rqZkyfPv1DGwEAgCZ0va4ABgCAj3bFFVfscdZZZ11dXFzcwTb+Xi6XixkzZsR1110XCxYsiMbGRksBUqWxsTGWLFkSM2bMiPLy8ujSpUtkMhmL+RvZbLbFQQcddHibNm1mP/HEE6ttBAAAmoYtFcDeAQwAQN6aNGnSqAMOOODsTCZTaBt/b9GiRXHPPffEu+++axlA3ujWrVucdNJJ0bt3b8v4B7lcrm7y5Mm//vKXv/yIbQAAwK63pXcAK4ABAMg7paWlBTNnzjyzT58+x9vG39uwYUOMGzcuZsyY4VHPQF7KZDKx3377xde//vWoqKiwkH+waNGiP+27775X1dTUeCwEAADsQgpgAAD4H926dctOnjz5V506dRppG/9fLpeLqVOnxp///OfYuHGjhQB5r6KiIkaNGhX777+/x0L/g+XLlz9+6KGHXvLuu+/W2QYAAOwaWyqAvQMYAIC8MXz48PInnnjiynbt2o2wjf/vnXfeiWuvvTaee+652Lx5s4UARMTmzZtjzpw58dprr0XPnj2jRYsWlvI/Kioq+n7rW98aMnXq1Ofee+89f3AAAMAusKV3ACuAAQDIC9/+9rc73n777X9o0aLFANv4b1VVVXHXXXfFvffeG+vXr7cQgI+wbt26eP7552P9+vWx2267RVFRkaVERElJSefjjjvuoA8++GDKK6+88hcbAQCAnUsBDABAXjv//PP7XXzxxX8oKSnpbBv/bfr06XHttdfGokWLLAPgU3jnnXdi2rRp0bp16+jc2R8nERHZbLbyC1/4whElJSUvTp48eY2NAADAzqMABgAgb/3ud7/b60c/+tFVRUVFrWwjYs2aNXHzzTfHpEmTora21kIAtkJtbW289NJL8c4770Tfvn2jtLQ073dSWFhYNnz48C/26dNn4UMPPbTMpwQAAHYOBTAAAHnp1ltv3f+b3/zmfxYWFjbP913kcrl4/vnn4/rrr4/ly5f7cAB8BitXroxp06ZFRUVFdOvWLTKZTF7vo6CgIDto0KBDBw0atOiBBx54xycEAAB2vC0VwJmex8Z+H/WF+pURa17ym6wAACTTww8//KXDDjvsXzKZTN6/rPGDDz6I22+/Pd544w0fDIDtbMCAAfGtb30r2rRpk/e7yOVyjVOmTPn1yJEjH/LJAACAHavN3jVR1OGjv6YABgAgdV555ZXTPve5z30r3/fQ0NAQjz32WDz++ONRV1fngwGwg2Sz2Tj66KPjC1/4QhQUFOT9Pl5//fU79tprr9/7ZAAAwI6jAAYAIC9ks9nMyy+/fFafPn2Oz/ddvPvuu3HbbbfFe++954MBsJN069YtvvOd70S3bt3yfhdLliy5f5999rmypqam0ScDAAC2PwUwAACpV1paWjBr1qyzevfufVw+7yGXy8WTTz4ZDz74oLt+AXaBbDYbxxxzTBxxxBF5fzfw0qVLHxg6dOjlSmAAANj+FMAAAKRar169mk2ePHlsu3btDsrnPaxcuTJuueWWePvtt30oAHaxnj17ximnnBIdOnTI6z2sXr16yiGHHPIvS5Ys2exTAQAA28+WCuDCyoHR9aO+0FgVUbMia3sAADRpQ4cOLXvqqacub9Omzf75uoNcLhfPPPNMXH/99bF27VofCoAmYP369TFlypQoKSmJnj17RiaTycs9NG/evPtJJ500ZPLkyc+sWLHCoykAAGA7KetcHwXlH/01BTAAAIk1ZMiQ0kceeeSKVq1a7Z2vO6iuro7bb789nnjiiWhs9IRNgKaksbEx5s+fH++//34MGDAgstn8/DlLaWlpp6997WuDn3rqqadXrlxZ75MBAACfnQIYAIDUOfTQQ1s8+OCDv2/ZsuUe+bqDOXPmxNVXX+2RzwBN3PLly+OFF16Ijh075u0joUtLSzudcMIJ+7/00ktPv/3227U+FQAA8NkogAEASJVhw4Y1v++++37TsmXLQfl4/vr6+hg/fnz88Y9/jNpaP0MHSILNmzfHiy++GJs3b47ddtstCgoK8m4HxcXFbY866qg9n3vuuaeXL1/ucdAAAPAZKIABAEiNI488snLcuHG/b9GixcB8PP97770XV111VcyZM8eHASCBFi1aFC+//HL069cvWrRokXfnLykp6XDcccftP2fOnGcWLVq0yScCAAC2jQIYAIBUOPLIIyvvvPPO35aXl++Wj+d/+umn48Ybb4wPP/zQhwEgwf7yl7/ECy+8ECUlJdGrV6+8O3+zZs3aHHXUUfspgQEAYNspgAEASLxjjz227W233faH5s2b98m3s1dVVcXNN98cTz31VDQ2NvowAKRAY2NjzJ8/P5YtWxYDBgyIZs2a5dX5mzVr1uaYY4458M0333xm4cKFNT4RAACwdRTAAAAk2qGHHtritttuuzofy9+33347rrnmmli8eLEPAkAKvf/++/HKK69Enz59orKyMq/Ons1mK4888sh9Zs6c+dTSpUs3+zQAAMCnpwAGACCxjjjiiJb33nvvteXl5f3y6dy5XC4mTZoUN998c1RVVfkgAKRYVVVVTJ06NbLZbPTp0ycymUzenL24uLjtV7/61c+/8sorTy1evLjWpwEAAD4dBTAAAIl06KGHtrj33nt/l2/lb3V1ddx0000xefLkyOVyPggAeSCXy8WCBQvi3Xffjd133z2y2fz5mUyzZs1aH3300fvNmDHjSXcCAwDAp6MABgAgcYYOHVo2fvz4qysqKgbk07mXLVsWV111lUc+A+SplStXxiuvvBKf+9znoqKiIm/O3axZszZHH3300GeeeebJFStW1PkkAADAlimAAQBIlCFDhpQ++uij17Rs2XL3fDr31KlT49prr42NGzf6EADksaqqqpg+fXq0bds2unTpkjfnLikpaT9q1KihTz755JMrV66s90kAAICPt6UCuMB6AABoSjp16pSdMGHCv1dWVu6RL2dubGyMcePGxR133BF1dW56AiCitrY2br755hg/fnw0NjbmzbkrKyv3mDBhwr9369bNXQkAALCNFMAAADQZrVq1Kpw+ffolbdq02T9fzlxdXR2/+93vYtKkSd73C8DfyeVy8fjjj8fvf//7qK6uzptzt2nTZv8pU6Zc0qpVq0KfAgAA2HoKYAAAmoSKioqC2bNnX9KuXbuD8uXMS5cujYsuuijmz5/vAwDAx3r11VfjoosuiqVLl+bNmdu1a3fQ7Nmz/72iosLPrgAAYCu5iAYAoEmYOXPmz9q1a3dIvpz35ZdfjiuuuCLWrVsnfAA+0bp16+KKK66Il19+OW/O3K5du4Nnzpz5M+kDAMDWUQADALDLvfjii2N69OgxKh/Omsvl4oEHHogbbrghamtrhQ/Ap1ZbWxs33HBDPPDAA3nz2oAePXqMevHFF8dIHwAAPj0FMAAAu9SkSZO+NnDgwFPy4ax1dXVx8803x8SJE73vF4BtksvlYuLEiXHLLbdEXV1dXpx54MCBJ0+aNOlr0gcAgE9HAQwAwC7z6KOPHnXggQeekw9nXbduXfz617+OWbNmCR6Az2zmzJnx61//Ol9eJZA58MADz3n00UePkjwAAHyywsqB0fWjvtBYFVGzImtDAADsEDfeeOO+Rx999EWZTKYw7Wddvnx5XHXVVbFy5UrBA7DdbNiwIWbPnh0DBw6MioqKtB8307179/179uz56sMPP7xc+gAA5LuyzvVRUP7RX1MAAwCw011xxRV7fPe7372qoKCgWdrPOmfOnPjtb38bGzduFDwA2111dXVMmzYtOnfuHB07dkz1WTOZTOHuu+9+eJs2bV6aNGnSKukDAJDPFMAAADQZZ5xxRvef/exnvy0sLCxP+1knTJgQd999d9TX1wsegB2moaEhXnrppchms9G3b99UnzWTyRTttddeB/3lL395dubMmRukDwBAvlIAAwDQJBx00EEVf/jDH64pLi7ulOZz5nK5eOCBB+Kxxx4TOgA77c+eBQsWRF1dXfTv3z8ymUxqz1pQUFBywAEHDJs+ffqkpUuXbpY+AAD5aEsFcIH1AACwMwwaNKj0vvvuu7qsrKxXms9ZV1cX1113XUyaNEnoAOx0EydOjOuvvz7q6upSfc6ysrJef/rTn67u379/idQBAODvKYABANjhKioqCh577LGLKyoqBqb5nNXV1XHNNdfE7NmzhQ7ALvPKK6/ElVdeGVVVVak+Z4sWLQZOnDhxbEVFhZ9vAQDA33CBDADADjdz5syftW3b9sA0n3HdunVx2WWXxRtvvCFwAHa5xYsXx2WXXRZr165N9TnbtWt34MyZM38mcQAA+P8UwAAA7FBPPvnkqB49eoxK8xlXrVoVV1xxRSxfvlzgADQZK1asiCuuuCJWrlyZ6nP26NFj1KRJk0ZJHAAA/lth5cDo+lFfaKyKqFmRtSEAALbZjTfeuO+XvvSlCzOZTGp/8fDdd9+NK6+8MtatWydwAJqc6urqmDVrVvTv3z8qKytTe85u3boN79mz57yHH37Yb2MBAJAXyjrXR0H5R39NAQwAwA5x3nnn9T311FOvLigoKE7rGV977bW45pprorq6WuAANFmbN2+OGTNmRI8ePaJ9+/apPGMmkykYNGjQIYWFhVOee+45v5UFAEDqKYABANipjjrqqFb/8R//8YdmzZq1SusZX3755bj++uujrq5O4AA0eQ0NDfHSSy9Fp06dolOnTqk8Y0FBQXbYsGGfnz9//qQ33nhjk9QBAEizLRXA3gEMAMB21a1bt+wNN9zwnyUlJR3TesYpU6bEjTfeGPX19QIHIDHq6+vjxhtvjKlTp6b2jCUlJZ1uuOGG/+jWrZu7GgAAyFsKYAAAtqunn376XyorK/dI6/kmTZoUd955ZzQ2NgobgMRpbGyMO+64I5588snUnrGysnLw008//UtpAwCQrxTAAABsN88///w3unTp8k9pPd/EiRNj3LhxkcvlhA1AYuVyubj//vtTXQJ36dLlS88+++yJ0gYAIB95BzAAANvFTTfdNPzII488L5PJZNJ4vsceeyzGjx8vaABS47XXXotmzZpF3759U3m+zp0779urV695Dz/88DJpAwCQNlt6B7ACGACAz+wXv/hF7x/+8IdXFxQUNEvj+R544IF45JFHBA1A6ixYsCDq6upiwIABqTtbJpPJDBo06ODGxsbnpk6dul7aAACkiQIYAIAd5oADDqj43e9+99tmzZq1TeP5xo0bF5MmTRI0AKm1aNGi2Lx5cwwcODB1ZysoKMjut99+w5577rnH33vvvc3SBgAgLbZUAHsHMAAA2yybzWbuvPPOfyktLe2exvNNmDBB+QtAXpg0aVI89NBDqTxbaWlpj3vuuedfstlsRtIAAOQDBTAAANvs+eef/06HDh0OTePZHn744Xj44YeFDEDeeOSRR+LPf/5zKs/WoUOHw5599tlvSxkAgHygAAYAYJvcd999hw8ePPjUNJ7t/vvvjwkTJggZgLzz2GOPxX333ZfKs+25554/+NOf/nSYlAEASDvvAAYAYKudccYZ3ceMGXN5QUFBcdrONnHixHjkkUeEDEDeWrx4cWSz2ejbt2/ajpbp06fPvn/5y18mz5w5c4OkAQBIsi29A1gBDADAVhk2bFjzG2+88Q/NmjVrl7azPfroo6l99CUAbI2FCxdGUVFR9OvXL1XnKigoKD7wwAP3e/LJJx9dsWJFnaQBAEiqLRXAHgENAMBWuffee39ZWlraPW3nevzxx+PBBx8UMAD8jz//+c8xceLE1J2rtLS0x3333fdLCQMAkFYKYAAAPrVJkyaN6tSp0xEpPFeMHz9ewADwD8aPHx+TJ09O3bk6der0hUmTJn1VwgAApJFHQAMA8Kmcd955fU888cR/z2QyRWk618yZM+Puu+8WMAB8jNdeey06duwYnTt3TtW5unbtuk9BQcHzzz333DopAwCQNN4BDADAZ3LEEUe0vOKKK67NZrOVaTrXyy+/HDfffHPkcjkhA8DHyOVyMXv27OjSpUt06tQpNefKZDJF++yzz/CpU6c+9u67726WNAAASeIdwAAAbLNsNpu55ZZb/q2kpKRjms61YMGCuPnmm6OxsVHIAPAJGhsb4+abb44333wzVecqLS3tcvfdd5+fzWYzUgYAIC0UwAAAbNGkSZO+3rZt2wPTdKZly5bFDTfcEPX19QIGgE+prq4urr322li+fHmqztWuXbsDH3/88VESBgAgLTwCGgCAj3XZZZcN+upXvzo2k8mk5hcH33///bjyyiujqqpKwACwlerq6uLll1+OIUOGRHl5eWrO1aVLl31LS0unPvPMM2ukDABAEngENAAAW61///4lJ5988q8ymUxRWs60YcOG+P3vfx8bN24UMABso40bN8bvfve7VP15WlBQkP3hD394ft++fYslDABA4q9vrQAAgI/y4IMPnl1WVtYrLeeprq6O3/zmN7Fq1SrhAsBntGrVqrjyyiujuro6NWcqKyvr8/DDD58lXQAAkk4BDADA/zF+/Pgju3XrdnRazlNfX5/KdxYCwK60fPnyuO6666K+vj41Z+rRo8dXx40bd4R0AQBIMgUwAAB/53vf+16nI4444py0nCeXy8Vtt90Wb7zxhnABYDt7/fXX47bbbotcLpeaMx155JHnfvvb3+4oXQAAkkoBDADA/6qoqCi4+OKLLywsLCxPy5nGjx8fs2bNEi4A7CCzZs2Khx56KDXnKSwsrPj1r399QUVFhZ+bAQCQSC5kAQD4XxMnThxdWVk5OC3nef7552PixImCBYAd7LHHHosXXnghNeeprKzc89FHHz1RsgAAJFFh5cDo+lFfaKyKqFmRtSEAgDxxwQUX7DZq1KgLM5lMYRrO8+qrr8Ytt9ySqkdSAkBT/7O3d+/e0a5du1Scp2PHjkNzudxzU6ZMWSddAACamrLO9VHwMc/wcwcwAADRt2/f4h//+McXZzKZVPwG4HvvvRc33HBDNDY2ChcAdpKGhoa47rrrYtmyZak4T0FBQfbss88e27dv32LpAgCQqGtZKwAAYPz48T8qKyvrkYazbNiwIX7/+99HbW2tYAFgJ9u0aVP8/ve/j40bN6biPGVlZb3GjRs3RrIAACSJAhgAIM/ddNNNw/v06XN8Gs5SX18f1157baxdu1awALCLrFmzJq699tqor69PxXn69ev3jd///vdDJQsAQFIogAEA8thBBx1Uceyxx/5rRGTScJ477rgjFi9eLFgA2MUWLVoUd955Z1qOU/CNb3zj34YNG9ZcsgAAJOIC1goAAPLXzTfffFZxcXG7NJxl4sSJMX36dKECQBMxbdq0mDRpUirOUlJS0unOO+88Q6oAACSBAhgAIE/913/914FdunT5UhrO8tprr8Wf//xnoQJAEzN+/PhYsGBBKs7SrVu3o2+66abhUgUAoKlTAAMA5KEvfelLlV/5yld+lYazrFixIq6//vpobGwULAA0MY2NjXHdddfFihUr0nCczHHHHfergw46qEKyAAA0ZQpgAIA8dPXVV5+ezWYrk36OmpqauPbaa2PTpk1CBYAmatOmTXHttddGTU1N4s+SzWbb3njjjT+RKgAATZkCGAAgz9x6663Du3Tp8uWknyOXy8Utt9wSK1euFCoANHErV66MW2+9NXK5XOLP4lHQAAA0dQpgAIA8MnTo0LKvfvWrv0jDWSZMmBBz584VKgAkxJw5c+Kxxx5LxVlGjRr1i6FDh5ZJFQCApkgBDACQR+64444fFRcXd0z6OV5++eV45JFHBAoACfPQQw+l4he4SkpKOt5xxx0/lCgAAE2RAhgAIE9cfvnlu/fs2XNU0s/xwQcfxB133JGKR0gCQL7J5XJx2223xZo1axJ/lp49ex57+eWX7y5VAACaGgUwAEAe6NatW/a73/3uv2YymURf/9XX18cNN9wQ1dXVQgWAhKqqqoobb7wx6uvrE32OTCZT8N3vfvdX3bp1y0oVAICmRAEMAJAHxo8ff0pZWVmvpJ/jnnvuiaVLlwoUABJuyZIlcd999yX+HGVlZT3Hjx9/ikQBAGhKFMAAACn385//vOeAAQNGJ/0c06dPjylTpggUAFJi8uTJMWPGjMSfY8CAAaN//vOf95QoAABNhQIYACDFstls5qyzzjo3k8kk+tGEK1asiLvvvlugAJAyd911V6xYsSLRZ8hkMtmzzjrr3Gw2m5EoAABNgQIYACDFxo0b98XKysq9knyG2trauOGGG6K2tlagAJAyf/1zfvPmzYk+R2Vl5V7jxo0bKVEAAJoCBTAAQEoNHz68/OCDDz4t6ee4//77Y/ny5QIFgJRavnx5jBs3LvHnGDFixI+HDRvWXKIAAOxqCmAAgJS69dZbT8tms22TfIYZM2bEc889J0wASLnJkyfHzJkzE32G4uLitrfffvtp0gQAYFdTAAMApNBVV121R48ePb6S5DOsXLky7rrrLmECQJ64++6744MPPkj0GXr27PnVK664Yg9pAgCwKymAAQBSprS0tOAb3/jGT5N8rdfY2Bi333679/4CQB6pqamJ2267LRobG5N8jIJvfvObZ5aWlvqZGwAAu+6i1AoAANJlwoQJX6uoqBiQ5DOMHz8+Fi1aJEwAyDNvvvlmPPjgg4k+Q4sWLQY9+OCDx0gTAIBdRQEMAJAiRx55ZOWwYcN+kOQzzJ07N5544glhAkCemjhxYixYsCDRZxg+fPiPjjjiiJbSBABgV1AAAwCkyBVXXHFyUVFRRVLnr6qqijvvvDNyuZwwASBP5XK5uP3226O6ujqxZygqKmrxm9/85mRpAgCwKyiAAQBS4vzzz+/Xu3fv45J8httvvz0+/PBDYQJAnlu3bl3cfvvtiT5D7969jz///PP7SRMAgJ1NAQwAkALZbDZz6qmn/jyTyST2+m769OkxZ84cYQIAERExe/bsmDFjRmLnz2QyBaeeeurPs9lsRpoAAOxMCmAAgBT44x//eERlZeXgpM6/du3auPfeewUJAPyde+65J9atW5fY+SsrKwf/6U9/+oIkAQDYmRTAAAAJ17dv3+JDDjnkR0k+w9133x01NTXCBAD+Tk1NTdx9992JPsPBBx/8o759+xZLEwCAnUUBDACQcHfdddc3S0pKOiV1/smTJ8e8efMECQB8pLlz58azzz6b2PlLSko63nPPPd+SJAAAO4sCGAAgwb70pS9VDhw48KSkzr9mzZoYP368IAGALXrggQdizZo1iZ2/f//+Jx111FGtJAkAwM6gAAYASLArrrji1MLCwvIkzp7L5eK2226LTZs2CRIA2KJNmzbFbbfdFrlcLpHzFxYWll1++eU/kCQAADuDAhgAIKF+8Ytf9O7evftXkjr/s88+G2+88YYgAYBP5Y033ojnn38+sfN369bt6F/96ld9JAkAwI6mAAYASKgf/vCHP8pkMom8nvvggw/igQceECIAsFXGjRsX69atS+TsmUym4NRTT/2xFAEA2NEUwAAACXTdddcNa9eu3YFJnD2Xy8Udd9wRtbW1ggQAtsqmTZvizjvvTOz8bdq02f+mm27aT5IAAOxICmAAgIQpLS0t+NrXvnZ6Uud/4YUXYuHChYIEALbJq6++GjNmzEjs/Mccc8zpFRUVfiYHAMAO42ITACBhbr/99oMrKip2S+LsGzZsiHHjxgkRAPhM7r///qiqqkrk7OXl5X3/67/+6wgpAgCwoyiAAQASpKKiouCwww47Nanz33vvvYn9YS0A0HRs2LAh7r///sTOf9BBB/1zq1atCiUJAMCOoAAGAEiQ+++//+iysrKeSZx9zpw58dJLLwkRANguXnjhhViwYEEiZy8tLe32xz/+8StSBABgR1AAAwAkRN++fYv33Xfff07i7LW1tXHvvfcKEQDYru6+++6oq6tL5Oz77bffKf379y+RIgAA25sCGAAgIW6++eZRxcXFbZM4+yOPPBJr164VIgCwXa1atSoee+yxRM6ezWbb3njjjV+TIgAA25sCGAAgAYYOHVq21157fSeJs7/33nvxxBNPCBEA2CEmTpwYK1asSOTsQ4YM+c7QoUPLpAgAwPakAAYASIBrr732xKKiosqkzZ3L5eKee+6JxsZGIQIAO0R9fX3cddddkcvlEjd7UVFR5bXXXnuCFAEA2J4UwAAATdwBBxxQMWDAgG8kcfYZM2bEW2+9JUQAYId6880348UXX0zk7AMGDPjG8OHDy6UIAMD2ogAGAGjirrrqqhOKiooqkjb3pk2b4oEHHhAgALBT3H///VFbW5u4uYuKilpcffXV7gIGAGC7UQADADRhBx10UEX//v0Teffvww8/HB9++KEQAYCdYv369TFhwoREzj5w4MBvHHDAARVSBABge1AAAwA0Yf/5n/95bGFhYfOkzb1q1aqYPHmyAAGAnerpp5+O1atXJ27uwsLC8ssuu2yUBAEA2B4UwAAATdQBBxxQMWjQoNFJnP3uu++O+vp6IQIAO1V9fX3cddddiZx99913/+bQoUPLpAgAwGelAAYAaKIuv/zyYwsLC8uTNvfcuXNjwYIFAgQAdokFCxbE3LlzEzd3UVFRi9/97ndflyAAAJ+VAhgAoAkaOnRo2aBBgxL37t+6urr405/+JEAAYJf605/+FHV1dYmbe/fdd//mkCFDSiUIAMBnoQAGAGiCfvOb33ylqKioZdLmfu655xL53j0AIF1Wr14dzz33XOLmLioqann11VcfLUEAAD4LBTAAQBPTq1evZoMHD/5m0uaurq6ORx55RIAAQJPwyCOPRHV1deLmHjJkyLe6deuWlSAAANtKAQwA0MTcdNNNxxQXF7dN2twTJkyIqqoqAQIATUJVVVUifzmtuLi43a233uouYAAAtpkCGACgCWnVqlXhXnvtdVLS5l61alU8++yzAgQAmpTJkyfHqlWrEjf30KFDR7dq1apQggAAbAsFMABAE3LLLbccXlJS0jlpcz/44INRX18vQACgSamvr48HH3wwcXOXlJR0vummmw6VIAAA20IBDADQRGSz2cwBBxzw7aTNvWjRonjppZcECAA0SS+99FIsXrw4cXOPGDHiO9lsNiNBAAC2lgIYAKCJuOaaa/YuLy/vm7S5H3roocjlcgIEAJqkXC6XyLuAy8vL+1111VV7SRAAgK2lAAYAaCK+8pWvfDdpM8+bNy8WLlwoPACgSVu4cGG8+uqrrg8BAMgLCmAAgCbgsssuG1RZWblPkmbO5XIxfvx44QEAifDAAw8k7qklrVu33veSSy7pLz0AALaGAhgAoAkYNWrUCUmbefbs2bFs2TLhAQCJsGzZsnjllVcSN/cJJ5xwovQAANgaCmAAgF3sn//5nzt37NjxiCTN3NjYGA888IDwAIBEGT9+fDQ0NCRq5k6dOn1h9OjRHaQHAMCnpQAGANjFfvSjH30tk8kk6rps2rRpsWrVKuEBAImyatWqeOGFFxI1cyaTKfzpT386SnoAAHxaCmAAgF1o0KBBpX369Plqkmaur6+PCRMmCA8ASKQJEyZEXV1dombu27fvV/r27VssPQAAPg0FMADALnTZZZcdXlRUVJGkmadOnRpr164VHgCQSOvXr48pU6YkauaioqLK3/zmN0dIDwCAT0MBDACwi2Sz2cy+++57UpJmrqurc/cvAJB4jz76aOLuAt5///1PymazGekBAPBJFMAAALvI1VdfPbSsrKx3kmaeMmVKbNiwQXgAQKJt2LAhnn/++UTNXFZW1ueqq67aS3oAAHwSBTAAwC7y5S9/+bgkzVtfXx8TJ04UHACQCo8//nji7gL+0pe+dLzkAAD4JApgAIBdYPTo0R3atm07IkkzT5s2LdatWyc8ACAVPvzww5g+fXqiZm7fvv2I0aNHd5AeAABbogAGANgFfvrTn47KZDKFSZm3vr4+HnnkEcEBAKnyyCOPRH19fWLmzWQyhT/96U+/JjkAALZEAQwAsJN16tQp26dPn6OTNLO7fwGANFq3bl1MmzYtUTP36dPnmE6dOmWlBwDAx1EAAwDsZFddddUB2Wy2dVLmbWxsjEmTJgmOVOvYsWN06OCJmgD5aNKkSdHY2JiYebPZbOurrrrqAMkBAPBxFMAAADvZiBEjvp6keV988cVYtWqV4Ei1Ll26xIUXXhinnXZadO3a1UIA8siqVavipZdecj0JAEBqKIABAHaiM844o3tlZeXeSZk3l8vFxIkTBUdeyGQyMXjw4PjVr34VY8aMcUcwQB55/PHHI5fLJWbeysrKvc8444zukgMA4KMogAEAdqJTTjnlqxGRScq8CxYsiPfee09w5JVMJhN77713XHjhhTFmzJho3769pQCk3HvvvRcLFy5M1B9X/3NdCQAA/4cCGABgJ+nVq1ezXr16fTlJM3v3L/nsr0XwBRdcECeffHK0bdvWUgBSLGnXPb169fpyr169mkkOAIB/pAAGANhJrrjiioOLiopaJmXeBN4JAztEYWFhDB8+PC688MIYPXp0VFZWWgpACi1YsCCWLVuWmHmLiopaXnnllYdIDgCAf6QABgDYSYYPH/6VJM2btHfhwY5WVFQUI0aMiEsuuSRGjx4dLVu2tBSAFMnlcvH4448naub99tvvK5IDAOAfKYABAHaC0aNHd6isrByalHnXrl0bL7/8suDgI/y1CL744ovjhBNOiBYtWlgKQEq89NJLsW7dusTMW1lZudfo0aM7SA4AgL+lAAYA2AlOP/30o5J07fXMM89EQ0OD4GALiouL47DDDouxY8fGqFGjoqyszFIAEq6hoSGeeeaZJI1c8D/XmQAA8P8vEq0AAGDHymazmX79+n05KfPW1tbGlClTBAefUnFxcYwcOTIuvfTSGDVqVJSWlloKQII9//zzUVtbm5h5+/Xr9+VsNpuRHAAAf6UABgDYwX7zm9/sWVJS0jkp886YMSOqq6sFB1uppKQkRo4cGZdcckkcffTRUVJSYikACVRdXR0zZ85M0p8/na+44orBkgMA4K8UwAAAO9gXvvCFLyVl1lwuF08//bTQ4DNo3rx5HHXUUXHJJZfEyJEjI5vNWgpAwjz11FORy+USM++RRx75ZakBAPBXCmAAgB1oyJAhpZ07dz4iKfO+/vrrsWLFCsHBdlBeXh6jRo2KSy+9VBEMkDArVqyI119/PTHzdunS5fD+/ft79AQAABGhAAYA2KHGjh17aGFhYWJeCOruX9j+KioqYtSoUXHxxRfH4YcfHkVFRZYC4LpouyosLGz+H//xHwdLDQCACAUwAMAOteeeex6ZlFnXrl0b8+bNExrsIK1atYrjjz8+LrroohgxYkQUFPh2DKApmzdvXqxZsyYx8+61115HSg0AgAgFMADADnPMMce0bt269b5Jmfe5556LxsZGwcEO1qZNmxg9enRcfPHFimCAJqyxsTGee+65JP35MvyYY45pLTkAAPykAQBgBznzzDMPz2Qyibjeqq+vj6lTpwoNdqK2bdvG6NGj47zzzovhw4crggGaoBdeeCHq6+sTMWsmkyk844wzDpUaAAB+wgAAsIP079//C0mZdc6cObFhwwahwS7QqVOnOPnkk+Pf/u3fYu+9945MJmMpAE3Ehg0bYvbs2YmZd8CAAR4DDQCAAhgAYEf43ve+16mysnKPpMybpMcbQlp17tw5xowZE7/61a8UwQBNyPPPP5+YWSsrKwd/73vf6yQ1AID8pgAGANgBTj755CMiIhHtzcqVK+P1118XGjQRXbt2jTFjxsQ555wTgwcPthCAXez111+PlStXJmXczMknn3y41AAA8psCGABgB+jXr19iHv88ZcqUyOVyQoMmpnfv3nHaaafFOeecE/3797cQgF0kl8vFlClTknQd6jHQAAB5TgEMALCdnX766d0qKip2S8Ks9fX1MW3aNKFBE9anT58466yz4pxzzonddtvNQgB2gWnTpkV9fX0iZq2oqNjt9NNP7yY1AID8pQAGANjORo8efURSZp03b15s3LhRaJAAffr0ibPPPjvOPPPM6Nmzp4UA7EQbN26MefPmuR4FACARFMAAANtZr169EvPetSQ9zhD4bwMGDIhf/vKXceaZZ0b37t0tBGAnmTp1apKuRw+TGABA/lIAAwBsR2eccUb38vLyvkmYdf369fHaa68JDRJqwIAB8S//8i9x2mmnRbdunvQJsKPNnz8/Pvzww0TMWl5e3u9HP/pRF6kBAOQnBTAAwHZ03HHHHZSUWWfMmBGNjY1CgwTLZDIxePDg+Nd//dcYM2ZMdOjQwVIAdpDGxsaYMWNGYub9xje+cYjUAADykwIYAGA76tOnz8FJmDOXyyXqMYbAlmUymdh7773jwgsvjDFjxkT79u0tBWAHeOGFF5J0XXqIxAAA8pMCGABgOznppJPat2zZcvckzLpkyZJYuXKl0CBl/loEX3DBBXHyySdH27ZtLQVgO1qxYkW8/fbbiZi1srJy0PHHH+8PAgCAPKQABgDYTr773e8eGBGZJMyapMcXAluvsLAwhg8fHhdeeGGMHj06KisrLQVgO5k+fXpSRi34/ve/f6DEAADyjwIYAGA72X333Q9Nwpz19fUxc+ZMgUEeKCoqihEjRsQll1wSo0ePjpYtW1oKwGc0c+bMqK+vT8SsAwcOPFRiAAD5RwEMALAdHHTQQRUtW7bcKwmzLly4MKqrq4UGeeSvRfDFF18cJ5xwQrRo0cJSALZRVVVVvP7664mYtVWrVkOHDx9eLjUAgPyiAAYA2A7OPvvsz2cymaIkzOrxz5C/iouL47DDDouxY8fGqFGjoqyszFIAtkFSnqaSyWSy55577uclBgCQXxTAAADbwe67735AEuasra2NOXPmCAzyXHFxcYwcOTIuvfRSRTDANpg9e3bU1dUlYtY99tjjAIkBAOQXBTAAwGfUqlWrwnbt2u2fhFnnzZsXtbW1QgMiIqKkpCRGjhwZY8eOjaOPPjpKSkosBeBT2LRpU8ybNy8Rs7Zv337/iooKPwMEAMgjLv4AAD6jCy+8cPeioqKKJMz64osvCgz4P5o3bx5HHXVUXHLJJTFy5MjIZrOWAvAJZs2alYg5i4qKWlx88cWDJAYAkD8UwAAAn9GBBx6YiMfqVVdXJ+ZOFWDXKC8vj1GjRsWll16qCAb4BPPmzYuamppEzHrQQQd5DDQAQB5RAAMAfEZdu3YdnoQ5582bF/X19QIDPlFFRUWMGjUqLr744jj88MOjqKjIUgD+QV1dXbz66quJmLVLly77SwwAIH8ogAEAPoNTTjmlY3l5+W5JmPXll18WGLBVWrVqFccff3xcdNFFMWLEiCgo8C0kwN966aWXEjFnRUXFbieddFJ7iQEA5AffvQMAfAYnnnji55MwZ21tbcyfP19gwDZp06ZNjB49OsaOHasIBvgb8+fPj9ra2iSMmvnud7/7eYkBAOQH37UDAHwGn/vc5/ZLwpwLFy6Muro6gQGfyV+L4PPOOy+GDx+uCAby3ubNm2PhwoWJmLVfv37DJQYAkB98tw4AsI1atWpV2Lp1672TMKvHPwPbU6dOneLkk0+Oc889NwYNGmQhQF6bPXt2IuZs06bN3hUVFX4WCACQB1z0AQBso/PPP39gYWFheVOfs76+PubMmSMwYLvr2bNn/OQnP4nzzjsv9t5778hkMpYC5J3Zs2dHfX19k5+zqKio4vzzzx8oMQCA9FMAAwBso/3333/fJMz5+uuvR01NjcCAHaZLly4xZsyYOOecc2Lw4MEWAuSV6urqeOONNxIx64EHHriPxAAA0k8BDACwjbp27ZqIxz/PnTtXWMBO0bt37zjttNPinHPOif79+1sIkDeScr3VvXv3vaUFAJB+CmAAgG0wZMiQ0srKyj2a+py5XM7jn4Gdrk+fPnHWWWfFOeecE7vttpuFAKk3e/bsyOVyTX7Oli1b7jlo0KBSiQEApJsCGABgG5x55pl7ZjKZbFOfc9myZbFu3TqBAbtEnz594uyzz44zzzwzevbsaSFAaq1bty6WL1/e5OfMZDLZs846a4jEAADSrcgKAAC23tChQ4clYc558+YJC9jlBgwYEAMGDIgFCxbE+PHjY+nSpZYCpM68efOiS5cuTX7OffbZZ5+ImC4xAID0cgcwAMA26Nix4z5JmHP+/PnCApqMAQMGxC9/+cs47bTTolu3bhYCpEpSrrs6deq0j7QAANJNAQwAsJWOOOKIlhUVFf2a+pxVVVWxaNEigQFNSiaTicGDB8e//uu/xpgxY6JDhw6WAqTCW2+9FVVVVU1+zoqKis8deuihLSQGAJBeCmAAgK108sknD46ITFOfc/78+dHY2CgwoEnKZDKx9957x4UXXhhjxoyJ9u3bWwqQaI2NjbFgwYJE/Cv4u9/97h4SAwBILwUwAMBW2n333fdMwpze/wskwV+L4AsuuCBOPvnkaNu2raUAiZWU66/BgwfvKS0AgPQqsgIAgK3Trl27wU19xlwul5Q7UAAiIqKwsDCGDx8e++yzT0ybNi0mTJgQ69evtxggURYsWBC5XC4ymab9sJgOHToMlhYAQHq5AxgAYCsMGjSotGXLlgOa+pzvvfdebNy4UWBA4hQVFcWIESPikksuidGjR0fLli0tBUiMDz/8MJYtW9bk52zZsuXA/v37l0gMACCdFMAAAFvhxz/+8aBMJtPkn6Li7l8g6f5aBI8dOzZOOOGEaNGihaUAibBw4cImP2Mmk8n+5Cc/GSAtAIB0UgADAGyFvffee88kzJmEHzwCfBrNmjWLww47LMaOHRujRo2KsrIySwGatKT8Il5SrmsBANh63gEMALAVunbtOqSpz1hfXx9vvvmmsIBUKS4ujpEjR8bBBx8czz77bDz++ONRXV1tMUCT8+abb0Z9fX0UFTXtH7t16dJlT2kBAKSTO4ABAD6lioqKgoqKikFNfc4lS5bE5s2bBQakUklJSYwcOTLGjh0bRx99dJSUeIUl0LTU1tbG0qVLm/ycLVu2HFRaWupngwAAKeQiDwDgUzr77LP7FhYWNvlnj7722mvCAlKvefPmcdRRR8Ull1wSI0eOjGbNmlkK4HpsKxQWFpafffbZvaQFAJA+CmAAgE9p//3375+EOV9//XVhAXmjvLw8Ro0aFf/+7/8eI0eOjGw2aymA67FP6fOf//xAaQEApI8CGADgU+rRo8fuTX3G2traePvtt4UF5J2KiooYNWpUXHzxxXH44Yc3+XdvAum2ePHiRLySo1evXoOkBQCQPgpgAIBPqXXr1k3+DoklS5ZEQ0ODsIC81apVqzj++OPj4osvjhEjRkRBgW97gZ2voaEhlixZ0uTnbNOmjQIYACCFfCcMAPApDBkypLR58+a9m/qcb775prAAIqJ169YxevToGDt2rCIYcF32MZo3b95n0KBBpdICAEgX3wEDAHwKp556av9MJtPkr53eeustYQH8jTZt2sTo0aPjvPPOi+HDhyuCAddlfyOTyRT84Ac/+Jy0AADSxXe+AACfwuDBg5v84/Hq6+tj0aJFwgL4CJ06dYqTTz45/u3f/i323nvvyGQylgLsUIsXL07Eqzn23HPPgdICAEgXBTAAwKfQpUuXAU19xnfeeSfq6uqEBbAFnTt3jjFjxiiCgR2utrY23n333SRc53oPMABAyiiAAQA+hZYtW/Zv6jN6/DPAp9elS5cYM2ZMnHvuuTF48GALAfL2+iwJ17kAAGwdBTAAwCcYPnx4eUlJSeemPqfHPwNsvV69esVpp50W55xzTvTvrwMB8u/6rLS0tPPw4cPLpQUAkB4KYACAT/Ctb31rt4ho8s8IXbx4sbAAtlGfPn3irLPOinPOOSd22203CwG2i4T8gl7m29/+dj9pAQCkhwIYAOAT7L777k2+CVi7dm1s2LBBWACfUZ8+feLss8+OM888M3r27GkhwGfy4Ycfxrp165r8nAMHDlQAAwCkSJEVAABsWadOnZr8D8TefvttQQFsRwMGDIgBAwbEggULYvz48bF06VJLAbb5Oq1Vq1audwEA2GkUwAAAn6CyslIBDJCnBgwYEP3794958+bFQw89FO+++66lAFtlyZIlsddeezX1613PvgcASBEFMADAFnTq1CnbvHnzXk19ziVLlggLYAfJZDIxePDg2GOPPeLll1+OBx98MFauXGkxQGqu05o3b967Xbt2RatXr66XGABA8nkHMADAFowZM6ZnJpPJNuUZGxsbPZoUYCfIZDKx9957x4UXXhhjxoyJ9u3bWwrwiZYuXRqNjY1NesaCgoLsqaee2kNaAADp4A5gAIAt2Hvvvfs29RlXrlwZtbW1wgLYSf5aBO+5554xa9asmDBhQqxevdpigI9UW1sb77//fnTu3LlJzzls2LC+EbFIYgAAyecOYACALejRo0eTL4DfeecdQQHsAoWFhTF8+PC48MILY/To0VFZWWkpQGKv15Jw3QsAwKejAAYA2ILWrVs3+ff/vvvuu4IC2IUKCwtjxIgRcckll8To0aOjZcuWlgIk7notCde9AAB8Oh4BDQCwBc2bN+/Z1GdUAAM0kW+wi4pixIgRsd9++8WUKVPiscceiw0bNlgMEO+9914SrnsVwAAAKeEOYACAj9G/f/+SkpKSjk19TgUwQNPSrFmzOOyww2Ls2LExatSoKCsrsxTIc0m4XistLe3Ut2/fYmkBACSfAhgA4GOccMIJ3Zr69dK6deuiqqpKWABNUHFxcYwcOTJ+/etfK4Ihz1VVVcX69eub+pgF3/zmN7tLCwAg+RTAAAAfY8iQIT2b+oxJeJwgQL77axE8duzYOProo6OkpMRSIA8l4botCde/AAB8MgUwAMDH6N69e8+mPqPHPwMkR/PmzeOoo46KSy65JEaOHBnNmjWzFMgjSbhuS8L1LwAAn0wBDADwMVq1atWjqc+4bNkyQQEkTHl5eYwaNSr+/d//PUaOHBnZbNZSIA8k4botCde/AAB8MgUwAMDHqKio6NXUZ1y+fLmgAJL750yMGjUqLr744jj88MOjqKjIUiDFknDd1rJly16SAgBIPgUwAMBHyGazmbKysq5NecbGxsZYtWqVsAASrlWrVnH88cfHxRdfHCNGjIiCAt+qQxqtWrUqGhsbm/SMJSUlXbPZbEZaAADJ5rtKAICPcNxxx7UrKCgobsozrl69Ourr64UFkBKtW7eO0aNHx9ixYxXBkEJ1dXXxwQcfNOkZCwoKio877rh20gIASDbfTQIAfITPf/7zXZr6jO+//76gAFKoTZs2MXr06Dj//PNj+PDhimBIkRUrVrgOBgBgh/NdJP+PvTuPr7I888d/nSwEkhD2HUQEUVRAoIiouCtq64Jabd1arVorbqO2tlXbaavTOu38Rqffdmpbu9rWpYogsqgFRXCttAIKArJDgAAJBLKQ5JzfH8WO4+DOcp6T9/v18jWvTv657ut6hNvnk/t+AICd2G+//bL+xVcSXiAC8PF17do1Lr300rj99ttj2LBhkUq5lRWSLgn7tyTsgwEAeH8FWgAA8H917txZAAxAVujevXtceeWVsXr16njiiSdi9uzZkclkNAYSKAn7tyTsgwEAeH8CYACAnWjXrp0roAHIKj169Igrr7wyli5dGpMmTYo5c+ZoCiRMEvZvSdgHAwDw/gTAAAA7UVxc3D3baxQAAzRPffr0ibFjx8aSJUti/PjxsWDBAk2BhEjC/i0J+2AAAN6fbwADAOxESUlJz2yur7q6Ourq6gwKoBnbb7/94l/+5V/ia1/7WhxwwAEaAglQV1cX1dXV9sEAAOxWAmAAgHc5/PDDSwsKCtpmc40VFRUGBUBERPTt2zduvPHGuOGGG2LffffVEMhy2b6PKygoaDt8+PASkwIASC4BMADAu5x44oldsr3GDRs2GBQA/8uAAQPiG9/4Rtxwww3Ru3dvDQH7uE+yH+5qUgAAyeUbwAAA79KvX7+sD4DXr19vUADs1IABA+LAAw+MuXPnxoQJE2LlypWaAlkkCTe5HHDAAV0i4i3TAgBIJgEwAMC7dO/evXO21+gEMADvJ5VKxaBBg2LgwIExe/bsGD9+fKxbt05jwD4uZ/bDAAC8NwEwAMC7tG/fvlO21ygABuDDSKVSMWzYsBg6dGjMnj07HnvsMbdIwF6WhBPASdgPAwDw3gTAAADv0rp166w/8ZCEF4cAZI+3g+BDDz00XnnllZg4caK/S8A+LtH7YQAA3psAGADgXUpKSrL6xENjY2Ns3rzZoAD4yPLz8+Pwww+P4cOHx/PPPx8TJ06MqqoqjYE9aPPmzdHY2BgFBdn7Wi7b98MAALw/ATAAwLu0bNmySzbXV1lZGZlMxqAA+Njy8/Nj1KhRMXLkyHjhhRcEwbAHZTKZqKqqio4dO9oPAwCwWwiAAQDepaioKKuvvKusrDQkAHaJgoKCGDVqVIwYMSJmzpwZkydPji1btmgM7IH9XDYHwNm+HwYA4P3laQEAwP8YPnx4SX5+fkk21ygABmBXa9GiRRx//PFxxx13xNlnnx0lJSWaAs14P5efn18yfPhwfxAAACSUABgA4B2OOOKIDtleo+//ArC7FBUVxejRo+P73/9+nH322VFcXKwpsBsk4cr1JOyLAQDYOQEwAMA79O3bt1221+gEMAC729tB8B133BGnn356tGrVSlOgme3n9ttvv7YmBQCQTAJgAIB36NSpkwAYAHYoKSmJz3zmM3HnnXfG6NGjo0WLFpoCzWQ/l4R9MQAAOycABgB4hw4dOrTN9hqTcGUgALmlpKQkzj777PjOd74To0aNivz8fE2BHN/PJWFfDADAzgmAAQDeoaysrG221ygABmBvad++fVx00UVx5513xgknnBCFhYWaAjm6nysrK3MCGAAgoQTAAADvUFJS0j6b68tkMlFdXW1QAOxV7dq1i/POOy+++93vxqhRoyIvz+sF+CiSsJ8rLS0VAAMAJJT/QgMAeIfi4uK22VxfXV1dNDY2GhQAWeHtE8F33HGHIBg+gsbGxqirq7MvBgBgt/BfZgAA79CqVausPung9C8A2ahDhw5x0UUXxbe//e04/PDDBcGQA/u6oqIiJ4ABABLKf5EBALxDQUGBABgAPqauXbvGpZdeGt/61rdi2LBhkUqlNAUSuq9r0aJFW1MCAEimAi0AAPgfhYWFZdlc39atWw0JgKzXrVu3uPLKK2P16tXxxBNPxOzZsyOTyWgMJGhfl+37YgAA3psAGADgnZujgoLW2VyfE8AAJEmPHj3iyiuvjKVLl8akSZNizpw5mgIJ2ddl+74YAID35gpoAIAdWrdunZefn98ym2sUAAOQRH369ImxY8fGLbfcEgMGDNAQSMC+Lj8/v1WrVq28OwQASCCbOACAHQYNGlQSEVn9scJt27YZFACJtd9++8UNN9wQX/va1+KAAw7QEJq1BOzr8gYPHlxsUgAAySMABgDY4YADDijJ9hpramoMCoDE69u3b9x4441xww03xL777qshNEu1tbVZX2P//v1LTQoAIHl8AxgAYIeePXtm/QuuJLwoBIAPa8CAATFgwICYP39+jBs3LpYvX64pNBtJ2Nf16NGjxKQAAJJHAAwAsEOnTp0EwACwFwwYMCAOPPDAmDt3bkyYMCFWrlypKeS8JOzrunbtKgAGAEggATAAwA5lZWVZ/4Krrq7OoADISalUKgYNGhQDBw6M2bNnx4QJE2Lt2rUaQ85KQgDcpk0bV0ADACSQABgAYIeysjIngAFgL0ulUjFs2LAYOnRozJ49O8aPHx/r1q3TGHKOABgAgN1FAAwAsENJSUlxttfoBDAAzcXbQfCQIUPi5ZdfjokTJ0ZFRYXGkDOSEAAnYX8MAMD/JQAGANihqKioKNtrrKmpMSgAmpW8vLw4/PDDY/jw4fH888/HE088EZWVlRpD4iUhAG7RokWRSQEAJI8AGABgh8LCwhbZXF86nY7t27cbFADNUn5+fowaNSpGjhwZL7zwQkycODGqqqo0hsTavn17ZDKZSKVSWVtjixYtWpgUAEDyCIABAHbI9gC4oaHBkABo9goKCmLUqFExYsSImDlzZkyePDm2bNmiMSROJpOJhoaGyOaMtbCw0AlgAIAk/neTFgAA7NgYFRRk9QuuxsZGQwKAHVq0aBHHH398HHnkkfHMM8/E1KlTY9u2bRpDomR7AJzt+2MAAN5jH6cFAAA7NkZZ/oLL9c8A8H8VFRXF6NGj49hjj41nnnkmpkyZEjU1NRpDImT7DS8FBQWugAYASCABMADA2xujLH/B5QpoAHhvbwfBRx11VEyfPj2efvrpqK2t1RiymgAYAIDdIU8LAAD+QQAMAMlXUlISn/nMZ+LOO++M0aNHZ/X1uiAABgBgdxAAAwDskO1XQAuAAeDDKykpibPPPjv+7d/+LUaPHh2FhYWagv3dR5Sfn9/SlAAAkkcADADw9sYoL88JYADIMa1bt46zzz47vve978UJJ5wgCMb+7iPIz8/3LwwAQAIJgAEAdkilUlm9N2psbDQkAPiY2rVrF+edd15897vfjRNOOCEKCgo0Bfu7D94f55sSAEDyCIABAHbI9gA4nU4bEgB8Qu3bt/9nEDxq1KjIy/NqBPu799kfp0wJACB5/FcOAMAOXnABQPPRoUOHuOiii+J73/ueIJi9JpPJZHuJ/sUAAEggmzgAgP+R1QFwAl4QAkDidOzYMS666KL41re+FYcffnj4fTDs796xOc7yG3IAANg5mzgAgITsjQTAALD7dOvWLS699NL41re+FcOGDRMEs0dk+xXQeXl5/kUAAEigAi0AAPiHbH/BJQAGgN2ve/fuceWVV8ayZcviiSeeiDlz5mgKzXl/5/AIAEACCYABAHbIZDJOAAMAERGx7777xtixY2PJkiUxYcKEmD9/vqZgfwwAQCIIgAEA/ocr7gCA/2W//faLG264Id56660YP358vPnmm5rCLpPtV0Cn3IUOAJBIAmAAgB2y/QVXtr8gBIBc1rdv37jxxhvjrbfeinHjxsWiRYs0hU/MFdAAANjEAQDsXln9Bs4BDADY+/r27Rs333xz3HDDDdG7d28NIdf3d75BAgCQQE4AAwDskO0nMATAAJA9BgwYEAMGDIj58+fHI488EitXrtQUcnF/5woaAIAEcgIYAGCHVCqVzvL6DAkAssyAAQPi1ltvjbFjx0bPnj01hJza32UScEc1AAD/lxPAAAD/QwAMAHysv6MHDRoUBx98cDz//PMxadKk2LRpk8aQ+P1dtv+CJAAAO+cEMADADul0dr/fEgADQHarr6+PioqK2LZtm2aQE/u7dDrtBDAAQAI5AQwA8D+cAAYAPrK6urp4+umnY9q0acJfcm1/5wQwAEACCYABAP6HEw4AwIfW0NAQ06ZNiyeffDK2bt2qIXxkCfgGsAAYACCBBMAAADtkMpmsDoDz8ny9AwCywdvB71NPPRXV1dUaQs7u7wTAAADJJAAGANgh219wCYABYO9qbGyMGTNmxJNPPhmVlZUawieWn5+f9VtkUwIASB4BMADADplMpiGb6yssLDQkANgL0ul0zJo1KyZPnhwbN27UEHaZgoLsfjXX1NTUaEoAAAncZ2oBAMA/NDY2bs/m+gTAALBnpdPpePnll2Py5Mmxdu1aDWGXa9GiRbb/O1BvSgAAySMABgDYoampSQAMAEQmk4nZs2fH448/HuXl5RpCs93fNTY2CoABABJIAAwAsENDQ0NWv+ASAAPA7vV28PvEE0/E6tWrNYTdLtuvgM72G3IAAHiPfaYWAAD8gyugAaD5mjNnTkyaNCmWLl2qGewx2X4FtAAYACCZBMAAADs0NTU5AQwAzcyCBQtiwoQJ8dZbb2kG9nfv0tDQIAAGAEggATAAwA7Z/oJLAAwAu87ChQtj/PjxsXjxYs1gr8n2K6Cz/RckAQB4j32mFgAA/EO2B8AFBQWRl5cX6XTasADgY1q+fHmMGzcu5s+frxnsVXl5eVkfAG/fvt0JYACABBIAAwDs0NDQkPUnHFq1ahXbtm0zLAD4iFauXBmPPPKI4Jes2tclYH8sAAYASCABMADADrW1tXXZXqMAGAA+mnXr1sX48eNj9uzZkclkNISs2tdlu7q6ulqTAgBIHgEwAMAOW7du3ZrtNSbhRSEAZIP169fHY489JvjFvu4TqK6u3mpSAADJIwAGANihqqpKAAwACbdhw4Z4/PHH45VXXommpiYNwb7uE6isrHT1DABAAgmAAQB22LRpU9a/4GrZsqVBAcBOVFVVxcSJE+OFF16IxsZGDSHrJSEA3rRpkxPAAAAJJAAGANhh3bp1WR8AOwEMAP/bli1bYsKECYJfEicJ+7ry8nIBMABAAgmAAQB2WLZsmSugASAhqqurY/LkyTFz5syor6/XEBInCfu6pUuXCoABABJIAAwAsMP8+fOz/gRwcXGxQQHQrNXU1MSUKVPimWeeEfySaEnY173++uu+AQwAkEACYACAHRYsWFCXyWQaUqlUYbbW2Lp1a4MCoFmqq6uLp59+OqZNmxbbtsmkSL5s39el0+mGpUuXbjcpAIDkEQADALxDU1PTtoKCgrbZWp8AGIDmZvv27TF9+vR48sknY+tWt9GSO7J9X9fU1ORfOACAhBIAAwC8Q0NDw9ZsDoBLS0sNCYDm8ndyTJs2LZ566qmorq7WEHJOtu/rGhsb/YsHAJBQAmAAgHeor6+vbNWqVc9src8JYAByXWNjY8yYMSOefPLJqKys1BByVrbv6+rr66tMCQAgmQTAAADv0NDQkNVvmgXAAOSqdDods2bNismTJ8fGjRs1hJyX7fu6bN8XAwDw3gTAAADvUFdXV5XN9ZWWlkYqlYpMJmNYAOSETCYTr732Wjz++OOxatUqDaFZSKVSUVJSktU11tbWVpkUAEAyCYABAN5h27Ztm7K5vvz8/GjVqlXU1NQYFgCJlslkYvbs2fH4449HeXm5htCstGrVKvLz87O6xq1btzoBDACQUAJgAIB3qK6u3pztNZaVlQmAAUist4PfiRMnxpo1azSEZqmsrCzra9y2bVuVSQEAJJMAGADgHaqqqjZle43t2rWLtWvXGhYAiTNnzpyYNGlSLF26VDNo1tq1a5f1NW7atMkJYACALNbQWBgFjQ0REZFKRSavMJre/pkAGADgHSoqKqqyvcYkvDAEgHdasGBBTJgwId566y3NgITs5zZs2CAABgDIYoUFDf9MejMRqab0/+S+AmAAgHdYtWpV1r/oatu2rUEBkAgLFy6M8ePHx+LFizUD3iEJAfDq1aurTAoAIJkEwAAA77BgwYKsD4CdAAYg2y1fvjzGjRsX8+fP1wzYiST8Ql8S9sUAAOycABgA4B2eeOKJjZlMpimVSuVna41OAAOQrVauXBmPPPKI4Bc+QLb/Ql8mk2l64oknNpoUAEAyCYABAN6huro6vX379g1FRUVdsrVGJ4AByDZr166NCRMmxOzZsyOTyWgIJHw/t3379g3V1dVpkwIASCYBMADAu9TV1a0XAAPAB1u/fn089thjgl/Isf1cXV3delMCAEguATAAwLvU1dVVtGnTJmvrKykpiRYtWsT27dsNC4C9oqKiIiZOnBivvPJKNDU1aQh8BEVFRVFcXJz1+2GTAgBILgEwAMC7bN26dV2XLll7ADhSqVR07Ngx1qxZY1gA7FFVVVUxceLEeP755wW/8DF17NgxUqlU1u+HTQoAILkEwAAA71JVVZX1Jx46deokAAZgj9m8eXM8/vjj8cILL0RjY6OGwCfcx9kPAwCwOwmAAQDeZf369Vn/zbMkvDgEIPm2bNkSU6ZMiZkzZ0Z9fb2GwC7QsWNH+2EAAHYrATAAwLusXr066088JOHFIQDJVVNTE1OmTIlnnnlG8Au7WBJ+kW/VqlUCYACABBMAAwC8y9///ves/+aZABiA3aG2tjYmT54czz77bNTV1WkINNN93KuvvioABgBIMAEwAMC7PPzww+t//OMfN6RSqcJsrbFz584GBcAus3379pg+fXpMnTo1tm3bpiGwG2X7CeB0Ot3w8MMPC4ABABJMAAwA8C7V1dXpurq68latWu2TrTV26NAh8vLyIp1OGxgAH1tDQ0NMmzYtnnrqqaiurtYQ2M3y8vKiQ4cOWV1jfX39mtraWptMAIAEEwADAOxEbW3tmmwOgAsKCqJdu3axceNGwwLgI2tsbIwZM2bEk08+GZWVlRoCe0j79u2joCC7X8fV1NSUmxQAQLIJgAEAdmLz5s2r2rdvn9U1duvWTQAMwEeSTqdj1qxZMXnyZH+HwF7av2W7LVu2rDQpAIBkEwADAOzEpk2bVvfp0yera+zWrVvMmzfPsAD4QG8Hv1OmTIkNGzZoCOzF/Vu227BhwxqTAgBINgEwAMBOrFixYvWwYcOyusYkvEAEYO/KZDLx0ksvxZQpU6K83K2usLd17do162tctWrVKpMCAEg2ATAAwE7Mnz9/9ZgxY7K6xiS8QARg78hkMjF79uyYOHFirFnjMB9kiyT8At+8efP8oQEAkHACYACAnRg3btyab37zm5mISGVrjU4AA7Azc+bMiSeeeCKWLVumGZBlEvALfJlx48atNikAgGQTAAMA7MTrr79e29DQsKmwsLBDttZYXFwcZWVlsWXLFgMDIBYsWBDjx4+PJUuWaAZkobKysiguLs7qGhsaGjYuWLCgzrQAAJJNAAwA8B62bt26vF27dh2yucauXbsKgAGauYULF8b48eNj8eLFmgFZLAm3t2zbtm25SQEAJJ8AGADgPVRVVS1t167d0GyusWfPnrFw4ULDAmiGli1bFo899ljMnz9fMyABevbsmfU1VlZWLjUpAIDkEwADALyHdevWLevTp09W15iEF4kA7ForVqyIRx99VPALCZOEfdvatWuXmRQAQPIJgAEA3sPChQuXHX744VldY69evQwKoJlYtWpVjB8/PubOnRuZTEZDIGGSsG9buHDhMpMCAEg+ATAAwHuYNm3a0ksuuSSra+zevXvk5+dHU1OTgQHkqHXr1sX48eNj9uzZgl9IqIKCgkR8A/jpp59eZloAADmw/9QCAICde+ihhzbcd999W/Pz80uzdjNXUBBdunSJNWvWGBhAjqmoqIiJEyfGyy+/HOl0WkMgwbp27RoFBdn9Gq6xsbH6kUce2WBaAADJJwAGAHgf27ZtW15WVnZwNtfYq1cvATBADqmqqoqJEyfG888/74YHyBFJ+P7vtm3blpsUAEBuEAADALyPLVu2LMv2ALhnz57x0ksvGRZAwm3evDkef/zxeOGFF6KxsVFDIIck4fu/W7ZsWWpSAAC5QQAMAPA+1q9fvyzbT2z06NHDoAASbMuWLTFlypSYOXNm1NfXawjkoCTs19avX7/MpAAAcoMAGADgfSxYsGDh0KFDs7rGfffdN1KpVGQyGQMDSJCampqYMmVKPPPMM4JfyGGpVCr23XffrK9z/vz5C00LACA3CIABAN7Ho48++uYFF1yQ1TWWlJRE586dY926dQYGkAC1tbUxefLkePbZZ6Ourk5DIMd17do1WrVqlfV1/vnPf15kWgAAuUEADADwPiZNmlRVX1+/oaioqGM217nvvvsKgAGy3Pbt22P69OkxderU2LZtm4ZAM9GnT5+sr7G+vr7iySefrDItAIDcIAAGAPgAW7duXZTtAXCfPn3ipZdeMiyALNTQ0BDTpk2Lp556KqqrqzUEmpkkXP+8detWp38BAHKIABgA4ANUVFQs7NChw8hsrjEJLxYBmpvGxsaYMWNGPPnkk1FZWakh0EwlYZ9WUVHh+78AADlEAAwA8AGWLl266MADD8zqGnv16hUFBQXR2NhoYAB7WTqdjlmzZsWkSZNi06ZNGgLNWGFhYfTs2TMR+13TAgDIHQJgAIAPMHPmzEWnnnpqdm/qCgqiZ8+esWzZMgMD2EveDn4nT54cGzdu1BAg9tlnn8jPz0/CfnexaQEA5I48LQAAeH+//OUvV6bT6bpsr7NPnz6GBbAXZDKZePHFF+O73/1u3H///cJf4J+ScP1zOp2u++Uvf7nStAAAcocTwAAAH6C6ujpdXV29uE2bNodkc539+vWL6dOnGxjAHpLJZGL27NkxceLEWLNmjYYAO92fJWCvu7i6ujptWgAAuUMADADwIWzYsGFetgfA/fv3NyiAPeTVV1+NSZMmxapVqzQD2KlUKpWI/dmGDRvmmhYAQG4RAAMAfAiLFy9+o2/fvlldY1lZWXTu3DnWr19vYAC7yYIFC2L8+PGxZMkSzQDeV5cuXaK0tDQJ+9z5pgUAkFsEwAAAH8JTTz31+ujRo7O+zv33318ADLAbLFy4MMaPHx+LFy/WDOBD78uSYMqUKa+bFgBAbsnTAgCAD/aLX/xiTWNjY1W215mUF40ASbFs2bK4++674z/+4z+Ev8BHkoTv/zY0NFTee++9q00LACC3OAEMAPAhNDQ0ZDZv3jy/Q4cOI7O5TgEwwK6xYsWKePTRR2P+fDejArm7L9uyZYs/5AAAcpAAGADgQ1q3bl3WB8AdO3aMNm3axObNmw0M4GNYtWpVjB8/PubOnRuZTEZDgI+lbdu20aFDh0Tsb00LACD3CIABAD6kefPmzTvooIOyvs4DDzwwXnrpJQMD+AjWrVsX48ePj9mzZwt+gV2yH0uCuXPnzjMtAIDcIwAGAPiQ/vznP88/77zzsr7OAw44QAAM8CFVVFTEuHHjBL/ALt+PJcHDDz/sBDAAQA4SAAMAfEgTJ06srK2tXdGqVat9srnOgw8+2LAAPkBVVVVMnDgxnn/++WhqatIQYJdKwq0xNTU1yydNmlRlWgAAuUcADADwEWzYsOHvvXr1yuoAuG3bttG1a9dYu3atgQG8y+bNm+Pxxx+PF154IRobGzUE2OW6desWbdu2TcS+1rQAAHKTABgA4CNYuHDha7169Toj2+scMGCAABjgHbZs2RJTpkyJ5557LrZv364hwG6TlO//Lly48O+mBQCQmwTAAAAfwcSJE/9+wgknZH2dBx54YEyfPt3AgGavpqYmpkyZEs8880zU19drCLDbDRgwIBF1jh8//u+mBQCQmwTAAAAfwb333rv6Bz/4wfqioqLO2VznAQccEHl5eZFOpw0NaJZqa2tj8uTJ8eyzz0ZdXZ2GAHtEXl5e9O/fP+vrrK+vX3ffffeVmxgAQG4SAAMAfESVlZVzu3btmtXHgFu1ahX77LNPLFu2zMCAZqWuri6efvrpmDZtWmzbtk1DgD1qn332iVatWmV9nZs2bZpjWgAAuUsADADwES1dunR2tgfAERGDBg0SAAPNRkNDQ0ybNi2eeuqpqK6u1hBgr+2/kuCtt976m2kBAOQuATAAwEc0ffr0v48cOTLr6xw4cGBMmDDBwICc1tDQEM8991w8+eSTUVlZqSHAXt9/JcG0adP+bloAALlLAAwA8BH9x3/8x9JbbrmlOj8/v3U219mrV68oKyuLLVu2GBqQc9LpdMyaNSsmTZoUmzZt0hBgrysrK4tevXplfZ2NjY1b7rnnnmUmBgCQuwTAAAAfUW1tbXrDhg1/7dKly3HZXGcqlYqBAwfGrFmzDA3IGW8Hv5MnT46NGzdqCJA1Bg4cGKlUKuvr3Lhx4yu1tbVpEwMAyF0CYACAj+Gtt956JdsD4IgQAAM5I51Ox8svvxxTpkyJ8vJyDQGyct+VBIsWLXrFtAAAcpsAGADgYxg/fvwrRxxxRNbXedBBB0VBQUE0NjYaGpBImUwmZs+eHRMnTow1a9ZoCJCVCgoK4qCDDkpErY888ogAGAAgx+VpAQDAR/fjH/94ZX19/fpsr7OoqCj69etnYEAivfrqq3HHHXfEz3/+c+EvkNX69esXRUVFWV9nXV1d+b333rvaxAAAcpsTwAAAH9OGDRte6dGjx6ezvc5BgwbFggULDAxIjCVLlsSECRNi/vz5mgEkwuDBgxNR5/r1653+BQBoBgTAAAAf07x5815OQgA8bNiwePjhhyOTyRgakNXefPPNmDBhQixevFgzgMRIpVIxdOjQRNQ6d+7cl0wMACD3CYABAD6m++677+XRo0dnIiKVzXW2bds2evfuHcuWLTM0ICstW7YsHnvsMSd+gUTq06dPtG3bNgmlpu+9996/mhgAQO4TAAMAfEwTJ06s3Lp165LS0tK+2V7rkCFDBMBA1lmxYkU8+uijgl8g0YYMGZKIOqurqxc+/fTTm00MACD3CYABAD6B8vLyl/fff/+sD4AHDx4c48aNMzAgK6xcuTImTJgQc+fOdT09kHhJ+f7vmjVrfP8XAKCZEAADAHwCM2fOfG7//ff/fLbX2a1bt+jWrVuUl5cbGrDXrFu3LsaPHx+zZ88W/AI5oWfPntGlS5dE1DpjxoznTAwAoHkQAAMAfAK33Xbba5dcckl1fn5+62yvdciQIQJgYK9Yv359PPbYY4JfIOck5frnxsbGzbfddts8EwMAaB4EwAAAn0BlZWXThg0b/tqlS5fjsr3WQw89NCZNmmRowJ78MzKeeOKJeP7556OpqUlDgJxz6KGHJqLOioqKV6qrq9MmBgDQPAiAAQA+oXnz5s1MQgDcu3dv10ADe0RVVVVMnDgxXnjhhWhsbNQQICd17949evbsmZT9quufAQCakTwtAAD4ZP77v/97VkQk4kTFpz71KQMDdpstW7bEQw89FLfffns899xzwl8gpw0fPjwRdWYymfTdd9/9gokBADQfTgADAHxCkyZNqtqyZcuCsrKyg7K91uHDh8fjjz9uaMAuVVNTE1OmTIlnnnkm6uvrNQTIealUKg477LBE1Lply5bXp0+fvsXUAACaDwEwAMAusHz58lkDBw7M+gC4S5cu0atXr1i5cqWhAZ9YbW1tTJ48OZ599tmoq6vTEKDZ6N27d3Ts2DEx+1QTAwBoXgTAAAC7wLPPPvvCwIEDr0hCrcOGDRMAA59IXV1dPP300zFt2rTYtm2bhgDNzrBhwxJT61/+8pcXTQwAoHnxDWAAgF3g1ltvnV9fX782CbUefvjhkUqlDA34yBoaGmLq1Klx6623xuOPPy78BZqlJF3/XFdXt/rWW29dYGoAAM2LE8AAALtAQ0NDZs2aNc/16dPns9lea7t27aJPnz6xZMkSgwM+7J9xMW3atHjqqaeiurpaQ4Bmbb/99ou2bdsmotbVq1fPNDEAgOZHAAwAsIs8++yz05IQAEdEHHHEEQJg4AOl0+mYNWtWTJo0KTZt2qQhABFx5JFHJqbW6dOnTzMxAIDmxxXQAAC7yC233PJaQ0NDZRJqHT58eLRo0cLQgJ1Kp9Px3HPPxW233Rb333+/8Bdgh6KiovjUpz6ViFobGho23HLLLXNNDQCg+XECGABgF6murk6Xl5c/t88++5yR7bW2bNkyDj300Hj55ZcNDvindDodL7/8ckyZMiXKy8s1BOBdhgwZEkVFRYmodc2aNc/V1tamTQ0AoPkRAAMA7EIvvvjiM0kIgCMiRo4cKQAGIiIik8nE7NmzY+LEibFmzRoNAXif/VNSzJo161kTAwBongTAAAC70O233/7KOeecszU/P78022sdMGBAtG/f3tWu0My9+uqrMWnSpFi1apVmALyPjh07xgEHHJCIWhsbG6u/8Y1v/NXUAACaJwEwAMAutHLlyob169fP6tat2+hsrzWVSsXhhx8ekyZNMjhohubMmROTJ0+OJUuWaAbAh3D44YdHKpVKRK3r16+fVVFR0WhqAADNU54WAADsWq+++mpirts77LDDDAyamTfffDP+/d//PX7yk58IfwE+pFQqFSNGjEhMva+88sozpgYA0Hw5AQwAsIvddNNNz5166qnV+fn5rbO91m7dukX//v1j4cKFBgc5btmyZfHYY4/F/PnzNQPgIzrggAOic+fOiai1sbFxy4033jjL1AAAmi8BMADALrZy5cqG8vLyGT179vx0Euo9+uijBcCQw5YvXx7jxo0T/AJ8wv1SUpSXlz9TXl7eYGoAAM2XABgAYDeYMWPGUxdccEEiAuAhQ4ZE69ato7q62uAgh6xcuTImTJgQc+fOjUwmoyEAH1ObNm3i0EMPTUy9zz777FOmBgDQvPkGMADAbvDVr371lYaGhk1JqLWgoCCOOOIIQ4McsW7duvj5z38ed955Z8yZM0f4C/AJjRw5MvLz8xNRa0NDw8abbrrpVVMDAGjenAAGANgNKisrm1atWjW9T58+5ySh3qOPPjqefPJJQREk2Pr16+Oxxx6L2bNn+3cZYBdJpVIxatSoxNS7cuXKadXV1WmTAwBo3pwABgDYTaZNm5aY6/c6duwYAwYMMDRIoA0bNsSvf/3r+Nd//dd49dVXhb8Au9CAAQOiY8eOian36aefftLUAAAQAAMA7CZf+9rX5tTX11ckpd6jjjrK0CBBqqqq4v77749vf/vb8eKLL0ZTU5OmAOxiRx55ZGJqra+vX/eNb3zjdVMDAMAV0AAAu0ltbW16xYoVT++///6fT0K9hx56aLRt2zaqqqoMD7LYli1bYsqUKfHcc8/F9u3bNQRgN2nbtm0MGTIkMfUuX778qdraWtc/AwDgBDAAwO70xz/+cUJSas3Pz4/jjjvO0CBL1dTUxKOPPhq33XZb/OUvfxH+Auxmxx57bOTn5yel3Myvf/3rCaYGAECEABgAYLe66667llZXV89PSr1HH310tGjRwuAgi7wd/H7jG9+IqVOnRn19vaYA7GYtWrSIo48+OjH1btmy5Y177rlnhckBABDhCmgAgN3u9ddfn3T44YcPSEKtxcXFcdhhh8XMmTMNDvayurq6ePrpp2PatGmxbds2DQHYgw477LAoKSlJTL3z5s17wtQAAHibE8AAALvZ9773vanpdLohKfWecMIJkUqlDA72koaGhpg6dWrceuut8fjjjwt/AfawVCoVJ5xwQmLqTafT27/73e8+ZXIAALzNCWAAgN1s+vTpWyoqKmZ26dIlER/Y7d69e/Tv3z/efPNNw4M9qKGhIaZNmxZPPfVUVFdXawjAXnLAAQdE9+7dE1NvRUXFczNmzPAXBwAA/+QEMADAHjBr1qxEXcuXpFMvkHTpdDqee+65uP322+PRRx8V/gLsZccff3yi6p0xY8YkUwMA4J2cAAYA2AO++tWvvnT66adXFRYWtk1CvQMHDoyOHTvGhg0bDA92k3Q6HbNmzYrJkyfHxo0bNQQgC3Ts2DEGDhyYmHobGhoqb7755pdMDgCAd3ICGABgDygvL29YsWLF1MRsEvPy4sQTTzQ42A3S6XS8+OKL8Z3vfCfuv/9+4S9AFjnppJMiLy85r8tWrFgxpaKiotHkAAB4JwEwAMAe8qtf/erRiMgkpd6jjjoqysrKDA52kUwmE6+++mp873vfi1//+texdu1aTQHIImVlZXHUUUcl6q+W//7v//6zyQEA8G4CYACAPeQ///M/l1dWVv4tKfUWFhbGMcccY3CwC7wd/P785z+PNWvWaAhAFjruuOOioCA5X0urqqqa/dOf/nS1yQEA8G4CYACAPeill14al6R6jzvuuCgqKjI4+JjmzJkTd911V/z85z+P1au9owfIVkVFRYn7xbcXXnhhnMkBALAzBVoAALDnjB079pkFCxZUFhYWtktCvSUlJXHEEUfE9OnTDQ8+gjfffDPGjx8fb731lmYAJMCRRx4ZJSUliam3oaFh0zXXXPOsyQEAsDMCYACAPai8vLxh6dKlE/v3739xUmo+8cQT49lnn410Om2A8AEWLVoUjz32WCxevFgzABIiLy8vTjzxxETVvGTJkifKy8sbTA8AgJ3ucbUAAGDP+u1vfzsxIjJJqbdjx44xdOhQg4P3sXz58rj77rvjRz/6kfAXIGGGDRsWHTp0SFLJmd/85jePmxwAAO9FAAwAsIf953/+5/JNmza9kqSaTz/99EilUoYH77Jy5cr4yU9+Et///vdj/vz5GgKQMHl5eXHGGWckquZNmza9fM8996wwPQAA3osroAEA9oKXXnpp/KmnnnpYUurt2rVrDBkyJGbPnm14EBHr1q2L8ePHx+zZsyOTyWgIQEINHTo0OnfunKiaX3jhhQkmBwDA+xEAAwDsBZdffvkzS5YsWVdUVNQlKTWfccYZ8be//U3YRbO2fv36eOyxxwS/ADkglUrF6aefnqia6+rq1lx22WXTTQ8AgPcjAAYA2AsqKyub5s+f/8ihhx56dVJq7tatm1PANFsbNmyIxx9/PF555ZVoamrSEIAc8KlPfSq6du2aqJrfeOONcdXV1WnTAwDg/fgGMADAXvL1r399XDqdrktSzb4FTHNTVVUV999/f3z729+OF198UfgLkCNSqVR8+tOfTlTN6XS69pvf/OZjpgcAwAdxAhgAYC+ZMWNG9Zo1a/7Ss2fPxLx97N69ewwcODDmzJljgOS0LVu2xIQJE+KFF16IxsZGDQHIMYceemh069YtUTWvXr36qRkzZlSbHgAAH8QJYACAvejXv/71HyMiUR8SPeuss5wCJmdt27YtHn300bjtttviueeeE/4C5KC8vLwYM2ZM0srO/OpXv/qT6QEA8KH2vFoAALD3fP/733+rqqoqUR/V7dGjR3zqU58yPHJKfX19TJ06Nb71rW/F1KlTo76+XlMActSIESOiS5cuiap506ZNf73rrruWmh4AAB+GABgAYC975plnHkpazWeccUbk5dlKkjvmzZsXjz76aGzdulUzAHJYQUFBnH766Ymre9q0aQ+aHgAAH5a3dgAAe9nYsWNn1tfXr01SzZ07d47DDjvM8ACARBk5cmR06NAhUTXX1dWtHjt27POmBwDAhyUABgDYyyorK5tee+21Pyat7jPPPDMKCgoMEABIhBYtWiTy9O/s2bP/UF1dnTZBAAA+LAEwAEAWuOqqqyY0NjZWJanm9u3bx9FHH214AEAiHHfccdGmTZtE1dzQ0LDxiiuumGh6AAB8FAJgAIAssGDBgrqFCxc+lrS6R48eHYWFhQYIAGS1li1bxsknn5y4uhcuXDhu6dKl200QAICPQgAMAJAlvv71r/8pnU7XJqnmtm3bximnnGJ4AEBWO+2006K0tDRRNTc1NdV+7Wtfe8j0AAD4qATAAABZ4umnn968fPnyxF3xN3r06GjXrp0BAgBZqUOHDnH88ccnru5ly5ZNmD59+hYTBADgoxIAAwBkkbvvvvtPmUymKUk1FxYWxumnn254AEBWOvPMMxP3yYpMJtN41113/dH0AAD4OATAAABZ5Be/+MWatWvXTkta3UcccUT06tXLAAGArNK7d+847LDDEld3eXn5X+6///51JggAwMchAAYAyDIPP/zwn5JWcyqVijPPPNPwAICsMmbMmEilUomr+8EHH/yT6QEA8HEJgAEAsszXv/71NzZs2DAraXUPHDgwDj74YAMEALLCoEGDYsCAAYmru6KiYuatt966wAQBAPi4BMAAAFlo3Lhxv01i3WPGjIm8PFtMAGDvysvLizFjxiSy9j//+c+/NUEAAD7RflgLAACyz/XXXz+nqqrqr0mru1evXnHUUUcZIACwVx1zzDHRvXv3xNW9adOmV2666aa5JggAwCchAAYAyFJ/+tOf7k1i3WPGjInS0lIDBAD2ijZt2sRZZ52VyNofeOCBe00QAIBPSgAMAJClbrrpprlJPAVcXFwcZ555pgECAHvFWWedFS1btkxc3Zs2bXrl5ptvnmeCAAB8UgJgAIAsNm7cuF8lse5Ro0ZF7969DRAA2KP69OkTI0eOTGTtjz322K9MEACAXUEADACQxcaOHTu7qqrqb0mrO5VKxfnnnx+pVMoQAYA9tv/4/Oc/n8j9R2Vl5d+uueaav5kiAAC7ggAYACDLTZ069bdJrLtv374xZMgQAwQA9ojDDjsssTeQTJ48+TcmCADAriIABgDIcpdeeumLVVVVryax9s9//vNRXFxsiADAblVaWhrnn39+Imuvqqr66+WXX/6SKQIAsKsIgAEAEuChhx76WRLrLisri9NPP90AAYDd6qyzzoqSkpIklp753e9+91MTBABgVxIAAwAkwA033DB3w4YNs5JY+3HHHRd9+vQxRABgt+jbt28cddRRiay9oqJi1te//vU3TBEAgF1JAAwAkBA///nPfxoR6aTVnUql4vOf/3zk5dl6AgC7Vn5+flx00UWRSqWSWH76F7/4xX+bIgAAu5q3cAAACXHHHXe8tW7duulJrL13795xzDHHGCIAsEudcMIJ0b1790TWXl5e/pc77rjjLVMEAGBXEwADACTI3XfffW8mk2lKYu1nnXVWtG3b1hABgF2iQ4cOcfrppyey9kwm03T33Xf/3BQBANgdBMAAAAlyzz33rCgvL386ibW3bNkyzj33XEMEAHaJc889N1q0aJHI2tesWTP1xz/+8UpTBABgdxAAAwAkzA9/+MOfZzKZhiTWPnz48Bg0aJAhAgCfyKGHHhpDhw5NZO3pdLrhBz/4wS9MEQCA3UUADACQMPfee+/qRYsWPZDU+i+++OIoKSkxSADgY2ndunVcfPHFia1/4cKFf7jvvvvKTRIAgN1FAAwAkECXXXbZrxsaGjYlsfaysjJXQQMAH9u5554bpaWliay9oaFh4+WXX/47UwQAYHcSAAMAJNDs2bNrXn311V8ntf4jjjgiDj74YIMEAD6SwYMHx+GHH57Y+l955ZX7Zs+eXWOSAADsTgJgAICEOueccx6tqalZmtT6L7roomjZsqVBAgAfSsuWLeNzn/tcYuuvqalZMmbMmMdMEgCA3U0ADACQUJWVlU3Tpk37RVLrb9++fZx++ukGCQB8KGeccUa0b98+sfU/+eST91ZXV6dNEgCA3U0ADACQYOedd960qqqqV5Ja/wknnOAqaADgAx188MFx/PHHJ7b+TZs2vXzBBRc8a5IAAOwJAmAAgIT74x//eG9EZJJYeyqVigsuuMBV0ADAe2rZsmVccMEFkUqlkrqEzP333/8zkwQAYE8RAAMAJNzNN988b9WqVU8ktf6OHTsm+nt+AMDudcEFF0THjh0TW/+KFSse//rXv/6GSQIAsKcIgAEAcsCNN974k6ampq1JrX/kyJExdOhQgwQA/pdPfepTMWLEiMTW39TUVH3zzTf/t0kCALAnCYABAHLAxIkTK//+97//KslruPDCC6OsrMwwAYCIiGjTpk18/vOfT/QaZs+efd/EiRMrTRMAgD1JAAwAkCPOPvvsh2pqapYntf7S0tK46KKLDBIAiFQqFV/84hejtLQ0sWuoqal566yzznrYNAEA2NMEwAAAOaKioqJx0qRJP07yGgYPHhwjR440TABo5o444og46KCDEr2GJ5544qeVlZVNpgkAwJ4mAAYAyCGXXHLJzIqKihlJXsMFF1wQ3bp1M0wAaKZ69uyZ+KufKyoqZnzhC1+YZZoAAOwNAmAAgBzzb//2b/ek0+ntSa2/RYsWceWVV0ZhYaFhAkAzU1hYGF/60pcSvQ9Ip9Pb/+3f/u0e0wQAYG8RAAMA5Jh777139aJFix5M8hq6d+8eZ555pmECQDNzxhlnRPfu3RO9hsWLFz947733rjZNAAD2FgEwAEAO+uxnP/vL2traRL94PPHEE2Pw4MGGCQDNxKBBg+Kkk05K9Bpqa2tXn3vuub80TQAA9iYBMABADlq8eHH9uHHj/j3Ja0ilUnHJJZdE27ZtDRQAclybNm3ikksuiVQqleh1jBs37t8XL15cb6IAAOxNAmAAgBx1+eWXv1RRUTEjyWsoLS2NL3zhC4l/GQwAvLe3f+mrdevWiV5HRUXFM5dffvlLJgoAwN4mAAYAyGE33HDDXU1NTVuTvIaDDjrI94ABIId95jOfiUMOOSTRa2hqaqq+4YYbfmiaAABkAwEwAEAOGzdu3MbZs2cn/jt0p5xyiu8BA0AOOuSQQ+LTn/504tfx17/+9efjxo3baKIAAGQDATAAQI77zGc+81B1dfXCJK8hlUrFF7/4xejQoYOBAkCO6NixY3zpS19K/KceNm/ePO+00057xEQBAMgWAmAAgBxXXV2dfuCBB34UEekkr6O4uDguvfTSyMuzhQWApMvPz4/LLrssiouLk76U9P333/+ftbW1aVMFACBbeHsGANAMXH/99XMWLVr0YNLXsf/++8e5555roACQcOedd1707ds38etYuHDhH7/61a++bqIAAGQTATAAQDNxySWX/Lyurq486es4/vjjfQ8YABJs2LBhccwxxyR+HXV1dWsuvPDC+0wUAIBsIwAGAGgmXnvttdoHHnjguxGRSfI6UqlUfOlLX4oePXoYKgAkTO/evePSSy9N/Hd/IyLzwAMPfO/111+vNVUAALKNABgAoBm5+uqr/7Z06dJHk76OoqKiGDt2bJSWlhoqACRE69at46qrrorCwsLEr2X58uXjrr766r+ZKgAA2UgADADQzJx33nn/r66ubnXS19GhQ4e4/PLLIy/PlhYAsl1eXl5cfvnl0b59+8Svpb6+ft0ll1zyE1MFACBr999aAADQvLz++uu1Dz744Pcj4VdBR0QMGDAgzjrrLEMFgCw3ZsyYOPDAA3NiLY899tgPXnnllW2mCgBAthIAAwA0Q1/5ylf+umbNmqm5sJaTTz45Dj30UEMFgCw1ZMiQOOmkk3JiLWvXrv3LpZde+oKpAgCQzQTAAADN1GWXXfYf9fX1FUlfRyqViksvvTS6d+9uqACQZXr06BFf/OIXI5VKJX4tDQ0Nm6655pofmioAANlOAAwA0EzNmDGj+oEHHvhO5MBV0C1btozrr78+2rZta7AAkCXatWsX1113XbRs2TIXlpN56KGH/nXSpElVJgsAQLYTAAMANGNf+cpX/rpkyZI/58Ja2rZtG1dffXW0aNHCYAFgL2vRokVcffXVOfPLWUuXLn30iiuueNlkAQBIAgEwAEAzd+655/6ktrZ2eS6spXfv3jlzzSQAJNXbn2fYZ599cmI9tbW1y88555wfmywAAEkhAAYAaOYWLFhQ97Of/ezbmUymMRfWM2zYsDjllFMMFgD2kk9/+tMxdOjQnFhLJpNp/NnPfvbtBQsW1JksAABJIQAGACBuvfXWBfPnz78/V9Zz5plnxuDBgw0WAPaw4cOHx2c+85mcWc/8+fN/d+utty4wWQAAkkQADABARESMGTPmvpqamrdyYS2pVCouu+yy6Nmzp8ECwB7Su3fvuPjii3PmUwxbt25ddPrpp//aZAEASBoBMAAAERGxcuXKhh/+8Ie3pdPpnLjisGXLlvEv//Iv0aVLF8MFgN2sS5cucf3110dRUVFOrKepqanmu9/97jfKy8sbTBcAgKQRAAMA8E933XXX0ueff/6eXFlPaWlpXHvttVFWVma4ALCblJWVxXXXXRclJSU5s6aZM2fe/f/+3/9bZboAACSRABgAgP/l5JNPHldeXv50rqynU6dOMXbs2Jw5kQQA2aSoqCiuueaa6NixY86sqby8/MlTTz11gukCAJBUAmAAAP6PSy655K66urq1ubKefffdN6644orIy7P9BYBdJS8vL6688sro3bt3zqyprq6u/JJLLvmh6QIAkOi9uhYAAPBus2bNqn7ooYfujIh0rqxp4MCBcd555xkuAOwi559/fhxyyCG5tKT0gw8+eOesWbOqTRcAgCTLb3tQ9NzpjndbRG15oQ4BADRTEydOXDNmzJi8Tp06Dc2VNfXp0yfy8/PjzTffNGAA+ATOOuusOOmkk3JqTa+//vp9Z5555kTTBQAgCYq7N0Ze6c5/5gQwAADv6dRTT/31li1bXs+lNZ122mlx9NFHGy4AfEzHHntsnHrqqTm1pi1btrxx2mmn/cZ0AQDIBQJgAADeU0VFReONN974jcbGxqpcWtcFF1wQRx55pAEDwEd05JFHxuc+97mcWlNjY2PVzTff/I2KiopGEwYAIBcIgAEAeF9//OMf1z/yyCPfiRz6HnAqlYqLLroohgwZYsAA8CENHTo0LrrookilUrm0rPQjjzzynfvvv3+dCQMAkCsEwAAAfKBLL730hQULFvwupzbCeXnxpS99Kfbff38DBoAPcNBBB8WXvvSlyMvLrVdJCxYs+N2ll176ggkDAJBLBMAAAHwoo0eP/mVVVdXcXFpTYWFhfOUrX4kePXoYMAC8h169esUVV1wRBQUFObWuqqqqOaNHj/6lCQMAkGsEwAAAfCgVFRWNV1111S0NDQ0bcmldJSUlcfPNN8c+++xjyADwLr17946bbropiouLc2pdDQ0NG6666qqv++4vAAC5SAAMAMCHNmHChE3333//tzKZTDqX1lVcXBzXXXdddO/e3ZABYIfu3bvHtddeG61atcqpdWUymfT999//rQkTJmwyZQAAcpEAGACAj2Ts2LGz58+f/9tcW1fr1q3juuuuiw4dOhgyAM1ehw4d4rrrrovWrVvn3Nrmz5//m7Fjx842ZQAAcpUAGACAj+y44477xaZNm17MtXW1a9cubrzxxmjXrp0hA9BstW3bNmf/Pty4ceOLxx13nO/+AgCQ0wTAAAB8ZNXV1emLL774W3V1datzbW0dO3aMG2+8Mdq0aWPQADQ7ZWVlceONN0bHjh1zbm21tbWrL7zwwturq6vTJg0AQC7Lb3tQ9NzZD9LbImrLC3UIAICdWrZsWf327dtfOvbYY0/Ny8trkUtrKykpiaFDh8Zrr70WNTU1hg1As9ChQ4f42te+Fp06dcq5tTU1NW39zne+M/bBBx9cb9IAAOSC4u6NkVe6858JgAEA+NhefPHFzYcccsiyAQMGnBgRqZzaRBcXx5AhQ4TAADQLHTt2jJtuuik6dOiQi8tLjx8//ravfvWrc0waAIBc8X4BsCugAQD4RC688MIZb7zxxm9ycW3t27ePm266KSdPQgHA2zp16pTL4W+88cYbv77wwgufM2kAAJoLATAAAJ/YqFGjfrFhw4aZubi2t0Pgzp07GzQAOadz585x0003Rfv27XNyfRs2bJg5atSo+0waAIDmRAAMAMAnVltbm77sssu+V1dXtzoX19euXbu44YYbomPHjoYNQM7o0KFDXH/99dGuXbtc3Z+s/sIXvvDd2tratGkDANCc+AYwAAC7xJIlS+oj4pVRo0admpeX1yLX1ldcXBxDhw6NuXPnxrZt2wwcgETr0qVL3HjjjTl77XNTU1P1nXfeec0f/vCHdaYNAEAuer9vAAuAAQDYZWbNmlXVo0ePuYceeujoVCqVn2vra9WqVYwYMSIWLVoUlZWVBg5AIu23335x0003RVlZWU6uL51ON/z617++4fbbb3/TtAEAyFUCYAAA9phJkyatPeqoozbsu+++R+fi+goLC2P48OGxbNmy2LBhg4EDkCgDBgyIa6+9Nlq1apWza5w2bdq/XXLJJc+ZNgAAuez9AmDfAAYAYJc77bTTHn/rrbcezNX1FRUVxTXXXBNDhgwxbAASY8iQIXHNNddEUVFRzq5xwYIFvzv99NOfMG0AAJozATAAALvFEUcccc+GDRtm5ur6CgoK4sorr4wjjjjCsAFIwt/LceWVV0ZBQUHOrrG8vPypESNG/LdpAwDQ3AmAAQDYLaqrq9MXXXTRd2pra1fk7GY6Ly8uvvjiOPLIIw0cgKw1atSouPjiiyMvL3dfA23dunXxZz/72e83NDRkTBwAgObON4ABANhtli9fvr2mpuaFY4899uT8/PyWubjGVCoVgwYNikwmE4sWLTJ0ALLK6aefHueee26kUqmcXWN9fX3FDTfccM3UqVOrTBwAgObi/b4BLAAGAGC3evnll7cUFBS8cMQRR4zOy8trkYtrTKVSccABB0SnTp1i7ty5kck4fATA3lVYWBhXXHFFHHPMMTm9zsbGxuo777zzKz/72c9WmzoAAM2JABgAgL1qxowZlb169Xp98ODBJ6dSqfxcXWfPnj2jb9++8fe//z0aGxsNHoC9olWrVnH11VfHwIEDc3qd6XS64be//e2Nt9122wJTBwCguREAAwCw1z3xxBPlw4cPX9OvX79jIyJn76Hs2LFjDBw4MObMmRN1dXUGD8Ae1a5du7jxxhujT58+ub7U9JQpU779xS9+8XlTBwCgOXq/ADhPewAA2FPGjBkz9Y033vh1rq+zZ8+eceONN0bHjh0NHYA9pkuXLnHTTTdF9+7dc36tc+fO/eU555zzF1MHAID/SwAMAMAe9alPfernS5cufTjX19mlS5e49dZb48ADDzR0AHa7gQMHxje/+c3o1KlTzq/1rbfeemjEiBG/MnUAANg5ATAAAHvcsccee8/GjRtfyPV1FhcXx7XXXhsjRowwdAB2m8MPPzyuuuqqaNmyZc6vdePGjc8fffTR95g6AAC8NwEwAAB7XEVFReNxxx339crKyr/l+loLCgrisssui/PPPz9SqZThA7DLpFKpOP/88+PSSy+NgoKCnF/vpk2bXj7ssMNuqaysbDJ9AAB4bwJgAAD2isWLF9efddZZN1dXV7/ZHNZ7/PHHx5e//OUoKioyfAA+sRYtWsSXv/zlOP7445vFequrq98cM2bMN8rLyxtMHwAA3l9+24Oi585+kN4WUVteqEMAAOw2a9asaVi1atWs0aNHH1dQUNA619fbrVu3OOCAA2LevHlRX1/vAQDgYykrK4trrrkmDjrooGax3rq6uvKxY8de89RTT202fQAA+Ifi7o2RV7rznwmAAQDYq+bNm1ezevXqZ04++eTjCwoKSnN9ve3atYuRI0fG8uXLY+PGjR4AAD6S/v37x0033RRdu3ZtFuutr69fd9111335T3/6U4XpAwDA/xAAAwCQ1ebMmbMtlUq9fOSRR56Ul5eX83ckt2jRIkaMGBG1tbWxdOlSDwAAH8rxxx8fX/rSl5rN5wQaGxu33HXXXdf99Kc/XWn6AADwvwmAAQDIejNnzqzs2bPn64MHDz4plUrl5/p6U6lUHHLIIdGqVatYsGBBZDIZDwEAO5WXlxef/exn4/TTT49UKtUs1pxOp7f//ve//+o3vvGN1z0BAADwfwmAAQBIhEmTJpXvs88+8wYOHHhCKpUqaA5r3m+//WLAgAExd+5c3wUG4P8oKyuL6667LoYNG9Zs1pxOp7f/8Y9/vOmqq676qycAAAB2TgAMAEBiTJw4cc3BBx+85MADDzwulUrlNYc1t2/fPoYOHRqLFi2KLVu2eAgAiIiIffbZJ66//vro2bNns1lzJpNpnDBhwm1f/OIXn/cEAADAexMAAwCQKI8++ujy/fff/42DDjrohOZwHXRERHFxcRx11FHR2NgYb731locAoJkbPXp0XHHFFVFSUtJs1pxOpxsefvjhr15yySWzPAEAAPD+BMAAACTO+PHjVw0cOHDpAQcccGxzOQmcSqViwIAB0aVLl3jjjTeiqanJgwDQzBQVFcWll14aJ554YrP53m/EP07+Pv7447dffPHFMz0FAADwwQTAAAAk0iOPPLLs0EMPXbb//vs3mxA4IqJHjx4xZMiQePPNN2Pr1q0eBIBmonv37vEv//IvccABBzSrdWcymaYnnnji9s997nPPeAoAAODDEQADAJBYDz/88NJjjjlmY+/evY+KiGZzFKq0tDSGDx8eq1evjvXr13sQAHLcwIED45prrol27do1t6VnZsyY8YOzzjprqqcAAAA+PAEwAACJdv/99795zDHHVO6zzz5HRDMKgVu0aBGHHXZYtGzZMhYuXBjpdNrDAJBjCgoK4pxzzonzzz8/WrRo0dyWn37uuefuOuWUUyZ4EgAA4KMRAAMAkHi///3v5w8bNmxF3759j2lO10GnUqno27dvDB06NBYvXhxbtmzxMADkiJ49e8YNN9wQgwcPblbf+434x7XPU6ZM+fbpp58+2ZMAAAAfnQAYAICc8OCDDy4ZNmzYin79+jWrEDgionXr1nHEEUdEfX19LF261MMAkGCpVCpOOOGEuOKKK6JNmzbNbv07wt9vnXPOOX/xNAAAwMcjAAYAIGc89NBDS4YNG7a8X79+xza3EDg/Pz8OPvjg6NWrV8yfPz8aGho8EAAJU1JSEpdffnmccMIJkZ+f3+zWn8lkGp944olvffazn53maQAAgI9PAAwAQE556KGHlo4cOXJdnz59RqWa252ZEdG1a9cYNmxYLFu2LCorKz0QAAnRt2/fuO6662K//fZrluvPZDLpp59++rvnnHPO054GAAD4ZATAAADknD/96U+LDj300KX7779/s7sOOiKiuLg4jjzyyCgpKYk333wz0um0hwIgSxUUFMRnP/vZuPDCC6OkpKRZ9iCdTjc88sgjt5x//vnTPREAAPDJCYABAMhJDz/88NId3wQelUqlmt09mqlUKvr06RMHH3xwLFy4MLZt2+ahAMgynTt3jrFjx8bQoUOjGV5aERH/CH+feOKJ2y+88MLnPBEAALBrCIABAMhZDz300JIePXq8NmjQoGPz8vJaNMcetG3bNkaNGhVNTU2xZMkSDwVAFkilUjF69Oi48soro0OHDs22D01NTdt++9vf/stll132oqcCAAB2HQEwAAA5bdKkSeXdu3efM3jw4GYbAufn58eAAQOiV69esWDBgti+fbsHA2Avad26dVx66aVx/PHHR35+frPtQ2NjY/WvfvWrf7nuuute81QAAMCuJQAGACDnTZ48eW1jY+OMI4444uiCgoKS5tqHrl27xqhRo2Lbtm2xcuVKDwbAHpRKpWLUqFExduzY6NWrV7PuRX19/fo77rjjK9/61rcWejIAAGDXEwADANAsPP/881UbNmx45rjjjjuqsLCwrLn2obCwMAYNGhT77bdfLF68OGpraz0cALtZ+/bt44orrogTTzwxCgub9/uU2tralTfffPPVP/nJT1Z7MgAAYPcQAAMA0Gz87W9/27p27doZJ5xwwsjCwsK2zbkXnTp1ipEjR0Z1dbXTwAC70ciRI+Pqq6+OHj16NPte1NTULL/hhhuu/e1vf7vOkwEAALuPABgAgGbltdde2zpv3rynTznllKFFRUWdmnMvCgsL49BDD4399tsvFi1a5DQwwC709qnfk08+udmf+o2I2Lx587yLL774unHjxm30dAAAwO71fgFwat9zYsTOftC4LmLjq610DwCAxOrVq1fhs88++69du3Y9QTciGhoaYurUqTF58uRobGzUEICPqaCgIE499dQYPXq04HeH8vLyp4499tjvrly5skE3AABg9+swrDYKuuz8ZwJgAAByWuvWrfNeeumlm/fdd9+zdeMfVq9eHffff38sWbJEMwA+ov322y8uuugi1z2/w8KFC38/fPjwnzY0NGR0AwAA9gwBMAAAzd7zzz9/8aGHHnp1RKR0IyKTycTMmTPjz3/+c9TV1WkIwAcoKSmJ8847L0aMGBGplL9Kdki//PLL9xx77LEPagUAAOxZ7xcA+wYwAADNwn333Tfn+OOP39yrV6/DQwgcqVQqevfuHcOHD49169ZFRUWFhwTgPRxyyCExduzY6N+/v/B3h0wm0/jMM8/828knnzxONwAAYM97v28AC4ABAGg2fve7370xePDgJf369Ts6lUrl60hEcXFxjBgxInr06BFLly6N2tpaTQHYoUOHDvGFL3whzjzzzCguLtaQHZqammoeeOCBWz73uc9N1w0AANg7BMAAALDDww8/vKygoOC54cOHH1FQUFCqI//QrVu3OO6446K0tDQWL14cTU1NmgI0Wy1btoxzzjknLr300ujevbuGvENtbe2K22677arbbrvtDd0AAIC9RwAMAADv8Oyzz25avHjx0yeddNKQoqKiTjryD3l5edGnT58YOXJkbN26NVatWqUpQLNz+OGHx1e+8pUYMGBA5OXlacg7VFVV/e3CCy+8/oEHHvDdAAAA2MsEwAAA8C7z58+vefbZZ58+44wz+hcXF/fSkf/RsmXLGDJkSOyzzz6xdOnSqKmp0RQg53Xs2DG++MUvximnnBItW7bUkHdZt27dMyeffPI3Xn755W26AQAAe9/7BcCpfc+JETv7QeO6iI2vttI9AAByWmFhYer555//0sEHH3y5bvxfTU1N8fzzz8f48eOjurpaQ4Cc07p16zjzzDPjyCOPdOJ35zJ///vff3rMMcfc39DQkNEOAADIDh2G1UZBl53/TAAMAAARMWnSpM8cc8wxt6RSKdfg7ERNTU1MmTIlpk2bFg0NDRoCJF5hYWGccsopcdJJJ0VRUZGG7EQ6na6fOnXqd88555y/6AYAAGSX9wuAXQENAAAR8Yc//GHhfvvt98aAAQOOysvLkwS8S2FhYQwYMCCGDh0amzZtinXr1mkKkFiDBw+Oq666KoYOHRoFBQUashONjY1Vv//972/5whe+MEs3AAAg+/gGMAAAfAgTJkxYXV1dPf3II4/8VGFhYTsd+b9KS0vjsMMOi/79+8eaNWti8+bNmgIkRu/evePyyy+PU045JUpLSzXkPWzdunXxLbfccs33vve9hboBAADZyTeAAQDgI+jTp0+LJ5988us9evQ4TTfe3/z58+ORRx6JlStXagaQtXr16hXnnHNODBgwQDM+wKpVq5444YQTfrBy5Ur3/QMAQBbzDWAAAPgYnnnmmfOHDx9+fSqVytON95bJZGL27Nkxbty4qKio0BAga3Tu3DnOOuusGDp0aKRSKQ15/z/Lm2bNmvXDk08++THdAACA7OcbwAAA8DH85je/eX3//fd//cADDzzSd4HfWyqViu7du8cxxxwT7dq1i2XLlkV9fb3GAHtN27Zt49xzz42LL744evToIfz9AI2NjdUPPvjgLZ/97Gf/ohsAAJAMvgEMAAAf0/jx41dFxPOHHXbYiMLCwjIdeW95eXnRu3fvOOqoo6KgoCBWrlwZjY2NGgPsMcXFxXHKKafEl770pejbt2/k5bnA4YPU1tau+MEPfnD9LbfcMk83AAAgQf/94xvAAADwyQwePLjVo48++s1u3bqdpBsfTn19fTzzzDMxderU2LZtm4YAu01ZWVmceuqpceSRR0ZRkQsbPqyVK1c+/ulPf/pHixcvdm0DAAAkjG8AAwDALvLkk0+edeSRR96USqVcl/MhCYKB3eXtE7/HHnus4PcjyGQyDbNmzfoP3/sFAIDk8g1gAADYRX7/+98v6NGjx2uHHHLIyPz8fL8x+SEUFBREv3794qijjoq8vLxYtWqVq6GBT6Rly5ZxwgknxBVXXBEHHXRQFBQUaMqH1NDQsOG3v/3t1z7/+c8/oxsAAJBcroAGAIBd7Lzzzut4991339m2bdvBuvHR1NTUxLPPPhvTpk2LLVu2aAjwoZWVlcXxxx8fxxxzTBQXF2vIR1RVVfW3a6+99vZHHnlkg24AAECyuQIaAAB2g06dOhVMmzZtbN++fT8XESkd+WgaGhri+eefjyeffDI2bJBFAO/7522cdNJJccQRR0RhodvKPobMokWL/nTsscf+pLKyskk7AAAg+QTAAACwG/3hD38Ydfrpp99WUFDQRjc+unQ6Ha+++mpMnTo1Vq5cqSHAP/Xq1StOOeWUGDp0aOTl5WnIx9DY2Fg1YcKEOy666KKZugEAALlDAAwAALvZaaed1vbee+/9docOHUbqxse3fPnymDZtWrz88suRTqc1BJqhvLy8OOyww+L444+P3r17a8gnsHHjxue//OUvf3fSpElVugEAALlFAAwAAHtAYWFh6qmnnjpv+PDh16RSKXeUfgIbNmyIGTNmxHPPPRc1NTUaAs1AcXFxjBo1Ko4++ujo2LGjhnwCmUym4ZVXXvl/J5100kMNDQ0ZHQEAgNzzfgFwftuDoufOfpDeFlFb7p0VAAB8WOl0On7zm9+8Xlpa+uLgwYM/VVhYWKYrH09xcXEMGDAgjj322GjTpk2sXbs2amtrNQZyUIcOHeKMM86ISy+9NAYOHBjFxcWa8gnU1tau+slPfnLjxRdf/IybFAAAIHcVd2+MvNKd/8wJYAAA2A1OPPHENvfdd9+tnTp1Olo3PrnGxsb429/+Fs8++2wsWrRIQyAH9OvXL44++ugYNmxYFBQUaMguUFFR8cwXv/jFf5s+ffoW3QAAgNzmCmgAANhLHn744RNGjx799YKCgta6sWusX78+Zs6cGc8//3xUV1drCCRIaWlpHHnkkXHUUUdF586dNWQXaWxs3DJ16tS7PvvZz/5FNwAAoHkQAAMAwF50ySWXdP3+97//rXbt2g3VjV2nsbExXnvttXjuuedi/vz5GgJZbMCAATFq1KgYPHiw0767WFVV1atf//rXv/e73/1urW4AAEDzIQAGAIC9rF27dvlTp0699OCDD740lUrl68iutXz58nj++efj5ZdfjpqaGg2BLFBSUhLDhw+PI444Inr37q0hu1gmk2mcN2/efSeeeOJvq6urfewXAACaGQEwAABkia9//ev73Xjjjf9aWlraXzd2vXQ6HW+++WY899xz8dprr0VjY6OmwB5UUFAQgwcPjlGjRsUBBxwQeXl5mrIbVFdXL/zP//zPf/3BD36wRDcAAKB5EgADAEAWOfjgg1v9+c9/vrZ3795jIiKlI7tHZWVlvPjii/HCCy/EunXrNAR2o65du8bIkSPj8MMPj7Zt22rI7pNZunTpn88888z/t3jx4nrtAACA5ksADAAAWejuu+8eePHFF9/WqlUrd6PuZuXl5fHqq6/GSy+9FOvXr9cQ2AU6d+4cI0aMiGHDhkW3bt00ZDerqalZ9tvf/vbOm266aa5uAAAAAmAAAMhS/fr1K3r44Ycv79+//4WpVMpdqXvA8uXL46WXXoqXX345qqurNQQ+grKyshg+fHiMGDHCd333kEwmk164cOEfzj777F8sXbp0u44AAAARAmAAAMh6P/3pT4d97nOf+2bLli176Mae0dDQEHPnzo2//vWvMXfu3Ni+Xa4CO9OyZcsYNGhQDBs2LA455JAoKCjQlD2ktrZ21R//+Mc7rr322r/rBgAA8E4CYAAASIA+ffq0ePTRR69wGnjPS6fTsXTp0nj11VedDIaIaNu2bQwbNiyGDRsWffr0ibw8fyTtSZlMpuG11177+ZlnnvmnioqKRh0BAADeTQAMAAAJ8uMf//jQCy644JutWrXaRzf2vLdPBs+ePTvmzp0bdXV1mkKzUFZWFoMHD45hw4ZF//79Iz8/X1P2gpqammX333//nTfccINv/QIAAO9JAAwAAAnTrl27/HHjxp37qU996qq8vDwb870kk8nEihUrYu7cuTFnzpxYsWJFZDIZjSEnpFKp6Nu3bwwbNiwGDRoUHTt21JS9qKmpqfbVV1/92ZgxY/5cWVnZpCMAAMD7EQADAEBCffnLX+5x++23f7V9+/aH68bet2XLlnjjjTdizpw5MW/evKivr9cUEqVly5Zx8MEHx6BBg+KQQw6J0tJSTckCGzdufPG73/3uv//iF79YoxsAAMCHIQAGAIAEKywsTE2cOPGMkSNHXlNQUNBaR7JDXV1dvPnmm/HGG2/EG2+8EevXr9cUslKXLl3ioIMOioMOOigOOOCAKCoq0pQs0djYuGXmzJk/PvPMMyc2NDS4XgAAAPjQBMAAAJADjjzyyNY/+9nPrujbt++5EZGnI9mluro6Fi5cGPPnz4958+ZFZWWlprBXtGvXLg455JAYMGBA9O/fP1q39nsjWSj91ltv/fmqq676xaxZs6q1AwAA+KgEwAAAkEN++ctfjhgzZsyNrVq16q0b2SmdTsfKlStj0aJFsXDhwli8eHFs27ZNY9gtSkpKol+/ftG/f//Yf//9o1evXpGX53dEslVNTc3yRx999EdXXnnlK7oBAAB8XAJgAADIMd26dSt8+OGHPzd48ODL8vPzbdyzXCaTiTVr1sTChQtj0aJFsWjRotiyZYvG8LGUlZVF//79/xn6du/ePVKplMZkuaampprXXnvtV2PGjHmgoqKiUUcAAIBPQgAMAAA56rjjjiv7r//6r8tdC508mzdvjuXLl8eKFSti+fLlsXjx4qipqdEY/pfi4uLo169f9O7dO/bZZ5/Yd999o6ysTGMSJJPJpJcsWfLn66677pfTp0/3mx8AAMAuIQAGAIAc99Of/nTIueeee3NpaWlf3UimxsbGWLlyZSxdujSWLVsWy5cvj3Xr1kUmk9GcZiKVSkWXLl1in332iT59+kSfPn2iV69eUVBQoDkJtXXr1sUPPvjgj6699tq/6wYAALArCYABAKAZaNeuXf64cePOGTp06BUFBQWtdST56uvrY+XKlf88KbxixYpYu3ZtpNNpzUm4vLy86Nq1a+yzzz7//KdXr17RsmVLzckBjY2NW/7617/+4pxzznm0srKySUcAAIBdTQAMAADNyIknntjmnnvuuXzfffcdk0qlHB3MMdu3b481a9bEmjVrYu3atbF27dooLy+PDRs2CIazUF5eXnTs2DG6desWXbt2jW7dukW3bt2iR48eUVhYqEE5JpPJNC5ZsuRR1z0DAAC7mwAYAACaoa9+9av7Xnfdddd16NDhCN3IfY2Njf8MhNetWxfr1q2LioqKWLduXWzbtk2DdrPS0tLo3LnzP//p0qVLdO3aNbp27eoK52Ziw4YNM//rv/7rxz/60Y+W6wYAALC7CYABAKAZ++UvfznirLPOuq64uNj3gZupmpqaWL9+/T//qaioiMrKyqisrIxNmzZFY2OjJn2AgoKCaN++fbRr1y7at28fHTt2jC5dukSnTp2ic+fOUVxcrEnN1NatW98aP378PVdcccXLugEAAOwpAmAAAGjm2rVrl//ggw+eOWLEiCsLCwvb6gjvtHnz5n+GwZs2bYrKysqorq6OLVu2xJYtW6K6ujqqq6sjk8nk3NpTqVS0bt06WrduHWVlZdGmTZsoLS39X2Fvu3btok2bNh4U/peGhobKl1566efnnHPO+OrqavevAwAAe5QAGAAAiIiIoUOHFt97770XHHjggRfk5+c7ssiHlk6n/xkEV1dXR01Nzfv+k8lkora2NtLpdNTX10dTU1PU1dXt0u8U5+XlRcuWLSM/Pz+KiooiLy8vWrVqFalUKoqLi3f6T0lJSbRq1eqfgW9paWnk5eUZMB9aU1NTzYIFC/745S9/+Y+zZ8+u0REAAGBvEAADAAD/y2mnndb2rrvuurRPnz5n5+XlFeoIe9LbgfDbtm/f/r7XUBcUFESLFi3++b/fDnxhT8pkMg1LliwZd8stt/xq0qRJVToCAADsTQJgAABgp0477bS2d95554X777//5wTBAP9XJpNpWLhw4QO33nrrHwS/AABAtni/ADi/7UHRc2c/SG+LqC33/gcAAHLZokWL6u69995X0un0swcddFCnkpKS3roC8A8VFRUz/7//7/+77aKLLpq6aNGiOh0BAACyRXH3xsgr3fnPBMAAAEDMnDmz8u67736qqalpWr9+/Ypbt27dN5VKpXQGaG4ymUx6zZo1U+65555/Peeccx6cOXNmpa4AAADZRgAMAAB8KDNnzqz88Y9//Gw6nZ4uCAaak7eD37vvvvtfzz///McEvwAAQDYTAAMAAB+JIBhoLgS/AABAEgmAAQCAj+XtILisrOyFvn37diwuLu4VEYJgIBdkKioqnrv33nu/PWbMmEcEvwAAQJK8XwCc2vecGLGzHzSui9j4aivdAwAA/unqq6/u8ZWvfOX8Pn36nJWXl9dCR4CkSafT9UuXLh3/X//1Xw/84he/WKMjAABAEnUYVhsFXXb+MwEwAADwkZ1xxhntb7/99rMPPPDA8/Pz81vrCJDtmpqaqhcsWPDgd77znUcmTpzotC8AAJBoAmAAAGC3GD58eMkPf/jDzwwePPjioqKijjoCZJv6+voNr7322u9vvPHGx2fPnl2jIwAAQC4QAAMAALvV0KFDi++5556zDjnkkPOKioq66giwt9XV1a19/fXXH7z++uvHC34BAIBcIwAGAAD2iFatWuXdc889w0455ZTzO3bseJSOAHtYZsOGDbOmTJny4PXXX/9qbW1tWksAAIBcJAAGAAD2uH/913/tf/7555/dq1ev0/Ly8lroCLC7pNPp+pUrV05+4IEHHvnOd76zSEcAAIBcJwAGAAD2mjPOOKP97bfffvYBBxzw2YKCgjY6AuwqjY2NVW+++eafv/e97z06YcKETToCAAA0FwJgAABgrxs+fHjJ97///dGDBg0aU1paur+OAB9XdXX1wtdee+3Rr371q1Nfe+21Wh0BAACaGwEwAACQVb761a/ue8EFF3y6b9++ZxUUFLTWEeCDNDY2bnnrrbfG/+EPf5j4ox/9aLmOAAAAzZkAGAAAyEpDhw4t/sEPfnDy4MGDz27dunV/HQHerbq6+s2XX375weuuu+7ppUuXbtcRAAAAATAAAJDlCgsLU3ffffeQ0aNHn9G1a9fj8vLyinQFmq90Ol1XXl4+bcqUKROuvfbav+sIAADA/yYABgAAEqNPnz4t/v3f/33UyJEjz2rfvv2nIiKlK9AsZDZt2vTXF1544bGvfe1rzzntCwAA8N4EwAAAQCJddNFFXa6++uqTDzzwwLNbtmzZTUcg99TV1a1ZsGDBuJ/+9KdP3n///et0BAAA4IMJgAEAgETr1q1b4d13333k4YcffmqHDh2OyMvLK9QVSK50Ot2wcePGWbNmzZp8/fXXz6qoqGjUFQAAgA9PAAwAAOSMo48+uvWtt956/CGHHHJKu3btBkdEnq5AIqQrKytfmzdv3uQ777xz+owZM6q1BAAA4OMRAAMAADnpuOOOK/vGN75x/CGHHHJa27ZtB4bvBUO2yVRVVc2dN2/epO9///vTpk+fvkVLAAAAPjkBMAAAkPNuu+22vmedddZJffr0Oa5Vq1a9dQT2ntra2uXLly+f/uijjz51xx13vKUjAAAAu5YAGAAAaFa+9KUvdbv44ouP7t+//wlOBsMekamqqpq7cOHCv/z+97+fcd9995VrCQAAwO4jAAYAAJqtSy65pOtll112jDAYdrl0VVXVvIULF/7lV7/61bO/+93v1moJAADAniEABgAAiIirr766x/nnnz9q//33P7JNmzZDUqlUga7Ah5fJZBoqKyv/vnjx4uf+9Kc/zbr33ntX6woAAMCeJwAGAAB4l379+hV97WtfGzRy5MhRPXv2PLaoqKizrsD/VV9fv37VqlXPvPDCC8/9+7//+5zFixfX6woAAMDeJQAGAAB4H61bt8678847Bx599NFHde/efURpaen+4apomq/M1q1bF69Zs+bF5557btY3v/nNOdXV1WltAQAAyB4CYAAAgI9g8ODBrcaOHXvI8OHDD+vevfvw1q1bHxACYXJXprq6+s01a9a88sorr7z8k5/8ZN5rr71Wqy0AAADZSwAMAADwCVx//fX7nHHGGYf169dvePv27Yfm5+e31hWSrLGxsXrjxo2vvvXWWy+PHz/+lR//+McrdQUAACA5BMAAAAC70Je//OUe55xzzvA+ffoM7tix45CioqKuukI2q6+vX7t27doXFy9ePGfixImv3Xvvvat1BQAAILkEwAAAALvRl7/85R6f+cxnBvfr129Qly5dDm/ZsqVAmL2qrq5u7bp16wS+AAAAOUoADAAAsIe0atUq75prrtnn2GOPPXi//fY7uH379oeUlpb2TaVS+brDbpKuqalZtnHjxnlvvfXW3GeffXbef/3Xfy2vra1Naw0AAEBuEgADAADsRQceeGDLq6+++oAhQ4Yc3LNnz4Pbtm17sGuj+biampqqq6qqXi8vL583Z86ceb/85S/nvfjii1t1BgAAoPkQAAMAAGSZoUOHFn/xi1/cf9CgQQf26NHjwHbt2h3YqlWr3qlUKk932CFdU1OzvLKycsHq1asXzJkzZ8Gf//znJTNmzKjWGgAAgOZNAAwAAJAAxx13XNkFF1xw4MEHH3xA165dDywtLd23pKRkn1QqVag7uS2TyTRs27ZtRXV19dJ169YtfOONNxZOmDBh4YQJEzbpDgAAAO8mAAYAAEiw8847r+OJJ57Yp3///vt16dKlT5s2bfZr3bp1v/z8/GLdSZampqaa6urqxZs3b16ybt26pQsXLlzy9NNPL33ooYc26A4AAAAflgAYAAAgx7Rr1y7/kksu6TFkyJCe++67b89OnTr1Kisr61VcXNyzZcuW3VKpVL4u7R2ZTKaprq6uvKamZtWWLVtWVlRUrFy6dOnK2bNnr7r//vvXVFZWNukSAAAAn4QAGAAAoBnp1KlTwec+97luQ4cO7bnPPvv0aNeuXafWrVt3Li4u7tqyZcvORUVFnfLy8lro1MeTTqe319fXr6+rq6uoqalZW11dvb6ysnL9ihUrVr/66qurHnzwwbUVFRWNOgUAAMDuIgAGAADgfznjjDPaH3bYYZ369OnTuUuXLp3Kysral5SUtC0uLu5YVFTUrqioqG2LFi065OfnlzaXnjQ1NW3dvn37xvr6+qr6+vrKmpqaDdu2bavasmXLpnXr1lUsXbp0/Ysvvrh+4sSJlZ4gAAAA9iYBMAAAAB9Lr169CkeNGtXuoIMOatexY8ey9u3bl7Zp06Z1SUlJWXFxcetWrVq1btGiRVlRUVHrwsLC1hGRX1hYWBoR+QUFBSV5eXkFeXl5u/0/LtPpdG06nW5sbGzcFhFNDQ0NW3f83+r6+vrq7du3b6mtra2uqamp3rZtW/XmzZurN23aVL1hw4YtCxYsqJo1a1bl0qVLt5s4AAAASSAABgAAYK/q169fUffu3Vvss88+xSUlJQVv//8LCwtT3bp1+8BTxuXl5VsbGhoyb//vbdu2Na5YsaJmzZo12xcvXlyvwwAAADQn7xcAF2gPAAAAu9vixYvrdwS11boBAAAAu0+eFgAAAAAAAADkBgEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4o0AIAAAAAAACA5GhoLIyCxoaIiEilIpNXGE1v/0wADAAAAAAAAJAghQUN/0x6MxGppvT/5L6ugAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAIb/v5272ZHiusM4/FZ1NUkz9sQwOF4EyZJtpJCwysa5jSy4n1xPEqRIuQFvvfGSgIwBOzGRQAQERnx0d1UW0cgWGvKxsMGvnmfVdc7/1OJsf+oCAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoMY3JP//9K8My551lzpAk293a7QAAAAAAAAD8iIw3r+SL7TpPxuSt4/ibJJuz20QDBgAAAAAAAHhzrJPp6NvHYcyyjLl7dJTPbl/Jp6sPLufSsM+5ec7q5YOrF0OeP/SVaAAAAAAAAIA3weH7u6zfm79dWDIMSw6225w785vsx3XyzasOby5ssz69c4sAAAAAAAAAr9n69C6bC9sT93a7rKdnORin5Otxynzi1JQcfiwCAwAAAAAAALxO69O7HH68TaaT98cp85R8vbp3Nfszv8q0LHn7xMF1sjk/ZzUPmZ/MmWefhAYAAAAAAAD4oayPdjn7223Gn7x6ZrXPnetX8mBKkpv3cufDd/Pufn5FL56SzcVtNheT3dNt8tQlAwAAAAAAAHyv1sm0ySv/9XtsNWZ3I/lHkgzHi7/4XY7WYz5yiwAAAAAAAAA/Ivtcv/3nPEyS1fHa42t5+vNLyX7JoRsCAAAAAAAAePPt1/nbV3/KvePn1Xc371/NYxEYAAAAAAAA4M0yTHk2rvNo2WdzvHZqzN9v/SF3vju3evng/at5fPDLPDu1yuGyZHSVAAAAAAAAAK/XOGe4ueSvZ4e8M8xZbVe5ceuPufvy3Oqkw4+v5emDX+fuuTlLhhwsEYIBAAAAAAAAXpclGR8OuXP0TR4cPM/9z/+SRyfNDf/1TZezOp/87KdjzizJZkhO7edMy/w/nAUAAAAAAADg/zaMWcZkP8/ZLsmLacr2/MV8+cnvs/tP5/4FmLjAq1ifcioAAAAASUVORK5CYII=";

  // src/gen-utils.ts
  function getSmartParseNumber(size, xyDir, layout) {
    if (typeof size === "string" && !isNaN(Number(size))) size = Number(size);
    if (typeof size === "number" && size < 100) return inch2Emu(size);
    if (typeof size === "number" && size >= 100) return size;
    if (typeof size === "string" && size.includes("%")) {
      if (xyDir && xyDir === "X") return Math.round(parseFloat(size) / 100 * layout.width);
      if (xyDir && xyDir === "Y") return Math.round(parseFloat(size) / 100 * layout.height);
      return Math.round(parseFloat(size) / 100 * layout.width);
    }
    return 0;
  }
  function getUuid(uuidFormat) {
    return uuidFormat.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  function encodeXmlEntities(xml2) {
    if (typeof xml2 === "undefined" || xml2 == null) return "";
    return xml2.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  function inch2Emu(inches) {
    if (typeof inches === "number" && inches > 100) return inches;
    if (typeof inches === "string") inches = Number(inches.replace(/in*/gi, ""));
    return Math.round(EMU * inches);
  }
  function valToPts(pt) {
    const points = Number(pt) || 0;
    return isNaN(points) ? 0 : Math.round(points * ONEPT);
  }
  function convertRotationDegrees(d) {
    d = d || 0;
    return Math.round((d > 360 ? d - 360 : d) * 6e4);
  }
  function componentToHex(c) {
    const hex = c.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }
  function rgbToHex(r, g, b) {
    return (componentToHex(r) + componentToHex(g) + componentToHex(b)).toUpperCase();
  }
  function createColorElement(colorStr, innerElements) {
    let colorVal = (colorStr || "").replace("#", "");
    if (!REGEX_HEX_COLOR.test(colorVal) && colorVal !== "bg1" /* background1 */ && colorVal !== "bg2" /* background2 */ && colorVal !== "tx1" /* text1 */ && colorVal !== "tx2" /* text2 */ && colorVal !== "accent1" /* accent1 */ && colorVal !== "accent2" /* accent2 */ && colorVal !== "accent3" /* accent3 */ && colorVal !== "accent4" /* accent4 */ && colorVal !== "accent5" /* accent5 */ && colorVal !== "accent6" /* accent6 */) {
      console.warn(`"${colorVal}" is not a valid scheme color or hex RGB! "${DEF_FONT_COLOR}" used instead. Only provide 6-digit RGB or 'pptx.SchemeColor' values!`);
      colorVal = DEF_FONT_COLOR;
    }
    const tagName = REGEX_HEX_COLOR.test(colorVal) ? "srgbClr" : "schemeClr";
    const colorAttr = 'val="' + (REGEX_HEX_COLOR.test(colorVal) ? colorVal.toUpperCase() : colorVal) + '"';
    return innerElements ? `<a:${tagName} ${colorAttr}>${innerElements}</a:${tagName}>` : `<a:${tagName} ${colorAttr}/>`;
  }
  function createGlowElement(options, defaults) {
    var _a, _b, _c;
    let strXml = "";
    const opts = __spreadValues(__spreadValues({}, defaults), options);
    const size = Math.round(((_a = opts.size) != null ? _a : 0) * ONEPT);
    const color = (_b = opts.color) != null ? _b : "FFFFFF";
    const opacity = Math.round(((_c = opts.opacity) != null ? _c : 0.75) * 1e5);
    strXml += `<a:glow rad="${size}">`;
    strXml += createColorElement(color, `<a:alpha val="${opacity}"/>`);
    strXml += "</a:glow>";
    return strXml;
  }
  function genXmlColorSelection(props) {
    let fillType = "solid";
    let colorVal = "";
    let internalElements = "";
    let outText = "";
    if (props) {
      if (typeof props === "string") colorVal = props;
      else {
        if (props.type) fillType = props.type;
        if (props.color) colorVal = props.color;
        if (props.transparency) internalElements += `<a:alpha val="${Math.round((100 - props.transparency) * 1e3)}"/>`;
      }
      switch (fillType) {
        case "solid":
          outText += `<a:solidFill>${createColorElement(colorVal, internalElements)}</a:solidFill>`;
          break;
        case "gradient":
          if (typeof props === "object" && "gradient" in props && props.gradient) {
            outText += generateGradientFillXml(props.gradient);
          }
          break;
        default:
          outText += "";
          break;
      }
    }
    return outText;
  }
  function generateGradientFillXml(gradient) {
    var _a, _b;
    const gradientType = (_a = gradient.type) != null ? _a : "linear";
    const angle = (_b = gradient.angle) != null ? _b : 90;
    const ooxmlAngle = angle * 6e4;
    let xml2 = "<a:gradFill>";
    xml2 += "<a:gsLst>";
    for (const stop of gradient.stops) {
      const position = Math.round(stop.position * 1e3);
      let stopInnerElements = "";
      if (stop.transparency) {
        stopInnerElements = `<a:alpha val="${Math.round((100 - stop.transparency) * 1e3)}"/>`;
      }
      xml2 += `<a:gs pos="${position}">${createColorElement(stop.color, stopInnerElements)}</a:gs>`;
    }
    xml2 += "</a:gsLst>";
    if (gradientType === "linear") {
      xml2 += `<a:lin ang="${ooxmlAngle}" scaled="1"/>`;
    } else if (gradientType === "radial") {
      xml2 += '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
    }
    xml2 += "</a:gradFill>";
    return xml2;
  }
  function getNewRelId(target) {
    return target._rels.length + target._relsChart.length + target._relsMedia.length + 1;
  }
  function correctShadowOptions(ShadowProps) {
    if (!ShadowProps || typeof ShadowProps !== "object") {
      return;
    }
    if (ShadowProps.type !== "outer" && ShadowProps.type !== "inner" && ShadowProps.type !== "none") {
      console.warn("Warning: shadow.type options are `outer`, `inner` or `none`.");
      ShadowProps.type = "outer";
    }
    if (ShadowProps.angle) {
      if (isNaN(Number(ShadowProps.angle)) || ShadowProps.angle < 0 || ShadowProps.angle > 359) {
        console.warn("Warning: shadow.angle can only be 0-359");
        ShadowProps.angle = 270;
      }
      ShadowProps.angle = Math.round(Number(ShadowProps.angle));
    }
    if (ShadowProps.opacity) {
      if (isNaN(Number(ShadowProps.opacity)) || ShadowProps.opacity < 0 || ShadowProps.opacity > 1) {
        console.warn("Warning: shadow.opacity can only be 0-1");
        ShadowProps.opacity = 0.75;
      }
      ShadowProps.opacity = Number(ShadowProps.opacity);
    }
    if (ShadowProps.color) {
      if (ShadowProps.color.startsWith("#")) {
        console.warn('Warning: shadow.color should not include hash (#) character, , e.g. "FF0000"');
        ShadowProps.color = ShadowProps.color.replace("#", "");
      }
    }
    return ShadowProps;
  }

  // src/gen-tables.ts
  function parseTextToLines(cell, colWidth, verbose) {
    var _a, _b;
    const FOCO = 2.3 + (((_a = cell.options) == null ? void 0 : _a.autoPageCharWeight) ? cell.options.autoPageCharWeight : 0);
    const CPL = Math.floor(colWidth / ONEPT * EMU) / ((((_b = cell.options) == null ? void 0 : _b.fontSize) ? cell.options.fontSize : DEF_FONT_SIZE) / FOCO);
    const parsedLines = [];
    let inputCells = [];
    const inputLines1 = [];
    const inputLines2 = [];
    if (cell.text && cell.text.toString().trim().length === 0) {
      inputCells.push({ _type: "tablecell" /* tablecell */, text: " " });
    } else if (typeof cell.text === "number" || typeof cell.text === "string") {
      inputCells.push({ _type: "tablecell" /* tablecell */, text: (cell.text || "").toString().trim() });
    } else if (Array.isArray(cell.text)) {
      inputCells = cell.text;
    }
    if (verbose) {
      console.log("[1/4] inputCells");
      inputCells.forEach((cell2, idx) => console.log(`[1/4] [${idx + 1}] cell: ${JSON.stringify(cell2)}`));
    }
    let newLine = [];
    inputCells.forEach((cell2) => {
      var _a2;
      if (typeof cell2.text === "string") {
        if (cell2.text.split("\n").length > 1) {
          cell2.text.split("\n").forEach((textLine) => {
            newLine.push({
              _type: "tablecell" /* tablecell */,
              text: textLine,
              options: __spreadValues(__spreadValues({}, cell2.options), { breakLine: true })
            });
          });
        } else {
          newLine.push({
            _type: "tablecell" /* tablecell */,
            text: cell2.text.trim(),
            options: cell2.options
          });
        }
        if ((_a2 = cell2.options) == null ? void 0 : _a2.breakLine) {
          if (verbose) console.log(`inputCells: new line > ${JSON.stringify(newLine)}`);
          inputLines1.push(newLine);
          newLine = [];
        }
      }
      if (newLine.length > 0) {
        inputLines1.push(newLine);
        newLine = [];
      }
    });
    if (verbose) {
      console.log(`[2/4] inputLines1 (${inputLines1.length})`);
      inputLines1.forEach((line, idx) => console.log(`[2/4] [${idx + 1}] line: ${JSON.stringify(line)}`));
    }
    inputLines1.forEach((line) => {
      line.forEach((cell2) => {
        const lineCells = [];
        const cellTextStr = String(cell2.text);
        const lineWords = cellTextStr.split(" ");
        lineWords.forEach((word, idx) => {
          const cellProps = __spreadValues({}, cell2.options);
          if (cellProps == null ? void 0 : cellProps.breakLine) cellProps.breakLine = idx + 1 === lineWords.length;
          lineCells.push({ _type: "tablecell" /* tablecell */, text: word + (idx + 1 < lineWords.length ? " " : ""), options: cellProps });
        });
        inputLines2.push(lineCells);
      });
    });
    if (verbose) {
      console.log(`[3/4] inputLines2 (${inputLines2.length})`);
      inputLines2.forEach((line) => console.log(`[3/4] line: ${JSON.stringify(line)}`));
    }
    inputLines2.forEach((line) => {
      let lineCells = [];
      let strCurrLine = "";
      line.forEach((word) => {
        if (strCurrLine.length + word.text.length > CPL) {
          parsedLines.push(lineCells);
          lineCells = [];
          strCurrLine = "";
        }
        lineCells.push(word);
        strCurrLine += word.text.toString();
      });
      if (lineCells.length > 0) parsedLines.push(lineCells);
    });
    if (verbose) {
      console.log(`[4/4] parsedLines (${parsedLines.length})`);
      parsedLines.forEach((line, idx) => console.log(`[4/4] [Line ${idx + 1}]:
${JSON.stringify(line)}`));
      console.log("...............................................\n\n");
    }
    return parsedLines;
  }
  function getSlidesForTableRows(tableRows = [], tableProps = {}, presLayout, masterSlide) {
    let arrInchMargins = DEF_SLIDE_MARGIN_IN;
    let emuSlideTabW = EMU * 1;
    let emuSlideTabH = EMU * 1;
    let emuTabCurrH = 0;
    let numCols = 0;
    const tableRowSlides = [];
    const tablePropX = getSmartParseNumber(tableProps.x, "X", presLayout);
    const tablePropY = getSmartParseNumber(tableProps.y, "Y", presLayout);
    const tablePropW = getSmartParseNumber(tableProps.w, "X", presLayout);
    const tablePropH = getSmartParseNumber(tableProps.h, "Y", presLayout);
    let tableCalcW = tablePropW;
    function calcSlideTabH() {
      let emuStartY = 0;
      if (tableRowSlides.length === 0) emuStartY = tablePropY || inch2Emu(arrInchMargins[0]);
      if (tableRowSlides.length > 0) emuStartY = inch2Emu(tableProps.autoPageSlideStartY || tableProps.newSlideStartY || arrInchMargins[0]);
      emuSlideTabH = (tablePropH || presLayout.height) - emuStartY - inch2Emu(arrInchMargins[2]);
      if (tableRowSlides.length > 1) {
        if (typeof tableProps.autoPageSlideStartY === "number") {
          emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu(tableProps.autoPageSlideStartY + arrInchMargins[2]);
        } else if (tablePropY) {
          emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu((tablePropY / EMU < arrInchMargins[0] ? tablePropY / EMU : arrInchMargins[0]) + arrInchMargins[2]);
          if (emuSlideTabH < tablePropH) emuSlideTabH = tablePropH;
        }
      }
    }
    if (tableProps.verbose) {
      console.log("[[VERBOSE MODE]]");
      console.log("|-- TABLE PROPS --------------------------------------------------------|");
      console.log(`| presLayout.width ................................ = ${(presLayout.width / EMU).toFixed(1)}`);
      console.log(`| presLayout.height ............................... = ${(presLayout.height / EMU).toFixed(1)}`);
      console.log(`| tableProps.x .................................... = ${typeof tableProps.x === "number" ? (tableProps.x / EMU).toFixed(1) : tableProps.x}`);
      console.log(`| tableProps.y .................................... = ${typeof tableProps.y === "number" ? (tableProps.y / EMU).toFixed(1) : tableProps.y}`);
      console.log(`| tableProps.w .................................... = ${typeof tableProps.w === "number" ? (tableProps.w / EMU).toFixed(1) : tableProps.w}`);
      console.log(`| tableProps.h .................................... = ${typeof tableProps.h === "number" ? (tableProps.h / EMU).toFixed(1) : tableProps.h}`);
      console.log(`| tableProps.slideMargin .......................... = ${tableProps.slideMargin ? String(tableProps.slideMargin) : ""}`);
      console.log(`| tableProps.margin ............................... = ${String(tableProps.margin)}`);
      console.log(`| tableProps.colW ................................. = ${String(tableProps.colW)}`);
      console.log(`| tableProps.autoPageSlideStartY .................. = ${tableProps.autoPageSlideStartY}`);
      console.log(`| tableProps.autoPageCharWeight ................... = ${tableProps.autoPageCharWeight}`);
      console.log("|-- CALCULATIONS -------------------------------------------------------|");
      console.log(`| tablePropX ...................................... = ${tablePropX / EMU}`);
      console.log(`| tablePropY ...................................... = ${tablePropY / EMU}`);
      console.log(`| tablePropW ...................................... = ${tablePropW / EMU}`);
      console.log(`| tablePropH ...................................... = ${tablePropH / EMU}`);
      console.log(`| tableCalcW ...................................... = ${tableCalcW / EMU}`);
    }
    {
      if (!tableProps.slideMargin && tableProps.slideMargin !== 0) tableProps.slideMargin = DEF_SLIDE_MARGIN_IN[0];
      if (masterSlide && typeof masterSlide._margin !== "undefined") {
        if (Array.isArray(masterSlide._margin)) arrInchMargins = masterSlide._margin;
        else if (!isNaN(Number(masterSlide._margin))) {
          arrInchMargins = [Number(masterSlide._margin), Number(masterSlide._margin), Number(masterSlide._margin), Number(masterSlide._margin)];
        }
      } else if (tableProps.slideMargin || tableProps.slideMargin === 0) {
        if (Array.isArray(tableProps.slideMargin)) arrInchMargins = tableProps.slideMargin;
        else if (!isNaN(tableProps.slideMargin)) arrInchMargins = [tableProps.slideMargin, tableProps.slideMargin, tableProps.slideMargin, tableProps.slideMargin];
      }
      if (tableProps.verbose) console.log(`| arrInchMargins .................................. = [${arrInchMargins.join(", ")}]`);
    }
    {
      const firstRow = tableRows[0] || [];
      firstRow.forEach((cell) => {
        if (!cell) cell = { _type: "tablecell" /* tablecell */ };
        const cellOpts = cell.options || null;
        numCols += Number((cellOpts == null ? void 0 : cellOpts.colspan) ? cellOpts.colspan : 1);
      });
      if (tableProps.verbose) console.log(`| numCols ......................................... = ${numCols}`);
    }
    if (!tablePropW && tableProps.colW) {
      tableCalcW = Array.isArray(tableProps.colW) ? tableProps.colW.reduce((p, n) => p + n) * EMU : tableProps.colW * numCols || 0;
      if (tableProps.verbose) console.log(`| tableCalcW ...................................... = ${tableCalcW / EMU}`);
    }
    {
      emuSlideTabW = tableCalcW || inch2Emu((tablePropX ? tablePropX / EMU : arrInchMargins[1]) + arrInchMargins[3]);
      if (tableProps.verbose) console.log(`| emuSlideTabW .................................... = ${(emuSlideTabW / EMU).toFixed(1)}`);
    }
    if (!tableProps.colW || !Array.isArray(tableProps.colW)) {
      if (tableProps.colW && !isNaN(Number(tableProps.colW))) {
        const arrColW = [];
        const firstRow = tableRows[0] || [];
        firstRow.forEach(() => arrColW.push(tableProps.colW));
        tableProps.colW = [];
        arrColW.forEach((val) => {
          if (Array.isArray(tableProps.colW)) tableProps.colW.push(val);
        });
      } else {
        tableProps.colW = [];
        for (let iCol = 0; iCol < numCols; iCol++) {
          tableProps.colW.push(emuSlideTabW / EMU / numCols);
        }
      }
    }
    let newTableRowSlide = { rows: [] };
    tableRows.forEach((row, iRow) => {
      const rowCellLines = [];
      let maxCellMarTopEmu = 0;
      let maxCellMarBtmEmu = 0;
      let currTableRow = [];
      row.forEach((cell) => {
        var _a, _b, _c, _d;
        currTableRow.push({
          _type: "tablecell" /* tablecell */,
          text: [],
          options: cell.options
        });
        if (cell.options.margin && cell.options.margin[0] >= 1) {
          if (((_a = cell.options) == null ? void 0 : _a.margin) && cell.options.margin[0] && valToPts(cell.options.margin[0]) > maxCellMarTopEmu) maxCellMarTopEmu = valToPts(cell.options.margin[0]);
          else if ((tableProps == null ? void 0 : tableProps.margin) && tableProps.margin[0] && valToPts(tableProps.margin[0]) > maxCellMarTopEmu) maxCellMarTopEmu = valToPts(tableProps.margin[0]);
          if (((_b = cell.options) == null ? void 0 : _b.margin) && cell.options.margin[2] && valToPts(cell.options.margin[2]) > maxCellMarBtmEmu) maxCellMarBtmEmu = valToPts(cell.options.margin[2]);
          else if ((tableProps == null ? void 0 : tableProps.margin) && tableProps.margin[2] && valToPts(tableProps.margin[2]) > maxCellMarBtmEmu) maxCellMarBtmEmu = valToPts(tableProps.margin[2]);
        } else {
          if (((_c = cell.options) == null ? void 0 : _c.margin) && cell.options.margin[0] && inch2Emu(cell.options.margin[0]) > maxCellMarTopEmu) maxCellMarTopEmu = inch2Emu(cell.options.margin[0]);
          else if ((tableProps == null ? void 0 : tableProps.margin) && tableProps.margin[0] && inch2Emu(tableProps.margin[0]) > maxCellMarTopEmu) maxCellMarTopEmu = inch2Emu(tableProps.margin[0]);
          if (((_d = cell.options) == null ? void 0 : _d.margin) && cell.options.margin[2] && inch2Emu(cell.options.margin[2]) > maxCellMarBtmEmu) maxCellMarBtmEmu = inch2Emu(cell.options.margin[2]);
          else if ((tableProps == null ? void 0 : tableProps.margin) && tableProps.margin[2] && inch2Emu(tableProps.margin[2]) > maxCellMarBtmEmu) maxCellMarBtmEmu = inch2Emu(tableProps.margin[2]);
        }
      });
      calcSlideTabH();
      emuTabCurrH += maxCellMarTopEmu + maxCellMarBtmEmu;
      if (tableProps.verbose && iRow === 0) console.log(`| SLIDE [${tableRowSlides.length}]: emuSlideTabH ...... = ${(emuSlideTabH / EMU).toFixed(1)} `);
      row.forEach((cell, iCell) => {
        var _a;
        const newCell = {
          _type: "tablecell" /* tablecell */,
          _lines: null,
          _lineHeight: inch2Emu(
            (((_a = cell.options) == null ? void 0 : _a.fontSize) ? cell.options.fontSize : tableProps.fontSize ? tableProps.fontSize : DEF_FONT_SIZE) * (LINEH_MODIFIER + (tableProps.autoPageLineWeight ? tableProps.autoPageLineWeight : 0)) / 100
          ),
          text: [],
          options: cell.options
        };
        if (newCell.options.rowspan) newCell._lineHeight = 0;
        newCell.options.autoPageCharWeight = tableProps.autoPageCharWeight ? tableProps.autoPageCharWeight : null;
        let totalColW = tableProps.colW[iCell];
        if (cell.options.colspan && Array.isArray(tableProps.colW)) {
          totalColW = tableProps.colW.filter((_cell, idx) => idx >= iCell && idx < idx + cell.options.colspan).reduce((prev, curr) => prev + curr);
        }
        newCell._lines = parseTextToLines(cell, totalColW, false);
        rowCellLines.push(newCell);
      });
      if (tableProps.verbose) console.log(`
| SLIDE [${tableRowSlides.length}]: ROW [${iRow}]: START...`);
      let currCellIdx = 0;
      let emuLineMaxH = 0;
      let isDone = false;
      while (!isDone) {
        const srcCell = rowCellLines[currCellIdx];
        let tgtCell = currTableRow[currCellIdx];
        rowCellLines.forEach((cell) => {
          if (cell._lineHeight >= emuLineMaxH) emuLineMaxH = cell._lineHeight;
        });
        if (emuTabCurrH + emuLineMaxH > emuSlideTabH) {
          if (tableProps.verbose) {
            console.log("\n|-----------------------------------------------------------------------|");
            console.log(`|-- NEW SLIDE CREATED (currTabH+currLineH > maxH) => ${(emuTabCurrH / EMU).toFixed(2)} + ${(srcCell._lineHeight / EMU).toFixed(2)} > ${emuSlideTabH / EMU}`);
            console.log("|-----------------------------------------------------------------------|\n\n");
          }
          if (currTableRow.length > 0 && currTableRow.map((cell) => cell.text.length).reduce((p, n) => p + n) > 0) newTableRowSlide.rows.push(currTableRow);
          tableRowSlides.push(newTableRowSlide);
          const newRows = [];
          newTableRowSlide = { rows: newRows };
          currTableRow = [];
          row.forEach((cell) => currTableRow.push({ _type: "tablecell" /* tablecell */, text: [], options: cell.options }));
          calcSlideTabH();
          emuTabCurrH += maxCellMarTopEmu + maxCellMarBtmEmu;
          if (tableProps.verbose) console.log(`| SLIDE [${tableRowSlides.length}]: emuSlideTabH ...... = ${(emuSlideTabH / EMU).toFixed(1)} `);
          emuTabCurrH = 0;
          if ((tableProps.addHeaderToEach || tableProps.autoPageRepeatHeader) && tableProps._arrObjTabHeadRows) {
            tableProps._arrObjTabHeadRows.forEach((row2) => {
              const newHeadRow = [];
              let maxLineHeight = 0;
              row2.forEach((cell) => {
                newHeadRow.push(cell);
                if (cell._lineHeight > maxLineHeight) maxLineHeight = cell._lineHeight;
              });
              newTableRowSlide.rows.push(newHeadRow);
              emuTabCurrH += maxLineHeight;
            });
          }
          tgtCell = currTableRow[currCellIdx];
        }
        const currLine = srcCell._lines.shift();
        if (Array.isArray(tgtCell.text)) {
          if (currLine) tgtCell.text = tgtCell.text.concat(currLine);
          else if (tgtCell.text.length === 0) tgtCell.text = tgtCell.text.concat({ _type: "tablecell" /* tablecell */, text: "" });
        }
        if (currCellIdx === rowCellLines.length - 1) emuTabCurrH += emuLineMaxH;
        currCellIdx = currCellIdx < rowCellLines.length - 1 ? currCellIdx + 1 : 0;
        const brent = rowCellLines.map((cell) => cell._lines.length).reduce((prev, next) => prev + next);
        if (brent === 0) isDone = true;
      }
      if (currTableRow.length > 0) newTableRowSlide.rows.push(currTableRow);
      if (tableProps.verbose) {
        console.log(
          `- SLIDE [${tableRowSlides.length}]: ROW [${iRow}]: ...COMPLETE ...... emuTabCurrH = ${(emuTabCurrH / EMU).toFixed(2)} ( emuSlideTabH = ${(emuSlideTabH / EMU).toFixed(2)} )`
        );
      }
    });
    tableRowSlides.push(newTableRowSlide);
    if (tableProps.verbose) {
      console.log("\n|================================================|");
      console.log(`| FINAL: tableRowSlides.length = ${tableRowSlides.length}`);
      tableRowSlides.forEach((slide) => console.log(slide));
      console.log("|================================================|\n\n");
    }
    return tableRowSlides;
  }
  function genTableToSlides(pptx, tabEleId, options = {}, masterSlide) {
    const opts = options || {};
    opts.slideMargin = opts.slideMargin || opts.slideMargin === 0 ? opts.slideMargin : 0.5;
    let emuSlideTabW = opts.w || pptx.presLayout.width;
    const arrObjTabHeadRows = [];
    const arrObjTabBodyRows = [];
    const arrObjTabFootRows = [];
    const arrColW = [];
    const arrTabColW = [];
    let arrInchMargins = [0.5, 0.5, 0.5, 0.5];
    let intTabW = 0;
    if (!document.getElementById(tabEleId)) throw new Error('tableToSlides: Table ID "' + tabEleId + '" does not exist!');
    if (masterSlide == null ? void 0 : masterSlide._margin) {
      if (Array.isArray(masterSlide._margin)) arrInchMargins = masterSlide._margin;
      else if (!isNaN(masterSlide._margin)) arrInchMargins = [masterSlide._margin, masterSlide._margin, masterSlide._margin, masterSlide._margin];
      opts.slideMargin = arrInchMargins;
    } else if (opts == null ? void 0 : opts.slideMargin) {
      if (Array.isArray(opts.slideMargin)) arrInchMargins = opts.slideMargin;
      else if (!isNaN(opts.slideMargin)) arrInchMargins = [opts.slideMargin, opts.slideMargin, opts.slideMargin, opts.slideMargin];
    }
    emuSlideTabW = (opts.w ? inch2Emu(opts.w) : pptx.presLayout.width) - inch2Emu(arrInchMargins[1] + arrInchMargins[3]);
    if (opts.verbose) {
      console.log("[[VERBOSE MODE]]");
      console.log("|-- `tableToSlides` ----------------------------------------------------|");
      console.log(`| tableProps.h .................................... = ${opts.h}`);
      console.log(`| tableProps.w .................................... = ${opts.w}`);
      console.log(`| pptx.presLayout.width ........................... = ${(pptx.presLayout.width / EMU).toFixed(1)}`);
      console.log(`| pptx.presLayout.height .......................... = ${(pptx.presLayout.height / EMU).toFixed(1)}`);
      console.log(`| emuSlideTabW .................................... = ${(emuSlideTabW / EMU).toFixed(1)}`);
    }
    let firstRowCells = document.querySelectorAll(`#${tabEleId} tr:first-child th`);
    if (firstRowCells.length === 0) firstRowCells = document.querySelectorAll(`#${tabEleId} tr:first-child td`);
    firstRowCells.forEach((cellEle) => {
      const cell = cellEle;
      if (cell.getAttribute("colspan")) {
        for (let idxc = 0; idxc < Number(cell.getAttribute("colspan")); idxc++) {
          arrTabColW.push(Math.round(cell.offsetWidth / Number(cell.getAttribute("colspan"))));
        }
      } else {
        arrTabColW.push(cell.offsetWidth);
      }
    });
    arrTabColW.forEach((colW) => {
      intTabW += colW;
    });
    arrTabColW.forEach((colW, idxW) => {
      const intCalcWidth = Number((Number(emuSlideTabW) * (colW / intTabW * 100) / 100 / EMU).toFixed(2));
      let intMinWidth = 0;
      const colSelectorMin = document.querySelector(`#${tabEleId} thead tr:first-child th:nth-child(${idxW + 1})`);
      if (colSelectorMin) intMinWidth = Number(colSelectorMin.getAttribute("data-pptx-min-width"));
      const intSetWidth = 0;
      const colSelectorSet = document.querySelector(`#${tabEleId} thead tr:first-child th:nth-child(${idxW + 1})`);
      if (colSelectorSet) intMinWidth = Number(colSelectorSet.getAttribute("data-pptx-width"));
      arrColW.push(intSetWidth || (intMinWidth > intCalcWidth ? intMinWidth : intCalcWidth));
    });
    if (opts.verbose) {
      console.log(`| arrColW ......................................... = [${arrColW.join(", ")}]`);
    }
    const tableParts = ["thead", "tbody", "tfoot"];
    tableParts.forEach((part) => {
      document.querySelectorAll(`#${tabEleId} ${part} tr`).forEach((row) => {
        const htmlRow = row;
        const arrObjTabCells = [];
        Array.from(htmlRow.cells).forEach((cell) => {
          const arrRGB1 = window.getComputedStyle(cell).getPropertyValue("color").replace(/\s+/gi, "").replace("rgba(", "").replace("rgb(", "").replace(")", "").split(",");
          let arrRGB2 = window.getComputedStyle(cell).getPropertyValue("background-color").replace(/\s+/gi, "").replace("rgba(", "").replace("rgb(", "").replace(")", "").split(",");
          if (
            // NOTE: (ISSUE#57): Default for unstyled tables is black bkgd, so use white instead
            window.getComputedStyle(cell).getPropertyValue("background-color") === "rgba(0, 0, 0, 0)" || window.getComputedStyle(cell).getPropertyValue("transparent")
          ) {
            arrRGB2 = ["255", "255", "255"];
          }
          const cellOpts = {
            align: null,
            bold: !!(window.getComputedStyle(cell).getPropertyValue("font-weight") === "bold" || Number(window.getComputedStyle(cell).getPropertyValue("font-weight")) >= 500),
            border: null,
            color: rgbToHex(Number(arrRGB1[0]), Number(arrRGB1[1]), Number(arrRGB1[2])),
            fill: { color: rgbToHex(Number(arrRGB2[0]), Number(arrRGB2[1]), Number(arrRGB2[2])) },
            fontFace: (window.getComputedStyle(cell).getPropertyValue("font-family") || "").split(",")[0].replace(/"/g, "").replace("inherit", "").replace("initial", "") || null,
            fontSize: Number(window.getComputedStyle(cell).getPropertyValue("font-size").replace(/[a-z]/gi, "")),
            margin: null,
            colspan: Number(cell.getAttribute("colspan")) || null,
            rowspan: Number(cell.getAttribute("rowspan")) || null,
            valign: null
          };
          if (["left", "center", "right", "start", "end"].includes(window.getComputedStyle(cell).getPropertyValue("text-align"))) {
            const align = window.getComputedStyle(cell).getPropertyValue("text-align").replace("start", "left").replace("end", "right");
            cellOpts.align = align === "center" ? "center" : align === "left" ? "left" : align === "right" ? "right" : null;
          }
          if (["top", "middle", "bottom"].includes(window.getComputedStyle(cell).getPropertyValue("vertical-align"))) {
            const valign = window.getComputedStyle(cell).getPropertyValue("vertical-align");
            cellOpts.valign = valign === "top" ? "top" : valign === "middle" ? "middle" : valign === "bottom" ? "bottom" : null;
          }
          if (window.getComputedStyle(cell).getPropertyValue("padding-left")) {
            cellOpts.margin = [0, 0, 0, 0];
            const sidesPad = ["padding-top", "padding-right", "padding-bottom", "padding-left"];
            sidesPad.forEach((val, idxs) => {
              cellOpts.margin[idxs] = Math.round(Number(window.getComputedStyle(cell).getPropertyValue(val).replace(/\D/gi, "")));
            });
          }
          if (window.getComputedStyle(cell).getPropertyValue("border-top-width") || window.getComputedStyle(cell).getPropertyValue("border-right-width") || window.getComputedStyle(cell).getPropertyValue("border-bottom-width") || window.getComputedStyle(cell).getPropertyValue("border-left-width")) {
            cellOpts.border = [null, null, null, null];
            const sidesBor = ["top", "right", "bottom", "left"];
            sidesBor.forEach((val, idxb) => {
              const intBorderW = Math.round(
                Number(
                  window.getComputedStyle(cell).getPropertyValue("border-" + val + "-width").replace("px", "")
                )
              );
              let arrRGB = [];
              arrRGB = window.getComputedStyle(cell).getPropertyValue("border-" + val + "-color").replace(/\s+/gi, "").replace("rgba(", "").replace("rgb(", "").replace(")", "").split(",");
              const strBorderC = rgbToHex(Number(arrRGB[0]), Number(arrRGB[1]), Number(arrRGB[2]));
              cellOpts.border[idxb] = { pt: intBorderW, color: strBorderC };
            });
          }
          arrObjTabCells.push({
            _type: "tablecell" /* tablecell */,
            text: cell.innerText,
            // `innerText` returns <br> as "\n", so linebreak etc. work later!
            options: cellOpts
          });
        });
        switch (part) {
          case "thead":
            arrObjTabHeadRows.push(arrObjTabCells);
            break;
          case "tbody":
            arrObjTabBodyRows.push(arrObjTabCells);
            break;
          case "tfoot":
            arrObjTabFootRows.push(arrObjTabCells);
            break;
          default:
            console.log(`table parsing: unexpected table part: ${part}`);
            break;
        }
      });
    });
    opts._arrObjTabHeadRows = arrObjTabHeadRows || null;
    opts.colW = arrColW;
    getSlidesForTableRows([...arrObjTabHeadRows, ...arrObjTabBodyRows, ...arrObjTabFootRows], opts, pptx.presLayout, masterSlide).forEach((slide, idxTr) => {
      const newSlide = pptx.addSlide({ masterName: opts.masterSlideName || null });
      if (idxTr === 0) opts.y = opts.y || arrInchMargins[0];
      if (idxTr > 0) opts.y = opts.autoPageSlideStartY || opts.newSlideStartY || arrInchMargins[0];
      if (opts.verbose) console.log(`| opts.autoPageSlideStartY: ${opts.autoPageSlideStartY} / arrInchMargins[0]: ${arrInchMargins[0]} => opts.y = ${opts.y}`);
      newSlide.addTable(slide.rows, { x: opts.x || arrInchMargins[3], y: opts.y, w: Number(emuSlideTabW) / EMU, colW: arrColW, autoPage: false });
      if (opts.addImage) {
        opts.addImage.options = opts.addImage.options || {};
        if (!opts.addImage.image || !opts.addImage.image.path && !opts.addImage.image.data) {
          console.warn("Warning: tableToSlides.addImage requires either `path` or `data`");
        } else {
          newSlide.addImage({
            path: opts.addImage.image.path,
            data: opts.addImage.image.data,
            x: opts.addImage.options.x,
            y: opts.addImage.options.y,
            w: opts.addImage.options.w,
            h: opts.addImage.options.h
          });
        }
      }
      if (opts.addShape) newSlide.addShape(opts.addShape.shapeName, opts.addShape.options || {});
      if (opts.addTable) newSlide.addTable(opts.addTable.rows, opts.addTable.options || {});
      if (opts.addText) newSlide.addText(opts.addText.text, opts.addText.options || {});
    });
  }

  // src/gen-objects.ts
  function createSlideMaster(props, target) {
    if (props.objects && Array.isArray(props.objects) && props.objects.length > 0) {
      props.objects.forEach((object, idx) => {
        const key = Object.keys(object)[0];
        const tgt = target;
        const obj = object;
        if (MASTER_OBJECTS[key] && key === "chart") addChartDefinition(tgt, obj.chart.type, obj.chart.data, obj.chart.opts);
        else if (MASTER_OBJECTS[key] && key === "image") addImageDefinition(tgt, obj.image);
        else if (MASTER_OBJECTS[key] && key === "line") addShapeDefinition(tgt, "line" /* LINE */, obj.line);
        else if (MASTER_OBJECTS[key] && key === "rect") addShapeDefinition(tgt, "rect" /* RECTANGLE */, obj.rect);
        else if (MASTER_OBJECTS[key] && key === "text") addTextDefinition(tgt, [{ text: obj.text.text }], obj.text.options, false);
        else if (MASTER_OBJECTS[key] && key === "placeholder") {
          obj.placeholder.options.placeholder = obj.placeholder.options.name;
          delete obj.placeholder.options.name;
          obj.placeholder.options._placeholderType = obj.placeholder.options.type;
          delete obj.placeholder.options.type;
          obj.placeholder.options._placeholderIdx = 100 + idx;
          addTextDefinition(tgt, [{ text: obj.placeholder.text }], obj.placeholder.options, true);
        }
      });
    }
    if (props.slideNumber && typeof props.slideNumber === "object") target._slideNumberProps = props.slideNumber;
  }
  function addChartDefinition(target, type, data, opt) {
    var _a, _b, _c;
    function correctGridLineOptions(glOpts) {
      if (!glOpts || glOpts.style === "none") return;
      if (glOpts.size !== void 0 && (isNaN(Number(glOpts.size)) || glOpts.size <= 0)) {
        console.warn("Warning: chart.gridLine.size must be greater than 0.");
        delete glOpts.size;
      }
      if (glOpts.style && !["solid", "dash", "dot"].includes(glOpts.style)) {
        console.warn("Warning: chart.gridLine.style options: `solid`, `dash`, `dot`.");
        delete glOpts.style;
      }
      if (glOpts.cap && !["flat", "square", "round"].includes(glOpts.cap)) {
        console.warn("Warning: chart.gridLine.cap options: `flat`, `square`, `round`.");
        delete glOpts.cap;
      }
    }
    target._presLayout._chartCounter = ((_a = target._presLayout._chartCounter) != null ? _a : 0) + 1;
    const chartId = target._presLayout._chartCounter;
    const resultObject = {
      _type: null,
      text: null,
      options: null,
      chartRid: null
    };
    let tmpOpt = null;
    let tmpData = [];
    if (Array.isArray(type)) {
      type.forEach((obj) => {
        tmpData = tmpData.concat(obj.data);
      });
      tmpOpt = data || opt;
    } else {
      tmpData = data;
      tmpOpt = opt;
    }
    tmpData.forEach((item, i) => {
      item._dataIndex = i;
      if (item.labels !== void 0 && !Array.isArray(item.labels[0])) {
        item.labels = [item.labels];
      }
    });
    const options = tmpOpt && typeof tmpOpt === "object" ? tmpOpt : {};
    options._type = type;
    options.x = typeof options.x !== "undefined" && options.x != null && !isNaN(Number(options.x)) ? options.x : 1;
    options.y = typeof options.y !== "undefined" && options.y != null && !isNaN(Number(options.y)) ? options.y : 1;
    options.w = options.w || "50%";
    options.h = options.h || "50%";
    options.objectName = options.objectName ? encodeXmlEntities(options.objectName) : `Chart ${((_b = target._slideObjects) != null ? _b : []).filter((obj) => obj._type === "chart" /* chart */).length}`;
    if (!["bar", "col"].includes(options.barDir || "")) options.barDir = "col";
    if (options._type === "area" /* AREA */) {
      if (!["stacked", "standard", "percentStacked"].includes(options.barGrouping || "")) options.barGrouping = "standard";
    }
    if (options._type === "bar" /* BAR */) {
      if (!["clustered", "stacked", "percentStacked"].includes(options.barGrouping || "")) options.barGrouping = "clustered";
    }
    if (options._type === "bar3D" /* BAR3D */) {
      if (!["clustered", "stacked", "standard", "percentStacked"].includes(options.barGrouping || "")) options.barGrouping = "standard";
    }
    if ((_c = options.barGrouping) == null ? void 0 : _c.includes("tacked")) {
      if (!options.barGapWidthPct) options.barGapWidthPct = 50;
    }
    if (options.dataLabelPosition) {
      if (options._type === "area" /* AREA */ || options._type === "bar3D" /* BAR3D */ || options._type === "doughnut" /* DOUGHNUT */ || options._type === "radar" /* RADAR */) {
        delete options.dataLabelPosition;
      }
      if (options._type === "pie" /* PIE */) {
        if (!["bestFit", "ctr", "inEnd", "outEnd"].includes(options.dataLabelPosition)) delete options.dataLabelPosition;
      }
      if (options._type === "bubble" /* BUBBLE */ || options._type === "bubble3D" /* BUBBLE3D */ || options._type === "line" /* LINE */ || options._type === "scatter" /* SCATTER */) {
        if (!["b", "ctr", "l", "r", "t"].includes(options.dataLabelPosition)) delete options.dataLabelPosition;
      }
      if (options._type === "bar" /* BAR */) {
        if (!["stacked", "percentStacked"].includes(options.barGrouping || "")) {
          if (!["ctr", "inBase", "inEnd"].includes(options.dataLabelPosition)) delete options.dataLabelPosition;
        }
        if (!["clustered"].includes(options.barGrouping || "")) {
          if (!["ctr", "inBase", "inEnd", "outEnd"].includes(options.dataLabelPosition)) delete options.dataLabelPosition;
        }
      }
    }
    options.dataLabelBkgrdColors = options.dataLabelBkgrdColors || !options.dataLabelBkgrdColors ? options.dataLabelBkgrdColors : false;
    if (!["b", "l", "r", "t", "tr"].includes(options.legendPos || "")) options.legendPos = "r";
    if (!["cone", "coneToMax", "box", "cylinder", "pyramid", "pyramidToMax"].includes(options.bar3DShape || "")) options.bar3DShape = "box";
    if (!["circle", "dash", "diamond", "dot", "none", "square", "triangle"].includes(options.lineDataSymbol || "")) options.lineDataSymbol = "circle";
    if (!["gap", "span"].includes(options.displayBlanksAs || "")) options.displayBlanksAs = "span";
    if (!["standard", "marker", "filled"].includes(options.radarStyle || "")) options.radarStyle = "standard";
    options.lineDataSymbolSize = options.lineDataSymbolSize && !isNaN(options.lineDataSymbolSize) ? options.lineDataSymbolSize : 6;
    options.lineDataSymbolLineSize = options.lineDataSymbolLineSize && !isNaN(options.lineDataSymbolLineSize) ? valToPts(options.lineDataSymbolLineSize) : valToPts(0.75);
    if (options.layout) {
      const layout = options.layout;
      ["x", "y", "w", "h"].forEach((key) => {
        const val = layout[key];
        if (val === void 0 || isNaN(Number(val)) || val < 0 || val > 1) {
          console.warn("Warning: chart.layout." + key + " can only be 0-1");
          delete layout[key];
        }
      });
    }
    options.catGridLine = options.catGridLine || (options._type === "scatter" /* SCATTER */ ? { color: "D9D9D9", size: 1 } : { style: "none" });
    options.valGridLine = options.valGridLine || (options._type === "scatter" /* SCATTER */ ? { color: "D9D9D9", size: 1 } : {});
    options.serGridLine = options.serGridLine || (options._type === "scatter" /* SCATTER */ ? { color: "D9D9D9", size: 1 } : { style: "none" });
    correctGridLineOptions(options.catGridLine);
    correctGridLineOptions(options.valGridLine);
    correctGridLineOptions(options.serGridLine);
    correctShadowOptions(options.shadow);
    options.showDataTable = options.showDataTable || !options.showDataTable ? options.showDataTable : false;
    options.showDataTableHorzBorder = options.showDataTableHorzBorder || !options.showDataTableHorzBorder ? options.showDataTableHorzBorder : true;
    options.showDataTableVertBorder = options.showDataTableVertBorder || !options.showDataTableVertBorder ? options.showDataTableVertBorder : true;
    options.showDataTableOutline = options.showDataTableOutline || !options.showDataTableOutline ? options.showDataTableOutline : true;
    options.showDataTableKeys = options.showDataTableKeys || !options.showDataTableKeys ? options.showDataTableKeys : true;
    options.showLabel = options.showLabel || !options.showLabel ? options.showLabel : false;
    options.showLegend = options.showLegend || !options.showLegend ? options.showLegend : false;
    options.showPercent = options.showPercent || !options.showPercent ? options.showPercent : true;
    options.showTitle = options.showTitle || !options.showTitle ? options.showTitle : false;
    options.showValue = options.showValue || !options.showValue ? options.showValue : false;
    options.showLeaderLines = options.showLeaderLines || !options.showLeaderLines ? options.showLeaderLines : false;
    options.catAxisLineShow = typeof options.catAxisLineShow !== "undefined" ? options.catAxisLineShow : true;
    options.valAxisLineShow = typeof options.valAxisLineShow !== "undefined" ? options.valAxisLineShow : true;
    options.serAxisLineShow = typeof options.serAxisLineShow !== "undefined" ? options.serAxisLineShow : true;
    options.v3DRotX = options.v3DRotX !== void 0 && !isNaN(options.v3DRotX) && options.v3DRotX >= -90 && options.v3DRotX <= 90 ? options.v3DRotX : 30;
    options.v3DRotY = options.v3DRotY !== void 0 && !isNaN(options.v3DRotY) && options.v3DRotY >= 0 && options.v3DRotY <= 360 ? options.v3DRotY : 30;
    options.v3DRAngAx = options.v3DRAngAx !== void 0 ? options.v3DRAngAx : true;
    options.v3DPerspective = options.v3DPerspective !== void 0 && !isNaN(options.v3DPerspective) && options.v3DPerspective >= 0 && options.v3DPerspective <= 240 ? options.v3DPerspective : 30;
    options.barGapWidthPct = options.barGapWidthPct !== void 0 && !isNaN(options.barGapWidthPct) && options.barGapWidthPct >= 0 && options.barGapWidthPct <= 1e3 ? options.barGapWidthPct : 150;
    options.barGapDepthPct = options.barGapDepthPct !== void 0 && !isNaN(options.barGapDepthPct) && options.barGapDepthPct >= 0 && options.barGapDepthPct <= 1e3 ? options.barGapDepthPct : 150;
    options.chartColors = Array.isArray(options.chartColors) ? options.chartColors : options._type === "pie" /* PIE */ || options._type === "doughnut" /* DOUGHNUT */ ? PIECHART_COLORS : BARCHART_COLORS;
    options.chartColorsOpacity = options.chartColorsOpacity && !isNaN(options.chartColorsOpacity) ? options.chartColorsOpacity : void 0;
    options.plotArea = options.plotArea || {};
    options.plotArea.border = options.plotArea.border && typeof options.plotArea.border === "object" ? options.plotArea.border : void 0;
    if (options.plotArea.border && (!options.plotArea.border.pt || isNaN(options.plotArea.border.pt))) options.plotArea.border.pt = DEF_CHART_BORDER.pt;
    if (options.plotArea.border && (!options.plotArea.border.color || typeof options.plotArea.border.color !== "string")) {
      options.plotArea.border.color = DEF_CHART_BORDER.color;
    }
    options.plotArea.fill = options.plotArea.fill || { color: void 0, transparency: void 0 };
    options.chartArea = options.chartArea || {};
    options.chartArea.border = options.chartArea.border && typeof options.chartArea.border === "object" ? options.chartArea.border : null;
    if (options.chartArea.border) {
      options.chartArea.border = {
        color: options.chartArea.border.color || DEF_CHART_BORDER.color,
        pt: options.chartArea.border.pt || DEF_CHART_BORDER.pt
      };
    }
    options.chartArea.roundedCorners = typeof options.chartArea.roundedCorners === "boolean" ? options.chartArea.roundedCorners : true;
    options.dataBorder = options.dataBorder && typeof options.dataBorder === "object" ? options.dataBorder : null;
    if (options.dataBorder && (!options.dataBorder.pt || isNaN(options.dataBorder.pt))) options.dataBorder.pt = 0.75;
    if (options.dataBorder && options.dataBorder.color) {
      const isHexColor = typeof options.dataBorder.color === "string" && options.dataBorder.color.length === 6 && /^[0-9A-Fa-f]{6}$/.test(options.dataBorder.color);
      const isSchemeColor = Object.values(SCHEME_COLOR_NAMES).includes(options.dataBorder.color);
      if (!isHexColor && !isSchemeColor) {
        options.dataBorder.color = "F9F9F9";
      }
    }
    if (!options.dataLabelFormatCode && options._type === "scatter" /* SCATTER */) options.dataLabelFormatCode = "General";
    if (!options.dataLabelFormatCode && (options._type === "pie" /* PIE */ || options._type === "doughnut" /* DOUGHNUT */)) {
      options.dataLabelFormatCode = options.showPercent ? "0%" : "General";
    }
    options.dataLabelFormatCode = options.dataLabelFormatCode && typeof options.dataLabelFormatCode === "string" ? options.dataLabelFormatCode : "#,##0";
    if (!options.dataLabelFormatScatter && options._type === "scatter" /* SCATTER */) options.dataLabelFormatScatter = "custom";
    options.lineSize = typeof options.lineSize === "number" ? options.lineSize : 2;
    options.valAxisMajorUnit = typeof options.valAxisMajorUnit === "number" ? options.valAxisMajorUnit : null;
    if (options._type === "area" /* AREA */ || options._type === "bar" /* BAR */ || options._type === "bar3D" /* BAR3D */ || options._type === "line" /* LINE */) {
      options.catAxisMultiLevelLabels = !!options.catAxisMultiLevelLabels;
    } else {
      delete options.catAxisMultiLevelLabels;
    }
    resultObject._type = "chart";
    resultObject.options = options;
    resultObject.chartRid = getNewRelId(target);
    target._relsChart.push({
      rId: getNewRelId(target),
      data: tmpData,
      opts: options,
      type: options._type,
      globalId: chartId,
      fileName: `chart${chartId}.xml`,
      Target: `/ppt/charts/chart${chartId}.xml`
    });
    target._slideObjects.push(resultObject);
    return resultObject;
  }
  function addImageDefinition(target, opt) {
    const newObject = {
      _type: null,
      text: null,
      options: null,
      image: null,
      imageRid: null,
      hyperlink: null
    };
    const intPosX = opt.x || 0;
    const intPosY = opt.y || 0;
    const intWidth = opt.w || 0;
    const intHeight = opt.h || 0;
    const sizing = opt.sizing || null;
    const objHyperlink = opt.hyperlink || "";
    const strImageData = opt.data || "";
    const strImagePath = opt.path || "";
    let imageRelId = getNewRelId(target);
    const objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : `Image ${target._slideObjects.filter((obj) => obj._type === "image" /* image */).length}`;
    if (!strImagePath && !strImageData) {
      console.error("ERROR: addImage() requires either 'data' or 'path' parameter!");
      return null;
    } else if (strImagePath && typeof strImagePath !== "string") {
      console.error(`ERROR: addImage() 'path' should be a string, ex: {path:'/img/sample.png'} - you sent ${String(strImagePath)}`);
      return null;
    } else if (strImageData && typeof strImageData !== "string") {
      console.error(`ERROR: addImage() 'data' should be a string, ex: {data:'image/png;base64,NMP[...]'} - you sent ${String(strImageData)}`);
      return null;
    } else if (strImageData && typeof strImageData === "string" && !strImageData.toLowerCase().includes("base64,")) {
      console.error("ERROR: Image `data` value lacks a base64 header! Ex: 'image/png;base64,NMP[...]')");
      return null;
    }
    let strImgExtn = (strImagePath.substring(strImagePath.lastIndexOf("/") + 1).split("?")[0].split(".").pop().split("#")[0] || "png").toLowerCase();
    if (strImageData && /image\/(\w+);/.exec(strImageData) && /image\/(\w+);/.exec(strImageData).length > 0) {
      strImgExtn = /image\/(\w+);/.exec(strImageData)[1];
    } else if (strImageData == null ? void 0 : strImageData.toLowerCase().includes("image/svg+xml")) {
      strImgExtn = "svg";
    }
    newObject._type = "image" /* image */;
    newObject.image = strImagePath || "preencoded.png";
    newObject.options = {
      x: intPosX || 0,
      y: intPosY || 0,
      w: intWidth || 1,
      h: intHeight || 1,
      altText: opt.altText || "",
      rounding: typeof opt.rounding === "boolean" ? opt.rounding : false,
      sizing,
      placeholder: opt.placeholder,
      rotate: opt.rotate || 0,
      flipV: opt.flipV || false,
      flipH: opt.flipH || false,
      transparency: opt.transparency || 0,
      objectName,
      shadow: correctShadowOptions(opt.shadow)
    };
    if (strImgExtn === "svg") {
      target._relsMedia.push({
        path: strImagePath || strImageData + "png",
        type: "image/png",
        extn: "png",
        data: strImageData || "",
        rId: imageRelId,
        Target: `../media/image-${target._slideNum}-${target._relsMedia.length + 1}.png`,
        isSvgPng: true,
        svgSize: { w: getSmartParseNumber(newObject.options.w, "X", target._presLayout), h: getSmartParseNumber(newObject.options.h, "Y", target._presLayout) }
      });
      newObject.imageRid = imageRelId;
      target._relsMedia.push({
        path: strImagePath || strImageData,
        type: "image/svg+xml",
        extn: strImgExtn,
        data: strImageData || "",
        rId: imageRelId + 1,
        Target: `../media/image-${target._slideNum}-${target._relsMedia.length + 1}.${strImgExtn}`
      });
      newObject.imageRid = imageRelId + 1;
    } else {
      const dupeItem = target._relsMedia.filter((item) => item.path && item.path === strImagePath && item.type === "image/" + strImgExtn && !item.isDuplicate)[0];
      target._relsMedia.push({
        path: strImagePath || "preencoded." + strImgExtn,
        type: "image/" + strImgExtn,
        extn: strImgExtn,
        data: strImageData || "",
        rId: imageRelId,
        isDuplicate: !!(dupeItem == null ? void 0 : dupeItem.Target),
        Target: (dupeItem == null ? void 0 : dupeItem.Target) ? dupeItem.Target : `../media/image-${target._slideNum}-${target._relsMedia.length + 1}.${strImgExtn}`
      });
      newObject.imageRid = imageRelId;
    }
    if (typeof objHyperlink === "object") {
      if (!objHyperlink.url && !objHyperlink.slide) throw new Error("ERROR: `hyperlink` option requires either: `url` or `slide`");
      else {
        imageRelId++;
        target._rels.push({
          type: "hyperlink" /* hyperlink */,
          data: objHyperlink.slide ? "slide" : "dummy",
          rId: imageRelId,
          Target: objHyperlink.url || objHyperlink.slide.toString()
        });
        objHyperlink._rId = imageRelId;
        newObject.hyperlink = objHyperlink;
      }
    }
    target._slideObjects.push(newObject);
  }
  function addMediaDefinition(target, opt) {
    const intPosX = opt.x || 0;
    const intPosY = opt.y || 0;
    const intSizeX = opt.w || 2;
    const intSizeY = opt.h || 2;
    const strData = opt.data || "";
    const strLink = opt.link || "";
    const strPath = opt.path || "";
    const strType = opt.type || "audio";
    let strExtn = "";
    const strCover = opt.cover || IMG_PLAYBTN;
    const objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : `Media ${target._slideObjects.filter((obj) => obj._type === "media" /* media */).length}`;
    const slideData = { _type: "media" /* media */ };
    if (!strPath && !strData && strType !== "online") {
      throw new Error("addMedia() error: either `data` or `path` are required!");
    } else if (strData && !strData.toLowerCase().includes("base64,")) {
      throw new Error("addMedia() error: `data` value lacks a base64 header! Ex: 'video/mpeg;base64,NMP[...]')");
    } else if (strCover && !strCover.toLowerCase().includes("base64,")) {
      throw new Error("addMedia() error: `cover` value lacks a base64 header! Ex: 'data:image/png;base64,iV[...]')");
    }
    if (strType === "online" && !strLink) {
      throw new Error("addMedia() error: online videos require `link` value");
    }
    strExtn = opt.extn || (strData ? strData.split(";")[0].split("/")[1] : strPath.split(".").pop()) || "mp3";
    slideData.mtype = strType;
    slideData.media = strPath || "preencoded.mov";
    slideData.options = {};
    slideData.options.x = intPosX;
    slideData.options.y = intPosY;
    slideData.options.w = intSizeX;
    slideData.options.h = intSizeY;
    slideData.options.objectName = objectName;
    if (strType === "online") {
      const relId1 = getNewRelId(target);
      target._relsMedia.push({
        path: strPath || "preencoded" + strExtn,
        data: "dummy",
        type: "online",
        extn: strExtn,
        rId: relId1,
        Target: strLink
      });
      slideData.mediaRid = relId1;
      target._relsMedia.push({
        path: "preencoded.png",
        data: strCover,
        type: "image/png",
        extn: "png",
        rId: getNewRelId(target),
        Target: `../media/image-${target._slideNum}-${target._relsMedia.length + 1}.png`
      });
    } else {
      const dupeItem = target._relsMedia.filter((item) => item.path && item.path === strPath && item.type === strType + "/" + strExtn && !item.isDuplicate)[0];
      const relId1 = getNewRelId(target);
      target._relsMedia.push({
        path: strPath || "preencoded" + strExtn,
        type: strType + "/" + strExtn,
        extn: strExtn,
        data: strData || "",
        rId: relId1,
        isDuplicate: !!(dupeItem == null ? void 0 : dupeItem.Target),
        Target: (dupeItem == null ? void 0 : dupeItem.Target) ? dupeItem.Target : `../media/media-${target._slideNum}-${target._relsMedia.length + 1}.${strExtn}`
      });
      slideData.mediaRid = relId1;
      target._relsMedia.push({
        path: strPath || "preencoded" + strExtn,
        type: strType + "/" + strExtn,
        extn: strExtn,
        data: strData || "",
        rId: getNewRelId(target),
        isDuplicate: !!(dupeItem == null ? void 0 : dupeItem.Target),
        Target: (dupeItem == null ? void 0 : dupeItem.Target) ? dupeItem.Target : `../media/media-${target._slideNum}-${target._relsMedia.length + 0}.${strExtn}`
      });
      target._relsMedia.push({
        path: "preencoded.png",
        type: "image/png",
        extn: "png",
        data: strCover,
        rId: getNewRelId(target),
        Target: `../media/image-${target._slideNum}-${target._relsMedia.length + 1}.png`
      });
    }
    target._slideObjects.push(slideData);
  }
  function addNotesDefinition(target, notes) {
    target._slideObjects.push({
      _type: "notes" /* notes */,
      text: [{ text: notes }]
    });
  }
  function addShapeDefinition(target, shapeName, opts) {
    const options = typeof opts === "object" ? opts : {};
    options.line = options.line || { type: "none" };
    const newObject = {
      _type: "text" /* text */,
      shape: shapeName || "rect" /* RECTANGLE */,
      options,
      text: null
    };
    if (!shapeName) throw new Error("Missing/Invalid shape parameter! Example: `addShape(pptxgen.shapes.LINE, {x:1, y:1, w:1, h:1});`");
    const newLineOpts = {
      type: options.line.type || "solid",
      color: options.line.color || DEF_SHAPE_LINE_COLOR,
      transparency: options.line.transparency || 0,
      width: options.line.width || 1,
      dashType: options.line.dashType || "solid",
      beginArrowType: options.line.beginArrowType || null,
      endArrowType: options.line.endArrowType || null
    };
    if (typeof options.line === "object" && options.line.type !== "none") options.line = newLineOpts;
    options.x = options.x || (options.x === 0 ? 0 : 1);
    options.y = options.y || (options.y === 0 ? 0 : 1);
    options.w = options.w || (options.w === 0 ? 0 : 1);
    options.h = options.h || (options.h === 0 ? 0 : 1);
    options.objectName = options.objectName ? encodeXmlEntities(options.objectName) : `Shape ${target._slideObjects.filter((obj) => obj._type === "text" /* text */).length}`;
    if (typeof options.line === "string") {
      const tmpOpts = newLineOpts;
      tmpOpts.color = String(options.line);
      options.line = tmpOpts;
    }
    createHyperlinkRels(target, newObject);
    target._slideObjects.push(newObject);
  }
  function addTableDefinition(target, tableRows, options, slideLayout, presLayout, addSlide, getSlide) {
    const slides = [target];
    const opt = options && typeof options === "object" ? options : {};
    opt.objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : `Table ${target._slideObjects.filter((obj) => obj._type === "table" /* table */).length}`;
    {
      if (tableRows === null || tableRows.length === 0 || !Array.isArray(tableRows)) {
        throw new Error("addTable: Array expected! EX: 'slide.addTable( [rows], {options} );' (https://gitbrent.github.io/PptxGenJS/docs/api-tables.html)");
      }
      if (!tableRows[0] || !Array.isArray(tableRows[0])) {
        throw new Error(
          "addTable: 'rows' should be an array of cells! EX: 'slide.addTable( [ ['A'], ['B'], {text:'C',options:{align:'center'}} ] );' (https://gitbrent.github.io/PptxGenJS/docs/api-tables.html)"
        );
      }
    }
    const arrRows = [];
    tableRows.forEach((row) => {
      const newRow = [];
      if (Array.isArray(row)) {
        row.forEach((cell) => {
          const newCell = {
            _type: "tablecell" /* tablecell */,
            text: "",
            options: typeof cell === "object" && cell.options ? cell.options : {}
          };
          if (typeof cell === "string" || typeof cell === "number") newCell.text = cell.toString();
          else if (cell.text) {
            if (typeof cell.text === "string" || typeof cell.text === "number") newCell.text = cell.text.toString();
            else if (cell.text) newCell.text = cell.text;
            if (cell.options && typeof cell.options === "object") newCell.options = cell.options;
          }
          newCell.options.border = newCell.options.border || opt.border || [{ type: "none" }, { type: "none" }, { type: "none" }, { type: "none" }];
          const cellBorder = newCell.options.border;
          if (!Array.isArray(cellBorder) && typeof cellBorder === "object") newCell.options.border = [cellBorder, cellBorder, cellBorder, cellBorder];
          if (!newCell.options.border[0]) newCell.options.border[0] = { type: "none" };
          if (!newCell.options.border[1]) newCell.options.border[1] = { type: "none" };
          if (!newCell.options.border[2]) newCell.options.border[2] = { type: "none" };
          if (!newCell.options.border[3]) newCell.options.border[3] = { type: "none" };
          const arrSides = [0, 1, 2, 3];
          arrSides.forEach((idx) => {
            newCell.options.border[idx] = {
              type: newCell.options.border[idx].type || DEF_CELL_BORDER.type,
              color: newCell.options.border[idx].color || DEF_CELL_BORDER.color,
              pt: typeof newCell.options.border[idx].pt === "number" ? newCell.options.border[idx].pt : DEF_CELL_BORDER.pt
            };
          });
          newRow.push(newCell);
        });
      } else {
        console.log("addTable: tableRows has a bad row. A row should be an array of cells. You provided:");
        console.log(row);
      }
      arrRows.push(newRow);
    });
    opt.x = getSmartParseNumber(opt.x || (opt.x === 0 ? 0 : EMU / 2), "X", presLayout);
    opt.y = getSmartParseNumber(opt.y || (opt.y === 0 ? 0 : EMU / 2), "Y", presLayout);
    if (opt.h) opt.h = getSmartParseNumber(opt.h, "Y", presLayout);
    opt.fontSize = opt.fontSize || DEF_FONT_SIZE;
    opt.margin = opt.margin === 0 || opt.margin ? opt.margin : DEF_CELL_MARGIN_IN;
    if (typeof opt.margin === "number") opt.margin = [Number(opt.margin), Number(opt.margin), Number(opt.margin), Number(opt.margin)];
    if (JSON.stringify({ arrRows }).indexOf("hyperlink") === -1) {
      if (!opt.color) opt.color = opt.color || DEF_FONT_COLOR;
    }
    if (typeof opt.border === "string") {
      console.warn("addTable `border` option must be an object. Ex: `{border: {type:'none'}}`");
      opt.border = null;
    } else if (Array.isArray(opt.border)) {
      [0, 1, 2, 3].forEach((idx) => {
        opt.border[idx] = opt.border[idx] ? { type: opt.border[idx].type || DEF_CELL_BORDER.type, color: opt.border[idx].color || DEF_CELL_BORDER.color, pt: opt.border[idx].pt || DEF_CELL_BORDER.pt } : { type: "none" };
      });
    }
    opt.autoPage = typeof opt.autoPage === "boolean" ? opt.autoPage : false;
    opt.autoPageRepeatHeader = typeof opt.autoPageRepeatHeader === "boolean" ? opt.autoPageRepeatHeader : false;
    opt.autoPageHeaderRows = typeof opt.autoPageHeaderRows !== "undefined" && !isNaN(Number(opt.autoPageHeaderRows)) ? Number(opt.autoPageHeaderRows) : 1;
    opt.autoPageLineWeight = typeof opt.autoPageLineWeight !== "undefined" && !isNaN(Number(opt.autoPageLineWeight)) ? Number(opt.autoPageLineWeight) : 0;
    if (opt.autoPageLineWeight) {
      if (opt.autoPageLineWeight > 1) opt.autoPageLineWeight = 1;
      else if (opt.autoPageLineWeight < -1) opt.autoPageLineWeight = -1;
    }
    let arrTableMargin = DEF_SLIDE_MARGIN_IN;
    if (slideLayout && typeof slideLayout._margin !== "undefined") {
      if (Array.isArray(slideLayout._margin)) arrTableMargin = slideLayout._margin;
      else if (!isNaN(Number(slideLayout._margin))) {
        arrTableMargin = [Number(slideLayout._margin), Number(slideLayout._margin), Number(slideLayout._margin), Number(slideLayout._margin)];
      }
    }
    if (opt.colW) {
      const firstRowColCnt = arrRows[0].reduce((totalLen, c) => {
        var _a;
        if (((_a = c == null ? void 0 : c.options) == null ? void 0 : _a.colspan) && typeof c.options.colspan === "number") {
          totalLen += c.options.colspan;
        } else {
          totalLen += 1;
        }
        return totalLen;
      }, 0);
      if (typeof opt.colW === "string" || typeof opt.colW === "number") {
        opt.w = Math.floor(Number(opt.colW) * firstRowColCnt);
        opt.colW = null;
      } else if (opt.colW && Array.isArray(opt.colW) && opt.colW.length === 1 && firstRowColCnt > 1) {
        opt.w = Math.floor(Number(opt.colW) * firstRowColCnt);
        opt.colW = null;
      } else if (opt.colW && Array.isArray(opt.colW) && opt.colW.length !== firstRowColCnt) {
        console.warn("addTable: mismatch: (colW.length != data.length) Therefore, defaulting to evenly distributed col widths.");
        opt.colW = null;
      }
    } else if (opt.w) {
      opt.w = getSmartParseNumber(opt.w, "X", presLayout);
    } else {
      opt.w = Math.floor(presLayout._sizeW / EMU - arrTableMargin[1] - arrTableMargin[3]);
    }
    if (opt.x && opt.x < 20) opt.x = inch2Emu(opt.x);
    if (opt.y && opt.y < 20) opt.y = inch2Emu(opt.y);
    if (opt.w && typeof opt.w === "number" && opt.w < 20) opt.w = inch2Emu(opt.w);
    if (opt.h && typeof opt.h === "number" && opt.h < 20) opt.h = inch2Emu(opt.h);
    arrRows.forEach((row) => {
      row.forEach((cell, idy) => {
        if (typeof cell === "number" || typeof cell === "string") {
          row[idy] = { _type: "tablecell" /* tablecell */, text: String(row[idy]), options: opt };
        } else if (typeof cell === "object") {
          if (typeof cell.text === "number") row[idy].text = row[idy].text.toString();
          else if (typeof cell.text === "undefined" || cell.text === null) row[idy].text = "";
          row[idy].options = cell.options || {};
          row[idy]._type = "tablecell" /* tablecell */;
        }
      });
    });
    const newAutoPagedSlides = [];
    if (opt && !opt.autoPage) {
      createHyperlinkRels(target, arrRows);
      target._slideObjects.push({
        _type: "table" /* table */,
        arrTabRows: arrRows,
        options: Object.assign({}, opt)
      });
    } else {
      if (opt.autoPageRepeatHeader) opt._arrObjTabHeadRows = arrRows.filter((_row, idx) => idx < opt.autoPageHeaderRows);
      getSlidesForTableRows(arrRows, opt, presLayout, slideLayout).forEach((slide, idx) => {
        if (!getSlide(target._slideNum + idx)) slides.push(addSlide({ masterName: (slideLayout == null ? void 0 : slideLayout._name) || null }));
        if (idx > 0) opt.y = inch2Emu(opt.autoPageSlideStartY || opt.newSlideStartY || arrTableMargin[0]);
        {
          const newSlide = getSlide(target._slideNum + idx);
          opt.autoPage = false;
          createHyperlinkRels(newSlide, slide.rows);
          newSlide.addTable(slide.rows, Object.assign({}, opt));
          if (idx > 0) newAutoPagedSlides.push(newSlide);
        }
      });
    }
    return newAutoPagedSlides;
  }
  function addTextDefinition(target, text, opts, isPlaceholder) {
    const newObject = {
      _type: isPlaceholder ? "placeholder" /* placeholder */ : "text" /* text */,
      shape: (opts == null ? void 0 : opts.shape) || "rect" /* RECTANGLE */,
      text: !text || text.length === 0 ? [{ text: "", options: null }] : text,
      options: opts || {}
    };
    function cleanOpts(itemOpts) {
      {
        if (!itemOpts.placeholder) {
          itemOpts.color = itemOpts.color || newObject.options.color || target.color || DEF_FONT_COLOR;
        }
        if (itemOpts.placeholder || isPlaceholder) {
          itemOpts.bullet = itemOpts.bullet || false;
        }
        if (itemOpts.placeholder && target._slideLayout && target._slideLayout._slideObjects) {
          const placeHold = target._slideLayout._slideObjects.filter(
            (item) => item._type === "placeholder" && item.options && item.options.placeholder && item.options.placeholder === itemOpts.placeholder
          )[0];
          if (placeHold == null ? void 0 : placeHold.options) itemOpts = __spreadValues(__spreadValues({}, itemOpts), placeHold.options);
        }
        itemOpts.objectName = itemOpts.objectName ? encodeXmlEntities(itemOpts.objectName) : `Text ${target._slideObjects.filter((obj) => obj._type === "text" /* text */).length}`;
        if (itemOpts.shape === "line" /* LINE */) {
          const newLineOpts = {
            type: itemOpts.line.type || "solid",
            color: itemOpts.line.color || DEF_SHAPE_LINE_COLOR,
            transparency: itemOpts.line.transparency || 0,
            width: itemOpts.line.width || 1,
            dashType: itemOpts.line.dashType || "solid",
            beginArrowType: itemOpts.line.beginArrowType || null,
            endArrowType: itemOpts.line.endArrowType || null
          };
          if (typeof itemOpts.line === "object") itemOpts.line = newLineOpts;
          if (typeof itemOpts.line === "string") {
            const tmpOpts = newLineOpts;
            tmpOpts.color = itemOpts.line;
            itemOpts.line = tmpOpts;
          }
        }
        itemOpts.line = itemOpts.line || {};
        itemOpts.lineSpacing = itemOpts.lineSpacing && !isNaN(itemOpts.lineSpacing) ? itemOpts.lineSpacing : null;
        itemOpts.lineSpacingMultiple = itemOpts.lineSpacingMultiple && !isNaN(itemOpts.lineSpacingMultiple) ? itemOpts.lineSpacingMultiple : null;
        itemOpts._bodyProp = itemOpts._bodyProp || {};
        itemOpts._bodyProp.anchor = !itemOpts.placeholder ? "ctr" /* ctr */ : null;
        itemOpts._bodyProp.vert = itemOpts.vert || null;
        itemOpts._bodyProp.wrap = typeof itemOpts.wrap === "boolean" ? itemOpts.wrap : true;
        if (typeof itemOpts.underline === "boolean" && itemOpts.underline === true) itemOpts.underline = { style: "sng" };
      }
      {
        if ((itemOpts.align || "").toLowerCase().indexOf("c") === 0) itemOpts._bodyProp.align = "center" /* center */;
        else if ((itemOpts.align || "").toLowerCase().indexOf("l") === 0) itemOpts._bodyProp.align = "left" /* left */;
        else if ((itemOpts.align || "").toLowerCase().indexOf("r") === 0) itemOpts._bodyProp.align = "right" /* right */;
        else if ((itemOpts.align || "").toLowerCase().indexOf("j") === 0) itemOpts._bodyProp.align = "justify" /* justify */;
        if ((itemOpts.valign || "").toLowerCase().indexOf("b") === 0) itemOpts._bodyProp.anchor = "b" /* b */;
        else if ((itemOpts.valign || "").toLowerCase().indexOf("m") === 0) itemOpts._bodyProp.anchor = "ctr" /* ctr */;
        else if ((itemOpts.valign || "").toLowerCase().indexOf("t") === 0) itemOpts._bodyProp.anchor = "t" /* t */;
      }
      correctShadowOptions(itemOpts.shadow);
      return itemOpts;
    }
    newObject.options = cleanOpts(newObject.options);
    newObject.text.forEach((item) => item.options = cleanOpts(item.options || {}));
    createHyperlinkRels(target, newObject.text || "");
    target._slideObjects.push(newObject);
  }
  function addPlaceholdersToSlideLayouts(slide) {
    (slide._slideLayout._slideObjects || []).forEach((slideLayoutObj) => {
      if (slideLayoutObj._type === "placeholder" /* placeholder */) {
        if (slide._slideObjects.filter((slideObj) => slideObj.options && slideObj.options.placeholder === slideLayoutObj.options.placeholder).length === 0) {
          addTextDefinition(slide, [{ text: "" }], slideLayoutObj.options, false);
        }
      }
    });
  }
  function addBackgroundDefinition(props, target) {
    if (props && (props.path || props.data)) {
      props.path = props.path || "preencoded.png";
      let strImgExtn = (props.path.split(".").pop() || "png").split("?")[0];
      if (strImgExtn === "jpg") strImgExtn = "jpeg";
      target._relsMedia = target._relsMedia || [];
      const intRels = target._relsMedia.length + 1;
      target._relsMedia.push({
        path: props.path,
        type: "image" /* image */,
        extn: strImgExtn,
        data: props.data || null,
        rId: intRels,
        Target: `../media/${(target._name || "").replace(/\s+/gi, "-")}-image-${target._relsMedia.length + 1}.${strImgExtn}`
      });
      target._bkgdImgRid = intRels;
    }
  }
  function createHyperlinkRels(target, text, options) {
    let textObjs = [];
    if (typeof text === "string" || typeof text === "number") return;
    else if (Array.isArray(text)) textObjs = text;
    else if (typeof text === "object") textObjs = [text];
    textObjs.forEach((text2, idx) => {
      if (options && options[idx] && options[idx].hyperlink) text2.options = __spreadValues(__spreadValues({}, text2.options), options[idx]);
      if (Array.isArray(text2)) {
        const cellOpts = [];
        text2.forEach((tablecell) => {
          if (tablecell.options && !tablecell.text.options) {
            cellOpts.push(tablecell.options);
          }
        });
        createHyperlinkRels(target, text2, cellOpts);
      } else if (Array.isArray(text2.text)) {
        createHyperlinkRels(target, text2.text, options && options[idx] ? [options[idx]] : void 0);
      } else if (text2 && typeof text2 === "object" && text2.options && text2.options.hyperlink && !text2.options.hyperlink._rId) {
        if (typeof text2.options.hyperlink !== "object") {
          console.log("ERROR: text `hyperlink` option should be an object. Ex: `hyperlink: {url:'https://github.com'}` ");
        } else if (!text2.options.hyperlink.url && !text2.options.hyperlink.slide) {
          console.log("ERROR: 'hyperlink requires either: `url` or `slide`'");
        } else {
          const relId = getNewRelId(target);
          target._rels.push({
            type: "hyperlink" /* hyperlink */,
            data: text2.options.hyperlink.slide ? "slide" : "dummy",
            rId: relId,
            Target: encodeXmlEntities(text2.options.hyperlink.url) || text2.options.hyperlink.slide.toString()
          });
          text2.options.hyperlink._rId = relId;
        }
      } else if (text2 && typeof text2 === "object" && text2.options && text2.options.hyperlink && text2.options.hyperlink._rId) {
        if (target._rels.filter((rel) => rel.rId === text2.options.hyperlink._rId).length === 0) {
          target._rels.push({
            type: "hyperlink" /* hyperlink */,
            data: text2.options.hyperlink.slide ? "slide" : "dummy",
            rId: text2.options.hyperlink._rId,
            Target: encodeXmlEntities(text2.options.hyperlink.url) || text2.options.hyperlink.slide.toString()
          });
        }
      }
    });
  }

  // src/layout/layout-engine.ts
  function normalizeGapValue(gap) {
    if (gap === void 0) return { x: 0, y: 0 };
    if (typeof gap === "number") return { x: gap, y: gap };
    return gap;
  }
  function calculateGridLayout(options, childrenCount) {
    var _a;
    const { x, y, cols } = options;
    const gap = normalizeGapValue(options.gap);
    const rows = (_a = options.rows) != null ? _a : Math.ceil(childrenCount / cols);
    let cellWidth;
    let cellHeight;
    if (options.cellWidth !== void 0) {
      cellWidth = options.cellWidth;
    } else if (options.w !== void 0) {
      cellWidth = (options.w - gap.x * (cols - 1)) / cols;
    } else {
      throw new Error("Grid layout requires either cellWidth or w to be specified");
    }
    if (options.cellHeight !== void 0) {
      cellHeight = options.cellHeight;
    } else if (options.h !== void 0) {
      cellHeight = (options.h - gap.y * (rows - 1)) / rows;
    } else {
      throw new Error("Grid layout requires either cellHeight or h to be specified");
    }
    const positions = [];
    for (let i = 0; i < childrenCount; i++) {
      const col = i % cols;
      const row = Math.floor(i / cols);
      positions.push({
        x: x + col * (cellWidth + gap.x),
        y: y + row * (cellHeight + gap.y),
        w: cellWidth,
        h: cellHeight
      });
    }
    return positions;
  }

  // src/styles/shadow-presets.ts
  var SHADOW_PRESETS = {
    none: void 0,
    /** Extra small - very subtle, barely visible */
    xs: {
      type: "outer",
      blur: 2,
      offset: 0.5,
      angle: 90,
      color: "000000",
      opacity: 0.05
    },
    /** Subtle - gentle shadow for light interfaces */
    subtle: {
      type: "outer",
      blur: 3,
      offset: 1,
      angle: 90,
      color: "000000",
      opacity: 0.08
    },
    /** Small - light shadow */
    sm: {
      type: "outer",
      blur: 3,
      offset: 1,
      angle: 45,
      color: "000000",
      opacity: 0.1
    },
    /** Medium - default shadow */
    md: {
      type: "outer",
      blur: 6,
      offset: 3,
      angle: 45,
      color: "000000",
      opacity: 0.15
    },
    /** Large - prominent shadow */
    lg: {
      type: "outer",
      blur: 10,
      offset: 5,
      angle: 45,
      color: "000000",
      opacity: 0.2
    },
    /** Extra large - dramatic shadow */
    xl: {
      type: "outer",
      blur: 15,
      offset: 8,
      angle: 45,
      color: "000000",
      opacity: 0.25
    }
  };
  function isShadowWithPreset(value) {
    return typeof value === "object" && value !== null && "preset" in value;
  }
  function resolveShadowPreset(shadowValue) {
    if (shadowValue === void 0 || shadowValue === "none") {
      return void 0;
    }
    if (typeof shadowValue === "string") {
      const preset = SHADOW_PRESETS[shadowValue];
      if (!preset) {
        console.warn(`PptxGenJS: Unknown shadow preset '${shadowValue}', using 'md'`);
        return SHADOW_PRESETS.md;
      }
      return __spreadValues({}, preset);
    }
    if (isShadowWithPreset(shadowValue)) {
      const _a = shadowValue, { preset } = _a, overrides = __objRest(_a, ["preset"]);
      const basePreset = SHADOW_PRESETS[preset];
      if (!basePreset) {
        console.warn(`PptxGenJS: Unknown shadow preset '${preset}', using 'md'`);
        return __spreadValues(__spreadValues({}, SHADOW_PRESETS.md), overrides);
      }
      return __spreadValues(__spreadValues({}, basePreset), overrides);
    }
    return shadowValue;
  }

  // src/styles/index.ts
  function normalizeFillValue(fill) {
    if (fill === void 0) return void 0;
    if (typeof fill === "string") {
      return { color: fill };
    }
    return fill;
  }

  // src/components/Card.ts
  function normalizePaddingValue(padding) {
    var _a, _b, _c, _d;
    const defaultPadding = 0.2;
    if (padding === void 0) {
      return { top: defaultPadding, right: defaultPadding, bottom: defaultPadding, left: defaultPadding };
    }
    if (typeof padding === "number") {
      return { top: padding, right: padding, bottom: padding, left: padding };
    }
    return {
      top: (_a = padding.top) != null ? _a : defaultPadding,
      right: (_b = padding.right) != null ? _b : defaultPadding,
      bottom: (_c = padding.bottom) != null ? _c : defaultPadding,
      left: (_d = padding.left) != null ? _d : defaultPadding
    };
  }
  var CARD_DEFAULTS = {
    background: "F5F5F5",
    borderRadius: 0.1,
    borderColor: "E0E0E0",
    borderWidth: 1,
    shadow: "sm",
    padding: 0.2,
    align: "left",
    // Title defaults
    titleColor: "555555",
    titleFontSize: 14,
    titleFontFace: "Arial",
    titleLineHeight: 1.4,
    // Heading defaults
    headingColor: "333333",
    headingFontSize: 16,
    headingFontFace: "Arial",
    headingBold: true,
    headingLineHeight: 1.5,
    // Body defaults
    bodyColor: "555555",
    bodyFontSize: 13,
    bodyFontFace: "Arial",
    bodyItalic: false,
    contentGap: 0.15,
    highlightColor: "E3F2FD"
    // Light blue for highlighted cards
  };
  function normalizeBorderValue(border, legacyColor, legacyWidth) {
    var _a, _b;
    if (border === false || border === "none") {
      return { color: void 0, width: 0, enabled: false };
    }
    if (typeof border === "object") {
      return {
        color: (_a = border.color) != null ? _a : CARD_DEFAULTS.borderColor,
        width: (_b = border.width) != null ? _b : CARD_DEFAULTS.borderWidth,
        enabled: true
      };
    }
    return {
      color: legacyColor != null ? legacyColor : CARD_DEFAULTS.borderColor,
      width: legacyWidth != null ? legacyWidth : CARD_DEFAULTS.borderWidth,
      enabled: true
    };
  }
  function resolveBackgroundColor(background, highlight) {
    var _a;
    if (typeof highlight === "string") {
      return { color: highlight };
    }
    if (highlight === true) {
      return { color: CARD_DEFAULTS.highlightColor };
    }
    return (_a = normalizeFillValue(background != null ? background : CARD_DEFAULTS.background)) != null ? _a : { color: CARD_DEFAULTS.background };
  }
  function resolveCardConfig(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
    const padding = normalizePaddingValue((_a = options.padding) != null ? _a : CARD_DEFAULTS.padding);
    const align = (_b = options.align) != null ? _b : CARD_DEFAULTS.align;
    const contentGap = (_c = options.contentGap) != null ? _c : CARD_DEFAULTS.contentGap;
    const titleFontSize = (_d = options.titleFontSize) != null ? _d : CARD_DEFAULTS.titleFontSize;
    const headingFontSize = (_e = options.headingFontSize) != null ? _e : CARD_DEFAULTS.headingFontSize;
    const bodyFontSize = (_f = options.bodyFontSize) != null ? _f : CARD_DEFAULTS.bodyFontSize;
    const titleLineHeight = CARD_DEFAULTS.titleLineHeight;
    const headingLineHeight = (_g = options.headingLineHeight) != null ? _g : CARD_DEFAULTS.headingLineHeight;
    const titleHeight = options.title ? titleFontSize / 72 * titleLineHeight : 0;
    const headingHeight = options.heading ? headingFontSize / 72 * headingLineHeight : 0;
    const contentX = options.x + padding.left;
    const contentY = options.y + padding.top;
    const contentW = options.w - padding.left - padding.right;
    const contentH = options.h - padding.top - padding.bottom;
    let currentY = contentY;
    const titleY = currentY;
    if (options.title) {
      currentY += titleHeight + contentGap;
    }
    const headingY = currentY;
    if (options.heading) {
      currentY += headingHeight + contentGap;
    }
    const bodyY = currentY;
    const bodyH = Math.max(0, contentH - (currentY - contentY));
    const border = normalizeBorderValue(options.border, options.borderColor, options.borderWidth);
    return {
      x: options.x,
      y: options.y,
      w: options.w,
      h: options.h,
      backgroundFill: resolveBackgroundColor(options.background, options.highlight),
      borderRadius: (_h = options.borderRadius) != null ? _h : CARD_DEFAULTS.borderRadius,
      borderColor: border.color,
      borderWidth: border.width,
      hasBorder: border.enabled,
      shadow: resolveShadowPreset((_i = options.shadow) != null ? _i : CARD_DEFAULTS.shadow),
      padding,
      align,
      // Title
      title: options.title,
      titleColor: (_j = options.titleColor) != null ? _j : CARD_DEFAULTS.titleColor,
      titleFontSize,
      titleFontFace: (_k = options.titleFontFace) != null ? _k : CARD_DEFAULTS.titleFontFace,
      titleX: contentX,
      titleY,
      titleW: contentW,
      titleH: titleHeight,
      // Heading
      heading: options.heading,
      headingColor: (_l = options.headingColor) != null ? _l : CARD_DEFAULTS.headingColor,
      headingFontSize,
      headingFontFace: (_m = options.headingFontFace) != null ? _m : CARD_DEFAULTS.headingFontFace,
      headingBold: (_n = options.headingBold) != null ? _n : CARD_DEFAULTS.headingBold,
      headingLineHeight,
      headingX: contentX,
      headingY,
      headingW: contentW,
      headingH: headingHeight,
      // Body
      body: options.body,
      bodyColor: (_o = options.bodyColor) != null ? _o : CARD_DEFAULTS.bodyColor,
      bodyFontSize,
      bodyFontFace: (_p = options.bodyFontFace) != null ? _p : CARD_DEFAULTS.bodyFontFace,
      bodyItalic: (_q = options.bodyItalic) != null ? _q : CARD_DEFAULTS.bodyItalic,
      bodyX: contentX,
      bodyY,
      bodyW: contentW,
      bodyH
    };
  }

  // src/utils/color.ts
  function parseHexColorToRgb(hex) {
    let cleanHex = hex.replace(/^#/, "");
    if (cleanHex.length === 3) {
      cleanHex = cleanHex[0] + cleanHex[0] + cleanHex[1] + cleanHex[1] + cleanHex[2] + cleanHex[2];
    }
    const r = parseInt(cleanHex.substring(0, 2), 16);
    const g = parseInt(cleanHex.substring(2, 4), 16);
    const b = parseInt(cleanHex.substring(4, 6), 16);
    return { r, g, b };
  }
  function rgbToHexColor(r, g, b) {
    const toHex = (n) => Math.round(Math.max(0, Math.min(255, n))).toString(16).padStart(2, "0");
    return (toHex(r) + toHex(g) + toHex(b)).toUpperCase();
  }
  function interpolateColor(colorFrom, colorTo, ratio) {
    const from = parseHexColorToRgb(colorFrom);
    const to = parseHexColorToRgb(colorTo);
    const r = from.r + (to.r - from.r) * ratio;
    const g = from.g + (to.g - from.g) * ratio;
    const b = from.b + (to.b - from.b) * ratio;
    return rgbToHexColor(r, g, b);
  }
  function interpolateColors(colorFrom, colorTo, steps) {
    if (steps < 2) {
      return [colorFrom];
    }
    const colors = [];
    for (let i = 0; i < steps; i++) {
      const ratio = i / (steps - 1);
      colors.push(interpolateColor(colorFrom, colorTo, ratio));
    }
    return colors;
  }
  function lightenColor(color, amount) {
    return interpolateColor(color, "FFFFFF", amount);
  }
  function darkenColor(color, amount) {
    return interpolateColor(color, "000000", amount);
  }

  // src/rich-text.ts
  function textStyle(options) {
    return (text) => ({
      __styledText: true,
      text,
      style: options
    });
  }
  function isStyledTextFragment(value) {
    return typeof value === "object" && value !== null && "__styledText" in value && value.__styledText === true;
  }
  function convertRichTextToTextProps(strings, values, defaultOptions = {}) {
    const result = [];
    const _a = defaultOptions, { x, y, w, h } = _a, styleOptions = __objRest(_a, ["x", "y", "w", "h"]);
    const defaultStyle = {};
    for (const [key, value] of Object.entries(styleOptions)) {
      if (value !== void 0) {
        defaultStyle[key] = value;
      }
    }
    const hasDefaultStyle = Object.keys(defaultStyle).length > 0;
    for (let i = 0; i < strings.length; i++) {
      const str = strings[i];
      if (str) {
        result.push({
          text: str,
          options: hasDefaultStyle ? __spreadValues({}, defaultStyle) : void 0
        });
      }
      if (i < values.length) {
        const value = values[i];
        if (isStyledTextFragment(value)) {
          result.push({
            text: value.text,
            options: __spreadValues(__spreadValues({}, defaultStyle), value.style)
          });
        } else if (typeof value === "string" && value) {
          result.push({
            text: value,
            options: hasDefaultStyle ? __spreadValues({}, defaultStyle) : void 0
          });
        }
      }
    }
    return result;
  }

  // src/slide.ts
  var Slide = class {
    constructor(params) {
      this._newAutoPagedSlides = [];
      /**
       * @type {boolean}
       */
      this._hidden = false;
      var _a;
      this.addSlide = params.addSlide;
      this.getSlide = params.getSlide;
      this._name = `Slide ${params.slideNumber}`;
      this._presLayout = params.presLayout;
      this._rId = params.slideRId;
      this._rels = [];
      this._relsChart = [];
      this._relsMedia = [];
      this._setSlideNum = params.setSlideNum;
      this._slideId = params.slideId;
      this._slideLayout = params.slideLayout;
      this._slideNum = params.slideNumber;
      this._slideObjects = [];
      this._animations = [];
      this._slideNumberProps = (_a = this._slideLayout) == null ? void 0 : _a._slideNumberProps;
    }
    set background(props) {
      this._background = props;
      if (props) addBackgroundDefinition(props, this);
    }
    get background() {
      return this._background;
    }
    set color(value) {
      this._color = value;
    }
    get color() {
      return this._color;
    }
    set hidden(value) {
      this._hidden = value;
    }
    get hidden() {
      return this._hidden;
    }
    /**
     * @type {SlideNumberProps}
     */
    set slideNumber(value) {
      this._slideNumberProps = value;
      this._setSlideNum(value);
    }
    get slideNumber() {
      return this._slideNumberProps;
    }
    /**
     * Slide transition
     * @since v4.1.0
     * @example slide.transition = { type: 'fade' }
     * @example slide.transition = { type: 'morph', durationMs: 2000 }
     * @example slide.transition = { type: 'push', direction: 'l', speed: 'slow' }
     */
    set transition(value) {
      this._transition = value;
    }
    get transition() {
      return this._transition;
    }
    get newAutoPagedSlides() {
      return this._newAutoPagedSlides;
    }
    /**
     * Add chart to Slide
     * @param {CHART_NAME|IChartMulti[]} type - chart type
     * @param {object[]} data - data object
     * @param {IChartOpts} options - chart options
     * @return {ShapeRef} reference to the added chart for animation targeting
     * @since v4.2.0 - returns ShapeRef instead of Slide
     */
    addChart(type, data, options) {
      const optionsWithType = options || {};
      optionsWithType._type = type;
      addChartDefinition(this, type, data, optionsWithType);
      return this._createShapeRef();
    }
    /**
     * Add image to Slide
     * @param {ImageProps} options - image options
     * @return {ShapeRef} reference to the added image for animation targeting
     * @since v4.2.0 - returns ShapeRef instead of Slide
     */
    addImage(options) {
      addImageDefinition(this, options);
      return this._createShapeRef();
    }
    /**
     * Add media (audio/video) to Slide
     * @param {MediaProps} options - media options
     * @return {Slide} this Slide
     */
    addMedia(options) {
      addMediaDefinition(this, options);
      return this;
    }
    /**
     * Add speaker notes to Slide
     * @docs https://gitbrent.github.io/PptxGenJS/docs/speaker-notes.html
     * @param {string} notes - notes to add to slide
     * @return {Slide} this Slide
     */
    addNotes(notes) {
      addNotesDefinition(this, notes);
      return this;
    }
    /**
     * Add shape to Slide
     * @param {SHAPE_NAME} shapeName - shape name
     * @param {ShapeProps} options - shape options
     * @return {ShapeRef} reference to the added shape for animation targeting
     * @since v4.2.0 - returns ShapeRef instead of Slide
     */
    addShape(shapeName, options) {
      addShapeDefinition(this, shapeName, options || {});
      return this._createShapeRef();
    }
    /**
     * Add table to Slide
     * @param {TableRow[]} tableRows - table rows
     * @param {TableProps} options - table options
     * @return {Slide} this Slide
     */
    addTable(tableRows, options) {
      this._newAutoPagedSlides = addTableDefinition(this, tableRows, options || {}, this._slideLayout, this._presLayout, this.addSlide, this.getSlide);
      return this;
    }
    /**
     * Add text to Slide
     * @param {string|TextProps[]} text - text string or complex object
     * @param {TextPropsOptions} options - text options
     * @return {ShapeRef} reference to the added text for animation targeting
     * @since v4.2.0 - returns ShapeRef instead of Slide
     */
    addText(text, options) {
      const textParam = typeof text === "string" || typeof text === "number" ? [{ text, options }] : text;
      addTextDefinition(this, textParam, options || {}, false);
      return this._createShapeRef();
    }
    addRichText(optionsOrStrings, ...values) {
      if (Array.isArray(optionsOrStrings) && "raw" in optionsOrStrings) {
        const strings = optionsOrStrings;
        const textProps = convertRichTextToTextProps(strings, values, {});
        addTextDefinition(this, textProps, {}, false);
        return this._createShapeRef();
      }
      const options = optionsOrStrings;
      return (strings, ...templateValues) => {
        const textProps = convertRichTextToTextProps(strings, templateValues, options);
        addTextDefinition(this, textProps, options, false);
        return this._createShapeRef();
      };
    }
    /**
     * Add animation to a shape on this slide
     * @since v4.1.0
     * @since v4.2.0 - accepts ShapeRef in addition to numeric index
     * @param {ShapeRef|number} shapeOrIndex - ShapeRef returned by addShape/addText/addImage, or numeric index (0-based)
     * @param {AnimationProps} options - animation options
     * @return {Slide} this Slide
     * @example slide.addAnimation(shape, { type: 'fade' }) // using ShapeRef (recommended)
     * @example slide.addAnimation(0, { type: 'fade' }) // using numeric index
     */
    addAnimation(shapeOrIndex, options) {
      let shapeIndex;
      if (typeof shapeOrIndex === "number") {
        shapeIndex = shapeOrIndex;
      } else if (shapeOrIndex && typeof shapeOrIndex === "object" && "_shapeIndex" in shapeOrIndex) {
        if (shapeOrIndex._slideRef !== this) {
          console.warn("PptxGenJS: addAnimation - ShapeRef belongs to a different slide");
          return this;
        }
        shapeIndex = shapeOrIndex._shapeIndex;
      } else {
        console.warn("PptxGenJS: addAnimation - invalid shapeOrIndex parameter");
        return this;
      }
      if (shapeIndex < 0 || shapeIndex >= this._slideObjects.length) {
        console.warn(`PptxGenJS: addAnimation - invalid shapeIndex ${shapeIndex}. Slide has ${this._slideObjects.length} shapes.`);
        return this;
      }
      const preset = ANIMATION_PRESETS[options.type];
      if (!preset) {
        console.warn(`PptxGenJS: addAnimation - unknown animation type '${options.type}'`);
        return this;
      }
      let presetSubtype;
      if (options.direction && ANIMATION_DIRECTIONS[options.direction]) {
        presetSubtype = ANIMATION_DIRECTIONS[options.direction];
      }
      const animation = {
        shapeIndex,
        options,
        presetId: preset.presetId,
        presetClass: preset.presetClass,
        presetSubtype
      };
      this._animations.push(animation);
      return this;
    }
    /**
     * Create a ShapeRef for the most recently added shape
     * @internal
     */
    _createShapeRef() {
      return {
        _shapeIndex: this._slideObjects.length - 1,
        _slideRef: this
      };
    }
    // ============================================================================
    // COMPOSITIONAL API - High-level components and layouts
    // ============================================================================
    /**
     * Add a title to the slide with sensible defaults.
     * Convenience method that wraps addText with common title styling.
     *
     * @since v5.0.0
     * @param text - Title text
     * @param options - Optional title configuration
     * @returns ShapeRef to the title text
     *
     * @example
     * slide.addTitle('My Presentation')
     *
     * @example // With custom color
     * slide.addTitle('My Presentation', { color: '2A9D8F' })
     *
     * @example // With gradient
     * slide.addTitle('Gradient Title', { gradient: { from: '1E88E5', to: '26A69A' } })
     */
    addTitle(text, options) {
      const titleDefaults = {
        x: 0.5,
        y: 0.4,
        w: 9,
        h: 0.7,
        fontSize: 32,
        fontFace: "Arial",
        bold: true
      };
      const config = __spreadValues(__spreadValues({}, titleDefaults), options);
      if (config.gradient) {
        return this.addGradientText(text, {
          x: config.x,
          y: config.y,
          w: config.w,
          h: config.h,
          fontSize: config.fontSize,
          fontFace: config.fontFace,
          bold: config.bold,
          gradientFrom: config.gradient.from,
          gradientTo: config.gradient.to,
          gradientMode: "word"
        });
      }
      return this.addText(text, {
        x: config.x,
        y: config.y,
        w: config.w,
        h: config.h,
        fontSize: config.fontSize,
        fontFace: config.fontFace,
        bold: config.bold,
        color: config.color
      });
    }
    /**
     * Add text with a gradient color effect.
     * Creates a visual gradient by splitting the text into segments with interpolated colors.
     *
     * @since v5.0.0
     * @param text - Text to display
     * @param options - Gradient and text options
     * @returns ShapeRef to the text
     *
     * @example
     * slide.addGradientText('Hello World', {
     *   x: 1, y: 1, w: 6, h: 0.5,
     *   gradientFrom: '1E88E5',
     *   gradientTo: '26A69A',
     *   fontSize: 24,
     *   bold: true,
     * })
     */
    addGradientText(text, options) {
      const _a = options, { gradientFrom, gradientTo, gradientMode = "word" } = _a, textOptions = __objRest(_a, ["gradientFrom", "gradientTo", "gradientMode"]);
      const segments = gradientMode === "character" ? text.split("") : text.split(/(\s+)/);
      const nonEmptySegments = segments.filter((s) => s.length > 0);
      const colors = interpolateColors(gradientFrom, gradientTo, nonEmptySegments.length);
      const textProps = nonEmptySegments.map((segment, index) => ({
        text: segment,
        options: {
          color: colors[index],
          fontSize: textOptions.fontSize,
          fontFace: textOptions.fontFace,
          bold: textOptions.bold,
          italic: textOptions.italic,
          underline: textOptions.underline
        }
      }));
      return this.addText(textProps, {
        x: textOptions.x,
        y: textOptions.y,
        w: textOptions.w,
        h: textOptions.h,
        valign: textOptions.valign,
        align: textOptions.align
      });
    }
    /**
     * Add a card component to the slide.
     * A card is a rounded rectangle with optional shadow, heading, and body text.
     *
     * @since v5.0.0
     * @param options - Card configuration
     * @returns ShapeRef to the card's background shape
     *
     * @example
     * slide.addCard({
     *   x: 0.5, y: 1.0, w: 4, h: 2,
     *   heading: '1. LEARNING',
     *   headingColor: 'C5A636',
     *   body: 'How machines acquire knowledge from data.',
     *   shadow: 'sm',
     * })
     *
     * @example // Card without border
     * slide.addCard({ ..., border: false })
     *
     * @example // Highlighted card
     * slide.addCard({ ..., highlight: true })
     * slide.addCard({ ..., highlight: 'E3F2FD' }) // Custom highlight color
     */
    addCard(options) {
      const config = resolveCardConfig(options);
      this.addShape("roundRect" /* roundRect */, {
        x: config.x,
        y: config.y,
        w: config.w,
        h: config.h,
        fill: config.backgroundFill,
        line: config.hasBorder ? { color: config.borderColor, width: config.borderWidth } : { color: "FFFFFF", width: 0 },
        // No visible border
        rectRadius: config.borderRadius,
        shadow: config.shadow
      });
      const backgroundShapeRef = this._createShapeRef();
      if (config.title) {
        this.addText(config.title, {
          x: config.titleX,
          y: config.titleY,
          w: config.titleW,
          h: config.titleH,
          fontSize: config.titleFontSize,
          fontFace: config.titleFontFace,
          color: config.titleColor,
          align: config.align
        });
      }
      if (config.heading) {
        this.addText(config.heading, {
          x: config.headingX,
          y: config.headingY,
          w: config.headingW,
          h: config.headingH,
          fontSize: config.headingFontSize,
          fontFace: config.headingFontFace,
          bold: config.headingBold,
          color: config.headingColor,
          align: config.align
        });
      }
      if (config.body) {
        this.addText(config.body, {
          x: config.bodyX,
          y: config.bodyY,
          w: config.bodyW,
          h: config.bodyH,
          fontSize: config.bodyFontSize,
          fontFace: config.bodyFontFace,
          color: config.bodyColor,
          italic: config.bodyItalic,
          align: config.align,
          valign: "top"
        });
      }
      return backgroundShapeRef;
    }
    /**
     * Add a circular badge with text inside (e.g., numbered circle).
     *
     * @since v5.0.0
     * @param options - Badge configuration
     * @returns ShapeRef to the badge
     *
     * @example
     * slide.addBadge({
     *   x: 1, y: 1, size: 0.3,
     *   text: '1',
     *   color: '29B6F6',
     * })
     */
    addBadge(options) {
      const {
        x,
        y,
        size,
        text,
        color,
        textColor = "FFFFFF",
        fontSize = Math.round(size * 72 * 0.5),
        // Auto-size based on badge size
        fontFace = "Arial",
        bold = true
      } = options;
      this.addShape("ellipse" /* ellipse */, {
        x,
        y,
        w: size,
        h: size,
        fill: { color },
        line: { color, width: 0 }
      });
      const shapeRef = this._createShapeRef();
      this.addText(text, {
        x,
        y,
        w: size,
        h: size,
        fontSize,
        fontFace,
        color: textColor,
        bold,
        align: "center",
        valign: "middle"
      });
      return shapeRef;
    }
    /**
     * Add a bullet list with optional colored badges.
     *
     * @since v5.0.0
     * @param options - Bullet list configuration
     * @returns This slide for chaining
     *
     * @example
     * slide.addBulletList({
     *   x: 0.7, y: 2.1, w: 4,
     *   items: [
     *     { badge: { text: '1', color: '29B6F6' }, text: 'First item' },
     *     { badge: { text: '2', color: 'EF5350' }, text: 'Second item' },
     *     { badge: { text: '3', color: '66BB6A' }, text: 'Third item' },
     *   ],
     * })
     */
    addBulletList(options) {
      var _a;
      const {
        x,
        y,
        w,
        items,
        itemHeight = 0.5,
        showBullets = true,
        bulletChar = "\u2022",
        color = "555555",
        fontSize = 16,
        fontFace = "Arial",
        badgeSize = 0.3,
        bulletBadgeGap = 0.1,
        badgeTextGap = 0.15
      } = options;
      const bulletX = x;
      const bulletW = showBullets ? 0.25 : 0;
      const badgeX = bulletX + bulletW + bulletBadgeGap;
      const textX = badgeX + badgeSize + badgeTextGap;
      const textW = w - (textX - x);
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const itemY = y + i * itemHeight;
        if (showBullets) {
          this.addText(bulletChar, {
            x: bulletX,
            y: itemY,
            w: bulletW,
            h: itemHeight,
            fontSize,
            color,
            fontFace,
            valign: "middle"
          });
        }
        if (item.badge) {
          const badgeY = itemY + (itemHeight - badgeSize) / 2;
          this.addBadge({
            x: badgeX,
            y: badgeY,
            size: badgeSize,
            text: item.badge.text,
            color: item.badge.color,
            textColor: item.badge.textColor,
            fontSize: Math.round(badgeSize * 72 * 0.45)
          });
        }
        this.addText(item.text, {
          x: textX,
          y: itemY,
          w: textW,
          h: itemHeight,
          fontSize,
          fontFace,
          color: (_a = item.color) != null ? _a : color,
          bold: item.bold,
          valign: "middle"
        });
      }
      return this;
    }
    /**
     * Add a two-column layout with render functions for each column.
     *
     * @since v5.0.0
     * @param options - Two-column layout configuration
     * @returns This slide for chaining
     *
     * @example
     * slide.addTwoColumn({
     *   x: 0.5, y: 1, w: 9, h: 4,
     *   gap: 0.5,
     *   left: { ratio: 0.45 },
     *   renderLeft: (bounds) => {
     *     slide.addText('Left content', { ...bounds })
     *   },
     *   renderRight: (bounds) => {
     *     slide.addCard({ ...bounds, heading: 'Right card' })
     *   },
     * })
     */
    addTwoColumn(options) {
      const {
        x,
        y,
        w,
        h,
        gap = 0.5,
        left = {},
        right = {},
        renderLeft,
        renderRight
      } = options;
      const availableWidth = w - gap;
      let leftWidth;
      if (left.w !== void 0) {
        leftWidth = left.w;
      } else if (left.ratio !== void 0) {
        leftWidth = availableWidth * left.ratio;
      } else if (right.w !== void 0) {
        leftWidth = availableWidth - right.w;
      } else if (right.ratio !== void 0) {
        leftWidth = availableWidth * (1 - right.ratio);
      } else {
        leftWidth = availableWidth / 2;
      }
      const rightWidth = availableWidth - leftWidth;
      const leftBounds = { x, y, w: leftWidth, h };
      const rightBounds = { x: x + leftWidth + gap, y, w: rightWidth, h };
      renderLeft(leftBounds);
      renderRight(rightBounds);
      return this;
    }
    /**
     * Add vertically stacked elements with automatic Y positioning.
     *
     * @since v5.0.0
     * @param options - Stack configuration (position, width, gap)
     * @param builder - Callback function that receives a builder for adding items
     * @returns This slide for chaining
     *
     * @example
     * ```typescript
     * const keyword = textStyle({ bold: true, color: '5DADE2' })
     *
     * slide.addStack({ x: 0.65, y: 1.0, w: 9, gap: 0.25 }, (add) => {
     *   add.text('The Title', { h: 0.7, fontSize: 40, bold: true, color: 'FFFFFF' })
     *   add.space(0.1) // extra spacing
     *   add.richText({ h: 0.8, fontSize: 22, color: 'FFFFFF' })`First paragraph with ${keyword('emphasis')}.`
     *   add.richText({ h: 0.8, fontSize: 22, color: '9EAAB8' })`Second paragraph.`
     * })
     * ```
     */
    addStack(options, builder) {
      const { x, y, w, gap = 0.2, defaults = {} } = options;
      let currentY = y;
      const stackBuilder = {
        get currentY() {
          return currentY;
        },
        text: (text, itemOptions) => {
          const _a = itemOptions, { h } = _a, textOptions = __objRest(_a, ["h"]);
          const mergedOptions = __spreadProps(__spreadValues(__spreadValues({}, defaults), textOptions), { x, y: currentY, w, h });
          const ref = this.addText(text, mergedOptions);
          currentY += h + gap;
          return ref;
        },
        richText: (itemOptions) => {
          const _a = itemOptions, { h } = _a, textOptions = __objRest(_a, ["h"]);
          return (strings, ...values) => {
            const mergedOptions = __spreadProps(__spreadValues(__spreadValues({}, defaults), textOptions), { x, y: currentY, w, h });
            const textProps = convertRichTextToTextProps(strings, values, mergedOptions);
            addTextDefinition(this, textProps, mergedOptions, false);
            const ref = this._createShapeRef();
            currentY += h + gap;
            return ref;
          };
        },
        space: (height) => {
          currentY += height;
        },
        card: (cardOptions) => {
          const _a = cardOptions, { h } = _a, rest = __objRest(_a, ["h"]);
          const ref = this.addCard(__spreadProps(__spreadValues({}, rest), { x, y: currentY, w, h }));
          currentY += h + gap;
          return ref;
        }
      };
      builder(stackBuilder);
      return this;
    }
    /**
     * Options for grid layout children.
     * Each child can be a CardOptions (for cards) or a render function.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    addGrid(options) {
      const _a = options, { children, render } = _a, layoutOptions = __objRest(_a, ["children", "render"]);
      const positions = calculateGridLayout(
        layoutOptions,
        children.length
      );
      for (let i = 0; i < children.length; i++) {
        render(children[i], positions[i], i);
      }
      return this;
    }
    /**
     * Convenience method to add a grid of cards.
     * Simpler than addGrid when all children are cards.
     *
     * @since v5.0.0
     * @example
     * slide.addCardGrid({
     *   x: 0.5, y: 1.0,
     *   cols: 2, gap: 0.3,
     *   cellWidth: 4, cellHeight: 1.5,
     *   cards: [
     *     { heading: '1. LEARNING', body: '...' },
     *     { heading: '2. REASONING', body: '...' },
     *   ]
     * })
     */
    addCardGrid(options) {
      const _a = options, { cards } = _a, gridOptions = __objRest(_a, ["cards"]);
      return this.addGrid(__spreadProps(__spreadValues({}, gridOptions), {
        children: cards,
        render: (cardOptions, bounds) => {
          this.addCard(__spreadProps(__spreadValues({}, cardOptions), {
            x: bounds.x,
            y: bounds.y,
            w: bounds.w,
            h: bounds.h
          }));
        }
      }));
    }
  };

  // src/gen-charts.ts
  var import_jszip = __toESM(require_lib3(), 1);
  function createExcelWorksheet(chartObject, zip) {
    return __async(this, null, function* () {
      const data = chartObject.data;
      return yield new Promise((resolve, reject) => {
        var _a, _b;
        const zipExcel = new import_jszip.default();
        const intBubbleCols = (data.length - 1) * 2 + 1;
        const IS_MULTI_CAT_AXES = ((_b = (_a = data[0]) == null ? void 0 : _a.labels) == null ? void 0 : _b.length) > 1;
        zipExcel.folder("_rels");
        zipExcel.folder("docProps");
        zipExcel.folder("xl/_rels");
        zipExcel.folder("xl/tables");
        zipExcel.folder("xl/theme");
        zipExcel.folder("xl/worksheets");
        zipExcel.folder("xl/worksheets/_rels");
        {
          zipExcel.file(
            "[Content_Types].xml",
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>  <Default Extension="xml" ContentType="application/xml"/>  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>  <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>  <Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>  <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>  <Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>  <Override PartName="/xl/tables/table1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"/>  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/></Types>\n'
          );
          zipExcel.file(
            "_rels/.rels",
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>\n'
          );
          zipExcel.file(
            "docProps/app.xml",
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Macintosh Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>\n'
          );
          zipExcel.file(
            "docProps/core.xml",
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator>PptxGenJS</dc:creator><cp:lastModifiedBy>PptxGenJS</cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">' + (/* @__PURE__ */ new Date()).toISOString() + '</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">' + (/* @__PURE__ */ new Date()).toISOString() + "</dcterms:modified></cp:coreProperties>"
          );
          zipExcel.file(
            "xl/_rels/workbook.xml.rels",
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/><Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/></Relationships>'
          );
          zipExcel.file(
            "xl/styles.xml",
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><numFmts count="1"><numFmt numFmtId="0" formatCode="General"/></numFmts><fonts count="4"><font><sz val="9"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="9"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="10"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="18"/><color indexed="8"/><name val="Arial"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><dxfs count="0"/><tableStyles count="0"/><colors><indexedColors><rgbColor rgb="ff000000"/><rgbColor rgb="ffffffff"/><rgbColor rgb="ffff0000"/><rgbColor rgb="ff00ff00"/><rgbColor rgb="ff0000ff"/><rgbColor rgb="ffffff00"/><rgbColor rgb="ffff00ff"/><rgbColor rgb="ff00ffff"/><rgbColor rgb="ff000000"/><rgbColor rgb="ffffffff"/><rgbColor rgb="ff878787"/><rgbColor rgb="fff9f9f9"/></indexedColors></colors></styleSheet>\n'
          );
          zipExcel.file(
            "xl/theme/theme1.xml",
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="Yu Gothic Light"/><a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/><a:font script="Hans" typeface="DengXian Light"/><a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="Yu Gothic"/><a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/><a:font script="Hans" typeface="DengXian"/><a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>'
          );
          zipExcel.file(
            "xl/workbook.xml",
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><fileVersion appName="xl" lastEdited="7" lowestEdited="6" rupBuild="10507"/><workbookPr/><bookViews><workbookView xWindow="0" yWindow="500" windowWidth="20960" windowHeight="15960"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="0" concurrentCalc="0"/></workbook>\n'
          );
          zipExcel.file(
            "xl/worksheets/_rels/sheet1.xml.rels",
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" Target="../tables/table1.xml"/></Relationships>\n'
          );
        }
        {
          let strSharedStrings = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
          if (chartObject.opts._type === "bubble" /* BUBBLE */ || chartObject.opts._type === "bubble3D" /* BUBBLE3D */) {
            strSharedStrings += `<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="${intBubbleCols}" uniqueCount="${intBubbleCols}">`;
          } else if (chartObject.opts._type === "scatter" /* SCATTER */) {
            strSharedStrings += `<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="${data.length}" uniqueCount="${data.length}">`;
          } else if (IS_MULTI_CAT_AXES) {
            let totCount = data.length;
            data[0].labels.forEach((arrLabel) => totCount += arrLabel.filter((label) => label && label !== "").length);
            strSharedStrings += `<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="${totCount}" uniqueCount="${totCount}">`;
            strSharedStrings += "<si><t/></si>";
          } else {
            const totCount = data.length + data[0].labels.length * data[0].labels[0].length + data[0].labels.length;
            const unqCount = data.length + data[0].labels.length * data[0].labels[0].length + 1;
            strSharedStrings += `<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="${totCount}" uniqueCount="${unqCount}">`;
            strSharedStrings += '<si><t xml:space="preserve"></t></si>';
          }
          if (chartObject.opts._type === "bubble" /* BUBBLE */ || chartObject.opts._type === "bubble3D" /* BUBBLE3D */) {
            data.forEach((objData, idx) => {
              if (idx === 0) strSharedStrings += "<si><t>X-Axis</t></si>";
              else {
                strSharedStrings += `<si><t>${encodeXmlEntities(objData.name || `Y-Axis${idx}`)}</t></si>`;
                strSharedStrings += `<si><t>${encodeXmlEntities(`Size${idx}`)}</t></si>`;
              }
            });
          } else {
            data.forEach((objData) => {
              strSharedStrings += `<si><t>${encodeXmlEntities((objData.name || " ").replace("X-Axis", "X-Values"))}</t></si>`;
            });
          }
          if (chartObject.opts._type !== "bubble" /* BUBBLE */ && chartObject.opts._type !== "bubble3D" /* BUBBLE3D */ && chartObject.opts._type !== "scatter" /* SCATTER */) {
            data[0].labels.slice().reverse().forEach((labelsGroup) => {
              labelsGroup.filter((label) => label && label !== "").forEach((label) => {
                strSharedStrings += `<si><t>${encodeXmlEntities(label)}</t></si>`;
              });
            });
          }
          strSharedStrings += "</sst>\n";
          zipExcel.file("xl/sharedStrings.xml", strSharedStrings);
        }
        {
          let strTableXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
          if (chartObject.opts._type === "bubble" /* BUBBLE */ || chartObject.opts._type === "bubble3D" /* BUBBLE3D */) {
            strTableXml += `<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="A1:${getExcelColName(intBubbleCols)}${intBubbleCols}" totalsRowShown="0">`;
            strTableXml += `<tableColumns count="${intBubbleCols}">`;
            let idxColLtr = 1;
            data.forEach((obj, idx) => {
              if (idx === 0) {
                strTableXml += `<tableColumn id="${idx + 1}" name="X-Values"/>`;
              } else {
                strTableXml += `<tableColumn id="${idx + idxColLtr}" name="${obj.name}"/>`;
                idxColLtr++;
                strTableXml += `<tableColumn id="${idx + idxColLtr}" name="Size${idx}"/>`;
              }
            });
          } else if (chartObject.opts._type === "scatter" /* SCATTER */) {
            strTableXml += `<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="A1:${getExcelColName(data.length)}${data[0].values.length + 1}" totalsRowShown="0">`;
            strTableXml += `<tableColumns count="${data.length}">`;
            data.forEach((_obj, idx) => {
              strTableXml += `<tableColumn id="${idx + 1}" name="${idx === 0 ? "X-Values" : "Y-Value "}${idx}"/>`;
            });
          } else {
            strTableXml += `<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="A1:${getExcelColName(data.length + data[0].labels.length)}${data[0].labels[0].length + 1}'" totalsRowShown="0">`;
            strTableXml += `<tableColumns count="${data.length + data[0].labels.length}">`;
            data[0].labels.forEach((_labelsGroup, idx) => {
              strTableXml += `<tableColumn id="${idx + 1}" name="Column${idx + 1}"/>`;
            });
            data.forEach((obj, idx) => {
              strTableXml += `<tableColumn id="${idx + data[0].labels.length + 1}" name="${encodeXmlEntities(obj.name)}"/>`;
            });
          }
          strTableXml += "</tableColumns>";
          strTableXml += '<tableStyleInfo showFirstColumn="0" showLastColumn="0" showRowStripes="1" showColumnStripes="0"/>';
          strTableXml += "</table>";
          zipExcel.file("xl/tables/table1.xml", strTableXml);
        }
        {
          let strSheetXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
          strSheetXml += '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">';
          if (chartObject.opts._type === "bubble" /* BUBBLE */ || chartObject.opts._type === "bubble3D" /* BUBBLE3D */) {
            strSheetXml += `<dimension ref="A1:${getExcelColName(intBubbleCols)}${data[0].values.length + 1}"/>`;
          } else if (chartObject.opts._type === "scatter" /* SCATTER */) {
            strSheetXml += `<dimension ref="A1:${getExcelColName(data.length)}${data[0].values.length + 1}"/>`;
          } else {
            strSheetXml += `<dimension ref="A1:${getExcelColName(data.length + 1)}${data[0].values.length + 1}"/>`;
          }
          strSheetXml += '<sheetViews><sheetView tabSelected="1" workbookViewId="0"><selection activeCell="B1" sqref="B1"/></sheetView></sheetViews>';
          strSheetXml += '<sheetFormatPr baseColWidth="10" defaultRowHeight="16"/>';
          if (chartObject.opts._type === "bubble" /* BUBBLE */ || chartObject.opts._type === "bubble3D" /* BUBBLE3D */) {
            strSheetXml += "<sheetData>";
            strSheetXml += `<row r="1" spans="1:${intBubbleCols}">`;
            strSheetXml += '<c r="A1" t="s"><v>0</v></c>';
            for (let idx = 1; idx < intBubbleCols; idx++) {
              strSheetXml += `<c r="${getExcelColName(idx + 1)}1" t="s"><v>${idx}</v></c>`;
            }
            strSheetXml += "</row>";
            data[0].values.forEach((val, idx) => {
              strSheetXml += `<row r="${idx + 2}" spans="1:${intBubbleCols}">`;
              strSheetXml += `<c r="A${idx + 2}"><v>${val}</v></c>`;
              let idxColLtr = 2;
              for (let idy = 1; idy < data.length; idy++) {
                strSheetXml += `<c r="${getExcelColName(idxColLtr)}${idx + 2}"><v>${data[idy].values[idx] || ""}</v></c>`;
                idxColLtr++;
                strSheetXml += `<c r="${getExcelColName(idxColLtr)}${idx + 2}"><v>${data[idy].sizes[idx] || ""}</v></c>`;
                idxColLtr++;
              }
              strSheetXml += "</row>";
            });
          } else if (chartObject.opts._type === "scatter" /* SCATTER */) {
            strSheetXml += "<sheetData>";
            strSheetXml += `<row r="1" spans="1:${data.length}">`;
            for (let idx = 0; idx < data.length; idx++) {
              strSheetXml += `<c r="${getExcelColName(idx + 1)}1" t="s"><v>${idx}</v></c>`;
            }
            strSheetXml += "</row>";
            data[0].values.forEach((val, idx) => {
              strSheetXml += `<row r="${idx + 2}" spans="1:${data.length}">`;
              strSheetXml += `<c r="A${idx + 2}"><v>${val}</v></c>`;
              for (let idy = 1; idy < data.length; idy++) {
                strSheetXml += `<c r="${getExcelColName(idy + 1)}${idx + 2}"><v>${data[idy].values[idx] || data[idy].values[idx] === 0 ? data[idy].values[idx] : ""}</v></c>`;
              }
              strSheetXml += "</row>";
            });
          } else {
            strSheetXml += "<sheetData>";
            if (!IS_MULTI_CAT_AXES) {
              strSheetXml += `<row r="1" spans="1:${data.length + data[0].labels.length}">`;
              data[0].labels.forEach((_labelsGroup, idx) => {
                strSheetXml += `<c r="${getExcelColName(idx + 1)}1" t="s"><v>0</v></c>`;
              });
              for (let idx = 0; idx < data.length; idx++) {
                strSheetXml += `<c r="${getExcelColName(idx + 1 + data[0].labels.length)}1" t="s"><v>${idx + 1}</v></c>`;
              }
              strSheetXml += "</row>";
              data[0].labels[0].forEach((_cat, idx) => {
                strSheetXml += `<row r="${idx + 2}" spans="1:${data.length + data[0].labels.length}">`;
                for (let idx2 = data[0].labels.length - 1; idx2 >= 0; idx2--) {
                  strSheetXml += `<c r="${getExcelColName(data[0].labels.length - idx2)}${idx + 2}" t="s">`;
                  strSheetXml += `<v>${data.length + idx + 1}</v>`;
                  strSheetXml += "</c>";
                }
                for (let idy = 0; idy < data.length; idy++) {
                  strSheetXml += `<c r="${getExcelColName(data[0].labels.length + idy + 1)}${idx + 2}"><v>${data[idy].values[idx] || ""}</v></c>`;
                }
                strSheetXml += "</row>";
              });
            } else {
              strSheetXml += `<row r="1" spans="1:${data.length + data[0].labels.length}">`;
              for (let idx = 0; idx < data[0].labels.length; idx++) {
                strSheetXml += `<c r="${getExcelColName(idx + 1)}1" t="s"><v>0</v></c>`;
              }
              for (let idx = data[0].labels.length - 1; idx < data.length + data[0].labels.length - 1; idx++) {
                strSheetXml += `<c r="${getExcelColName(idx + data[0].labels.length)}1" t="s"><v>${idx}</v></c>`;
              }
              strSheetXml += "</row>";
              const TOT_SER = data.length;
              const TOT_CAT = data[0].labels[0].length;
              const TOT_LVL = data[0].labels.length;
              for (let idx = 0; idx < TOT_CAT; idx++) {
                strSheetXml += `<row r="${idx + 2}" spans="1:${TOT_SER + TOT_LVL}">`;
                let totLabels = TOT_SER;
                const revLabelGroups = data[0].labels.slice().reverse();
                revLabelGroups.forEach((labelsGroup, idy) => {
                  const colLabel = labelsGroup[idx];
                  if (colLabel) {
                    const totGrpLbls = idy === 0 ? 1 : revLabelGroups[idy - 1].filter((label) => label && label !== "").length;
                    totLabels += totGrpLbls;
                    strSheetXml += `<c r="${getExcelColName(idx + 1 + idy)}${idx + 2}" t="s"><v>${totLabels}</v></c>`;
                  }
                });
                for (let idy = 0; idy < TOT_SER; idy++) {
                  strSheetXml += `<c r="${getExcelColName(TOT_LVL + idy + 1)}${idx + 2}"><v>${data[idy].values[idx] || 0}</v></c>`;
                }
                strSheetXml += "</row>";
              }
            }
          }
          strSheetXml += "</sheetData>";
          strSheetXml += '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>';
          strSheetXml += "</worksheet>\n";
          zipExcel.file("xl/worksheets/sheet1.xml", strSheetXml);
        }
        zipExcel.generateAsync({ type: "base64" }).then((content) => {
          zip.file(`ppt/embeddings/Microsoft_Excel_Worksheet${chartObject.globalId}.xlsx`, content, { base64: true });
          zip.file(
            "ppt/charts/_rels/" + chartObject.fileName + ".rels",
            `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/package" Target="../embeddings/Microsoft_Excel_Worksheet${chartObject.globalId}.xlsx"/></Relationships>`
          );
          zip.file(`ppt/charts/${chartObject.fileName}`, makeXmlCharts(chartObject));
          resolve("");
        }).catch((strErr) => {
          reject(strErr);
        });
      });
    });
  }
  function makeXmlCharts(rel) {
    var _a, _b, _c, _d;
    let strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
    let usesSecondaryValAxis = false;
    {
      strXml += '<c:chartSpace xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">';
      strXml += '<c:date1904 val="0"/>';
      strXml += `<c:roundedCorners val="${rel.opts.chartArea.roundedCorners ? "1" : "0"}"/>`;
      strXml += "<c:chart>";
      if (rel.opts.showTitle) {
        strXml += genXmlTitle(
          {
            title: rel.opts.title || "Chart Title",
            color: rel.opts.titleColor,
            fontFace: rel.opts.titleFontFace,
            fontSize: rel.opts.titleFontSize || DEF_FONT_TITLE_SIZE,
            titleAlign: rel.opts.titleAlign,
            titleBold: rel.opts.titleBold,
            titlePos: rel.opts.titlePos,
            titleRotate: rel.opts.titleRotate
          },
          rel.opts.x,
          rel.opts.y
        );
        strXml += '<c:autoTitleDeleted val="0"/>';
      } else {
        strXml += '<c:autoTitleDeleted val="1"/>';
      }
      if (rel.opts._type === "bar3D" /* BAR3D */) {
        strXml += `<c:view3D><c:rotX val="${rel.opts.v3DRotX}"/><c:rotY val="${rel.opts.v3DRotY}"/><c:rAngAx val="${!rel.opts.v3DRAngAx ? 0 : 1}"/><c:perspective val="${rel.opts.v3DPerspective}"/></c:view3D>`;
      }
      strXml += "<c:plotArea>";
      if (rel.opts.layout) {
        strXml += "<c:layout>";
        strXml += " <c:manualLayout>";
        strXml += '  <c:layoutTarget val="inner" />';
        strXml += '  <c:xMode val="edge" />';
        strXml += '  <c:yMode val="edge" />';
        strXml += '  <c:x val="' + (rel.opts.layout.x || 0) + '" />';
        strXml += '  <c:y val="' + (rel.opts.layout.y || 0) + '" />';
        strXml += '  <c:w val="' + (rel.opts.layout.w || 1) + '" />';
        strXml += '  <c:h val="' + (rel.opts.layout.h || 1) + '" />';
        strXml += " </c:manualLayout>";
        strXml += "</c:layout>";
      } else {
        strXml += "<c:layout/>";
      }
    }
    if (Array.isArray(rel.opts._type)) {
      rel.opts._type.forEach((type) => {
        const options = __spreadValues(__spreadValues({}, rel.opts), type.options);
        const valAxisId = options.secondaryValAxis ? AXIS_ID_VALUE_SECONDARY : AXIS_ID_VALUE_PRIMARY;
        const catAxisId = options.secondaryCatAxis ? AXIS_ID_CATEGORY_SECONDARY : AXIS_ID_CATEGORY_PRIMARY;
        usesSecondaryValAxis = usesSecondaryValAxis || options.secondaryValAxis;
        strXml += makeChartType(type.type, type.data, options, valAxisId, catAxisId, true);
      });
    } else {
      strXml += makeChartType(rel.opts._type, rel.data, rel.opts, AXIS_ID_VALUE_PRIMARY, AXIS_ID_CATEGORY_PRIMARY, false);
    }
    if (rel.opts._type !== "pie" /* PIE */ && rel.opts._type !== "doughnut" /* DOUGHNUT */) {
      if (rel.opts.valAxes && rel.opts.valAxes.length > 1 && !usesSecondaryValAxis) {
        throw new Error("Secondary axis must be used by one of the multiple charts");
      }
      if (rel.opts.catAxes) {
        if (!rel.opts.valAxes || rel.opts.valAxes.length !== rel.opts.catAxes.length) {
          throw new Error("There must be the same number of value and category axes.");
        }
        strXml += makeCatAxis(__spreadValues(__spreadValues({}, rel.opts), rel.opts.catAxes[0]), AXIS_ID_CATEGORY_PRIMARY, AXIS_ID_VALUE_PRIMARY);
      } else {
        strXml += makeCatAxis(rel.opts, AXIS_ID_CATEGORY_PRIMARY, AXIS_ID_VALUE_PRIMARY);
      }
      if (rel.opts.valAxes) {
        strXml += makeValAxis(__spreadValues(__spreadValues({}, rel.opts), rel.opts.valAxes[0]), AXIS_ID_VALUE_PRIMARY);
        if (rel.opts.valAxes[1]) {
          strXml += makeValAxis(__spreadValues(__spreadValues({}, rel.opts), rel.opts.valAxes[1]), AXIS_ID_VALUE_SECONDARY);
        }
      } else {
        strXml += makeValAxis(rel.opts, AXIS_ID_VALUE_PRIMARY);
        if (rel.opts._type === "bar3D" /* BAR3D */) {
          strXml += makeSerAxis(rel.opts, AXIS_ID_SERIES_PRIMARY, AXIS_ID_VALUE_PRIMARY);
        }
      }
      if (((_a = rel.opts) == null ? void 0 : _a.catAxes) && ((_b = rel.opts) == null ? void 0 : _b.catAxes[1])) {
        strXml += makeCatAxis(__spreadValues(__spreadValues({}, rel.opts), rel.opts.catAxes[1]), AXIS_ID_CATEGORY_SECONDARY, AXIS_ID_VALUE_SECONDARY);
      }
    }
    {
      if (rel.opts.showDataTable) {
        strXml += "<c:dTable>";
        strXml += `  <c:showHorzBorder val="${!rel.opts.showDataTableHorzBorder ? 0 : 1}"/>`;
        strXml += `  <c:showVertBorder val="${!rel.opts.showDataTableVertBorder ? 0 : 1}"/>`;
        strXml += `  <c:showOutline    val="${!rel.opts.showDataTableOutline ? 0 : 1}"/>`;
        strXml += `  <c:showKeys       val="${!rel.opts.showDataTableKeys ? 0 : 1}"/>`;
        strXml += "  <c:spPr>";
        strXml += "    <a:noFill/>";
        strXml += '    <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="tx1"><a:lumMod val="15000"/><a:lumOff val="85000"/></a:schemeClr></a:solidFill><a:round/></a:ln>';
        strXml += "    <a:effectLst/>";
        strXml += "  </c:spPr>";
        strXml += "  <c:txPr>";
        strXml += '   <a:bodyPr rot="0" spcFirstLastPara="1" vertOverflow="ellipsis" vert="horz" wrap="square" anchor="ctr" anchorCtr="1"/>';
        strXml += "   <a:lstStyle/>";
        strXml += "   <a:p>";
        strXml += '     <a:pPr rtl="0">';
        strXml += `       <a:defRPr sz="${Math.round((rel.opts.dataTableFontSize || DEF_FONT_SIZE) * 100)}" b="0" i="0" u="none" strike="noStrike" kern="1200" baseline="0">`;
        strXml += '         <a:solidFill><a:schemeClr val="tx1"><a:lumMod val="65000"/><a:lumOff val="35000"/></a:schemeClr></a:solidFill>';
        strXml += '         <a:latin typeface="+mn-lt"/>';
        strXml += '         <a:ea typeface="+mn-ea"/>';
        strXml += '         <a:cs typeface="+mn-cs"/>';
        strXml += "       </a:defRPr>";
        strXml += "     </a:pPr>";
        strXml += '    <a:endParaRPr lang="en-US"/>';
        strXml += "   </a:p>";
        strXml += " </c:txPr>";
        strXml += "</c:dTable>";
      }
      strXml += "  <c:spPr>";
      strXml += ((_c = rel.opts.plotArea.fill) == null ? void 0 : _c.color) ? genXmlColorSelection(rel.opts.plotArea.fill) : "<a:noFill/>";
      strXml += rel.opts.plotArea.border ? `<a:ln w="${valToPts(rel.opts.plotArea.border.pt)}" cap="flat">${genXmlColorSelection(rel.opts.plotArea.border.color)}</a:ln>` : "<a:ln><a:noFill/></a:ln>";
      strXml += "    <a:effectLst/>";
      strXml += "  </c:spPr>";
      strXml += "</c:plotArea>";
      if (rel.opts.showLegend) {
        strXml += "<c:legend>";
        strXml += '<c:legendPos val="' + rel.opts.legendPos + '"/>';
        strXml += '<c:overlay val="0"/>';
        if (rel.opts.legendFontFace || rel.opts.legendFontSize || rel.opts.legendColor) {
          strXml += "<c:txPr>";
          strXml += "  <a:bodyPr/>";
          strXml += "  <a:lstStyle/>";
          strXml += "  <a:p>";
          strXml += "    <a:pPr>";
          strXml += rel.opts.legendFontSize ? `<a:defRPr sz="${Math.round(Number(rel.opts.legendFontSize) * 100)}">` : "<a:defRPr>";
          if (rel.opts.legendColor) strXml += genXmlColorSelection(rel.opts.legendColor);
          if (rel.opts.legendFontFace) strXml += '<a:latin typeface="' + rel.opts.legendFontFace + '"/>';
          if (rel.opts.legendFontFace) strXml += '<a:cs    typeface="' + rel.opts.legendFontFace + '"/>';
          strXml += "      </a:defRPr>";
          strXml += "    </a:pPr>";
          strXml += '    <a:endParaRPr lang="en-US"/>';
          strXml += "  </a:p>";
          strXml += "</c:txPr>";
        }
        strXml += "</c:legend>";
      }
    }
    strXml += '  <c:plotVisOnly val="1"/>';
    strXml += '  <c:dispBlanksAs val="' + rel.opts.displayBlanksAs + '"/>';
    if (rel.opts._type === "scatter" /* SCATTER */) strXml += '<c:showDLblsOverMax val="1"/>';
    strXml += "</c:chart>";
    strXml += "<c:spPr>";
    strXml += ((_d = rel.opts.chartArea.fill) == null ? void 0 : _d.color) ? genXmlColorSelection(rel.opts.chartArea.fill) : "<a:noFill/>";
    strXml += rel.opts.chartArea.border ? `<a:ln w="${valToPts(rel.opts.chartArea.border.pt)}" cap="flat">${genXmlColorSelection(rel.opts.chartArea.border.color)}</a:ln>` : "<a:ln><a:noFill/></a:ln>";
    strXml += "  <a:effectLst/>";
    strXml += "</c:spPr>";
    strXml += '<c:externalData r:id="rId1"><c:autoUpdate val="0"/></c:externalData>';
    strXml += "</c:chartSpace>";
    return strXml;
  }
  function makeChartType(chartType, data, opts, valAxisId, catAxisId, isMultiTypeChart) {
    let colorIndex = -1;
    let idxColLtr = 1;
    let optsChartData = null;
    let strXml = "";
    switch (chartType) {
      case "area" /* AREA */:
      case "bar" /* BAR */:
      case "bar3D" /* BAR3D */:
      case "line" /* LINE */:
      case "radar" /* RADAR */:
        strXml += `<c:${chartType}Chart>`;
        if (chartType === "area" /* AREA */ && opts.barGrouping === "stacked") {
          strXml += '<c:grouping val="' + opts.barGrouping + '"/>';
        }
        if (chartType === "bar" /* BAR */ || chartType === "bar3D" /* BAR3D */) {
          strXml += '<c:barDir val="' + opts.barDir + '"/>';
          strXml += '<c:grouping val="' + (opts.barGrouping || "clustered") + '"/>';
        }
        if (chartType === "radar" /* RADAR */) {
          strXml += '<c:radarStyle val="' + opts.radarStyle + '"/>';
        }
        strXml += '<c:varyColors val="0"/>';
        data.forEach((obj) => {
          var _a;
          colorIndex++;
          strXml += "<c:ser>";
          strXml += `  <c:idx val="${obj._dataIndex}"/><c:order val="${obj._dataIndex}"/>`;
          strXml += "  <c:tx>";
          strXml += "    <c:strRef>";
          strXml += "      <c:f>Sheet1!$" + getExcelColName(obj._dataIndex + obj.labels.length + 1) + "$1</c:f>";
          strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + "</c:v></c:pt></c:strCache>";
          strXml += "    </c:strRef>";
          strXml += "  </c:tx>";
          const seriesColor = opts.chartColors ? opts.chartColors[colorIndex % opts.chartColors.length] : null;
          strXml += "  <c:spPr>";
          if (seriesColor === "transparent") {
            strXml += "<a:noFill/>";
          } else if (opts.chartColorsOpacity) {
            strXml += "<a:solidFill>" + createColorElement(seriesColor, `<a:alpha val="${Math.round(opts.chartColorsOpacity * 1e3)}"/>`) + "</a:solidFill>";
          } else {
            strXml += "<a:solidFill>" + createColorElement(seriesColor) + "</a:solidFill>";
          }
          if (chartType === "line" /* LINE */ || chartType === "radar" /* RADAR */) {
            if (opts.lineSize === 0) {
              strXml += "<a:ln><a:noFill/></a:ln>";
            } else {
              strXml += `<a:ln w="${valToPts(opts.lineSize)}" cap="${createLineCap(opts.lineCap)}"><a:solidFill>${createColorElement(seriesColor)}</a:solidFill>`;
              strXml += '<a:prstDash val="' + (opts.lineDash || "solid") + '"/><a:round/></a:ln>';
            }
          } else if (opts.dataBorder) {
            strXml += `<a:ln w="${valToPts(opts.dataBorder.pt)}" cap="${createLineCap(opts.lineCap)}"><a:solidFill>${createColorElement(opts.dataBorder.color)}</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>`;
          }
          strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
          strXml += "  </c:spPr>";
          strXml += '  <c:invertIfNegative val="0"/>';
          if (chartType !== "radar" /* RADAR */) {
            strXml += "<c:dLbls>";
            strXml += `<c:numFmt formatCode="${encodeXmlEntities(opts.dataLabelFormatCode) || "General"}" sourceLinked="0"/>`;
            if (opts.dataLabelBkgrdColors) strXml += `<c:spPr><a:solidFill>${createColorElement(seriesColor)}</a:solidFill></c:spPr>`;
            strXml += "<c:txPr><a:bodyPr/><a:lstStyle/><a:p><a:pPr>";
            strXml += `<a:defRPr b="${opts.dataLabelFontBold ? 1 : 0}" i="${opts.dataLabelFontItalic ? 1 : 0}" strike="noStrike" sz="${Math.round(
              (opts.dataLabelFontSize || DEF_FONT_SIZE) * 100
            )}" u="none">`;
            strXml += `<a:solidFill>${createColorElement(opts.dataLabelColor || DEF_FONT_COLOR)}</a:solidFill>`;
            strXml += `<a:latin typeface="${opts.dataLabelFontFace || "Arial"}"/>`;
            strXml += "</a:defRPr></a:pPr></a:p></c:txPr>";
            if (opts.dataLabelPosition) strXml += `<c:dLblPos val="${opts.dataLabelPosition}"/>`;
            strXml += '<c:showLegendKey val="0"/>';
            strXml += `<c:showVal val="${opts.showValue ? "1" : "0"}"/>`;
            strXml += `<c:showCatName val="0"/><c:showSerName val="${opts.showSerName ? "1" : "0"}"/><c:showPercent val="0"/><c:showBubbleSize val="0"/>`;
            strXml += `<c:showLeaderLines val="${opts.showLeaderLines ? "1" : "0"}"/>`;
            strXml += "</c:dLbls>";
          }
          if (chartType === "line" /* LINE */ || chartType === "radar" /* RADAR */) {
            strXml += "<c:marker>";
            strXml += '  <c:symbol val="' + opts.lineDataSymbol + '"/>';
            if (opts.lineDataSymbolSize) strXml += `<c:size val="${opts.lineDataSymbolSize}"/>`;
            strXml += "  <c:spPr>";
            strXml += `    <a:solidFill>${createColorElement(opts.chartColors[obj._dataIndex + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : obj._dataIndex])}</a:solidFill>`;
            strXml += `    <a:ln w="${opts.lineDataSymbolLineSize}" cap="flat"><a:solidFill>${createColorElement(opts.lineDataSymbolLineColor || seriesColor)}</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>`;
            strXml += "    <a:effectLst/>";
            strXml += "  </c:spPr>";
            strXml += "</c:marker>";
          }
          if ((chartType === "bar" /* BAR */ || chartType === "bar3D" /* BAR3D */) && data.length === 1 && (opts.chartColors && opts.chartColors !== BARCHART_COLORS && opts.chartColors.length > 1 || ((_a = opts.invertedColors) == null ? void 0 : _a.length))) {
            obj.values.forEach((value, index) => {
              const arrColors = value < 0 ? opts.invertedColors || opts.chartColors || BARCHART_COLORS : opts.chartColors || [];
              strXml += "  <c:dPt>";
              strXml += `    <c:idx val="${index}"/>`;
              strXml += '      <c:invertIfNegative val="0"/>';
              strXml += '    <c:bubble3D val="0"/>';
              strXml += "    <c:spPr>";
              if (opts.lineSize === 0) {
                strXml += "<a:ln><a:noFill/></a:ln>";
              } else if (chartType === "bar" /* BAR */) {
                strXml += "<a:solidFill>";
                strXml += '  <a:srgbClr val="' + arrColors[index % arrColors.length] + '"/>';
                strXml += "</a:solidFill>";
              } else {
                strXml += "<a:ln>";
                strXml += "  <a:solidFill>";
                strXml += '   <a:srgbClr val="' + arrColors[index % arrColors.length] + '"/>';
                strXml += "  </a:solidFill>";
                strXml += "</a:ln>";
              }
              strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
              strXml += "    </c:spPr>";
              strXml += "  </c:dPt>";
            });
          }
          {
            strXml += "<c:cat>";
            if (opts.catLabelFormatCode) {
              strXml += "  <c:numRef>";
              strXml += `    <c:f>Sheet1!$A$2:$A$${obj.labels[0].length + 1}</c:f>`;
              strXml += "    <c:numCache>";
              strXml += "      <c:formatCode>" + (opts.catLabelFormatCode || "General") + "</c:formatCode>";
              strXml += `      <c:ptCount val="${obj.labels[0].length}"/>`;
              obj.labels[0].forEach((label, idx) => strXml += `<c:pt idx="${idx}"><c:v>${encodeXmlEntities(label)}</c:v></c:pt>`);
              strXml += "    </c:numCache>";
              strXml += "  </c:numRef>";
            } else {
              strXml += "  <c:multiLvlStrRef>";
              strXml += `    <c:f>Sheet1!$A$2:$${getExcelColName(obj.labels.length)}$${obj.labels[0].length + 1}</c:f>`;
              strXml += "    <c:multiLvlStrCache>";
              strXml += `      <c:ptCount val="${obj.labels[0].length}"/>`;
              obj.labels.forEach((labelsGroup) => {
                strXml += "<c:lvl>";
                labelsGroup.forEach((label, idx) => strXml += `<c:pt idx="${idx}"><c:v>${encodeXmlEntities(label)}</c:v></c:pt>`);
                strXml += "</c:lvl>";
              });
              strXml += "    </c:multiLvlStrCache>";
              strXml += "  </c:multiLvlStrRef>";
            }
            strXml += "</c:cat>";
          }
          {
            strXml += "<c:val>";
            strXml += "  <c:numRef>";
            strXml += `<c:f>Sheet1!$${getExcelColName(obj._dataIndex + obj.labels.length + 1)}$2:$${getExcelColName(obj._dataIndex + obj.labels.length + 1)}$${obj.labels[0].length + 1}</c:f>`;
            strXml += "    <c:numCache>";
            strXml += "      <c:formatCode>" + (opts.valLabelFormatCode || opts.dataTableFormatCode || "General") + "</c:formatCode>";
            strXml += `      <c:ptCount val="${obj.labels[0].length}"/>`;
            obj.values.forEach((value, idx) => strXml += `<c:pt idx="${idx}"><c:v>${value || value === 0 ? value : ""}</c:v></c:pt>`);
            strXml += "    </c:numCache>";
            strXml += "  </c:numRef>";
            strXml += "</c:val>";
          }
          if (chartType === "line" /* LINE */) strXml += '<c:smooth val="' + (opts.lineSmooth ? "1" : "0") + '"/>';
          strXml += "</c:ser>";
        });
        {
          strXml += "  <c:dLbls>";
          strXml += `    <c:numFmt formatCode="${encodeXmlEntities(opts.dataLabelFormatCode) || "General"}" sourceLinked="0"/>`;
          strXml += "    <c:txPr>";
          strXml += "      <a:bodyPr/>";
          strXml += "      <a:lstStyle/>";
          strXml += "      <a:p><a:pPr>";
          strXml += `        <a:defRPr b="${opts.dataLabelFontBold ? 1 : 0}" i="${opts.dataLabelFontItalic ? 1 : 0}" strike="noStrike" sz="${Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100)}" u="none">`;
          strXml += "          <a:solidFill>" + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
          strXml += '          <a:latin typeface="' + (opts.dataLabelFontFace || "Arial") + '"/>';
          strXml += "        </a:defRPr>";
          strXml += "      </a:pPr></a:p>";
          strXml += "    </c:txPr>";
          if (opts.dataLabelPosition) strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
          strXml += '    <c:showLegendKey val="0"/>';
          strXml += '    <c:showVal val="' + (opts.showValue ? "1" : "0") + '"/>';
          strXml += '    <c:showCatName val="0"/>';
          strXml += '    <c:showSerName val="' + (opts.showSerName ? "1" : "0") + '"/>';
          strXml += '    <c:showPercent val="0"/>';
          strXml += '    <c:showBubbleSize val="0"/>';
          strXml += `    <c:showLeaderLines val="${opts.showLeaderLines ? "1" : "0"}"/>`;
          strXml += "  </c:dLbls>";
        }
        if (chartType === "bar" /* BAR */) {
          strXml += `  <c:gapWidth val="${opts.barGapWidthPct}"/>`;
          strXml += `  <c:overlap val="${(opts.barGrouping || "").includes("tacked") ? 100 : opts.barOverlapPct ? opts.barOverlapPct : 0}"/>`;
        } else if (chartType === "bar3D" /* BAR3D */) {
          strXml += `  <c:gapWidth val="${opts.barGapWidthPct}"/>`;
          strXml += `  <c:gapDepth val="${opts.barGapDepthPct}"/>`;
          strXml += '  <c:shape val="' + opts.bar3DShape + '"/>';
        } else if (chartType === "line" /* LINE */) {
          strXml += '  <c:marker val="1"/>';
        }
        strXml += `<c:axId val="${catAxisId}"/><c:axId val="${valAxisId}"/><c:axId val="${AXIS_ID_SERIES_PRIMARY}"/>`;
        strXml += `</c:${chartType}Chart>`;
        break;
      case "scatter" /* SCATTER */:
        strXml += "<c:" + chartType + "Chart>";
        strXml += '<c:scatterStyle val="lineMarker"/>';
        strXml += '<c:varyColors val="0"/>';
        colorIndex = -1;
        data.filter((_obj, idx) => idx > 0).forEach((obj, idx) => {
          colorIndex++;
          strXml += "<c:ser>";
          strXml += `  <c:idx val="${idx}"/>`;
          strXml += `  <c:order val="${idx}"/>`;
          strXml += "  <c:tx>";
          strXml += "    <c:strRef>";
          strXml += `      <c:f>Sheet1!$${getExcelColName(idx + 2)}$1</c:f>`;
          strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + "</c:v></c:pt></c:strCache>";
          strXml += "    </c:strRef>";
          strXml += "  </c:tx>";
          strXml += "  <c:spPr>";
          {
            const tmpSerColor = opts.chartColors[colorIndex % opts.chartColors.length];
            if (tmpSerColor === "transparent") {
              strXml += "<a:noFill/>";
            } else if (opts.chartColorsOpacity) {
              strXml += "<a:solidFill>" + createColorElement(tmpSerColor, '<a:alpha val="' + Math.round(opts.chartColorsOpacity * 1e3).toString() + '"/>') + "</a:solidFill>";
            } else {
              strXml += "<a:solidFill>" + createColorElement(tmpSerColor) + "</a:solidFill>";
            }
            if (opts.lineSize === 0) {
              strXml += "<a:ln><a:noFill/></a:ln>";
            } else {
              strXml += `<a:ln w="${valToPts(opts.lineSize)}" cap="${createLineCap(opts.lineCap)}"><a:solidFill>${createColorElement(tmpSerColor)}</a:solidFill>`;
              strXml += `<a:prstDash val="${opts.lineDash || "solid"}"/><a:round/></a:ln>`;
            }
            strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
          }
          strXml += "  </c:spPr>";
          {
            strXml += "<c:marker>";
            strXml += '  <c:symbol val="' + opts.lineDataSymbol + '"/>';
            if (opts.lineDataSymbolSize) {
              strXml += `<c:size val="${opts.lineDataSymbolSize}"/>`;
            }
            strXml += "<c:spPr>";
            strXml += `<a:solidFill>${createColorElement(opts.chartColors[idx + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : idx])}</a:solidFill>`;
            strXml += `<a:ln w="${opts.lineDataSymbolLineSize}" cap="flat"><a:solidFill>${createColorElement(opts.lineDataSymbolLineColor || opts.chartColors[colorIndex % opts.chartColors.length])}</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>`;
            strXml += "<a:effectLst/>";
            strXml += "</c:spPr>";
            strXml += "</c:marker>";
          }
          if (opts.showLabel) {
            const chartUuid = getUuid("-xxxx-xxxx-xxxx-xxxxxxxxxxxx");
            if (obj.labels[0] && (opts.dataLabelFormatScatter === "custom" || opts.dataLabelFormatScatter === "customXY")) {
              strXml += "<c:dLbls>";
              obj.labels[0].forEach((label, idx2) => {
                if (opts.dataLabelFormatScatter === "custom" || opts.dataLabelFormatScatter === "customXY") {
                  strXml += "  <c:dLbl>";
                  strXml += `    <c:idx val="${idx2}"/>`;
                  strXml += "    <c:tx>";
                  strXml += "      <c:rich>";
                  strXml += "            <a:bodyPr>";
                  strXml += "                <a:spAutoFit/>";
                  strXml += "            </a:bodyPr>";
                  strXml += "            <a:lstStyle/>";
                  strXml += "            <a:p>";
                  strXml += "                <a:pPr>";
                  strXml += "                    <a:defRPr/>";
                  strXml += "                </a:pPr>";
                  strXml += "              <a:r>";
                  strXml += '                    <a:rPr lang="' + (opts.lang || "en-US") + '" dirty="0"/>';
                  strXml += "                    <a:t>" + encodeXmlEntities(label) + "</a:t>";
                  strXml += "              </a:r>";
                  if (opts.dataLabelFormatScatter === "customXY" && !/^ *$/.test(label)) {
                    strXml += "              <a:r>";
                    strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0" dirty="0"/>';
                    strXml += "                  <a:t> (</a:t>";
                    strXml += "              </a:r>";
                    strXml += '              <a:fld id="{' + getUuid("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx") + '}" type="XVALUE">';
                    strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0"/>';
                    strXml += "                  <a:pPr>";
                    strXml += "                      <a:defRPr/>";
                    strXml += "                  </a:pPr>";
                    strXml += "                  <a:t>[" + encodeXmlEntities(obj.name) + "</a:t>";
                    strXml += "              </a:fld>";
                    strXml += "              <a:r>";
                    strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0" dirty="0"/>';
                    strXml += "                  <a:t>, </a:t>";
                    strXml += "              </a:r>";
                    strXml += '              <a:fld id="{' + getUuid("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx") + '}" type="YVALUE">';
                    strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0"/>';
                    strXml += "                  <a:pPr>";
                    strXml += "                      <a:defRPr/>";
                    strXml += "                  </a:pPr>";
                    strXml += "                  <a:t>[" + encodeXmlEntities(obj.name) + "]</a:t>";
                    strXml += "              </a:fld>";
                    strXml += "              <a:r>";
                    strXml += '                  <a:rPr lang="' + (opts.lang || "en-US") + '" baseline="0" dirty="0"/>';
                    strXml += "                  <a:t>)</a:t>";
                    strXml += "              </a:r>";
                    strXml += '              <a:endParaRPr lang="' + (opts.lang || "en-US") + '" dirty="0"/>';
                  }
                  strXml += "            </a:p>";
                  strXml += "      </c:rich>";
                  strXml += "    </c:tx>";
                  strXml += "    <c:spPr>";
                  strXml += "        <a:noFill/>";
                  strXml += "        <a:ln>";
                  strXml += "            <a:noFill/>";
                  strXml += "        </a:ln>";
                  strXml += "        <a:effectLst/>";
                  strXml += "    </c:spPr>";
                  if (opts.dataLabelPosition) strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
                  strXml += '    <c:showLegendKey val="0"/>';
                  strXml += '    <c:showVal val="0"/>';
                  strXml += '    <c:showCatName val="0"/>';
                  strXml += '    <c:showSerName val="0"/>';
                  strXml += '    <c:showPercent val="0"/>';
                  strXml += '    <c:showBubbleSize val="0"/>';
                  strXml += '       <c:showLeaderLines val="1"/>';
                  strXml += "    <c:extLst>";
                  strXml += '      <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart"/>';
                  strXml += '      <c:ext uri="{C3380CC4-5D6E-409C-BE32-E72D297353CC}" xmlns:c16="http://schemas.microsoft.com/office/drawing/2014/chart">';
                  strXml += `            <c16:uniqueId val="{${"00000000".substring(0, 8 - (idx2 + 1).toString().length).toString()}${idx2 + 1}${chartUuid}}"/>`;
                  strXml += "      </c:ext>";
                  strXml += "        </c:extLst>";
                  strXml += "</c:dLbl>";
                }
              });
              strXml += "</c:dLbls>";
            }
            if (opts.dataLabelFormatScatter === "XY") {
              strXml += "<c:dLbls>";
              strXml += "    <c:spPr>";
              strXml += "        <a:noFill/>";
              strXml += "        <a:ln>";
              strXml += "            <a:noFill/>";
              strXml += "        </a:ln>";
              strXml += "          <a:effectLst/>";
              strXml += "    </c:spPr>";
              strXml += "    <c:txPr>";
              strXml += "        <a:bodyPr>";
              strXml += "            <a:spAutoFit/>";
              strXml += "        </a:bodyPr>";
              strXml += "        <a:lstStyle/>";
              strXml += "        <a:p>";
              strXml += "            <a:pPr>";
              strXml += "                <a:defRPr/>";
              strXml += "            </a:pPr>";
              strXml += '            <a:endParaRPr lang="en-US"/>';
              strXml += "        </a:p>";
              strXml += "    </c:txPr>";
              if (opts.dataLabelPosition) strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
              strXml += '    <c:showLegendKey val="0"/>';
              strXml += ` <c:showVal val="${opts.showLabel ? "1" : "0"}"/>`;
              strXml += ` <c:showCatName val="${opts.showLabel ? "1" : "0"}"/>`;
              strXml += ` <c:showSerName val="${opts.showSerName ? "1" : "0"}"/>`;
              strXml += '    <c:showPercent val="0"/>';
              strXml += '    <c:showBubbleSize val="0"/>';
              strXml += "    <c:extLst>";
              strXml += '        <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart">';
              strXml += '            <c15:showLeaderLines val="1"/>';
              strXml += "        </c:ext>";
              strXml += "    </c:extLst>";
              strXml += "</c:dLbls>";
            }
          }
          if (data.length === 1 && opts.chartColors !== BARCHART_COLORS) {
            obj.values.forEach((value, index) => {
              const arrColors = value < 0 ? opts.invertedColors || opts.chartColors || BARCHART_COLORS : opts.chartColors || [];
              strXml += "  <c:dPt>";
              strXml += `    <c:idx val="${index}"/>`;
              strXml += '      <c:invertIfNegative val="0"/>';
              strXml += '    <c:bubble3D val="0"/>';
              strXml += "    <c:spPr>";
              if (opts.lineSize === 0) {
                strXml += "<a:ln><a:noFill/></a:ln>";
              } else {
                strXml += "<a:solidFill>";
                strXml += ' <a:srgbClr val="' + arrColors[index % arrColors.length] + '"/>';
                strXml += "</a:solidFill>";
              }
              strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
              strXml += "    </c:spPr>";
              strXml += "  </c:dPt>";
            });
          }
          {
            strXml += "<c:xVal>";
            strXml += "  <c:numRef>";
            strXml += `    <c:f>Sheet1!$A$2:$A$${data[0].values.length + 1}</c:f>`;
            strXml += "    <c:numCache>";
            strXml += "      <c:formatCode>General</c:formatCode>";
            strXml += `      <c:ptCount val="${data[0].values.length}"/>`;
            data[0].values.forEach((value, idx2) => {
              strXml += `<c:pt idx="${idx2}"><c:v>${value || value === 0 ? value : ""}</c:v></c:pt>`;
            });
            strXml += "    </c:numCache>";
            strXml += "  </c:numRef>";
            strXml += "</c:xVal>";
            strXml += "<c:yVal>";
            strXml += "  <c:numRef>";
            strXml += `    <c:f>Sheet1!$${getExcelColName(idx + 2)}$2:$${getExcelColName(idx + 2)}$${data[0].values.length + 1}</c:f>`;
            strXml += "    <c:numCache>";
            strXml += "      <c:formatCode>General</c:formatCode>";
            strXml += `      <c:ptCount val="${data[0].values.length}"/>`;
            data[0].values.forEach((_value, idx2) => {
              strXml += `<c:pt idx="${idx2}"><c:v>${obj.values[idx2] || obj.values[idx2] === 0 ? obj.values[idx2] : ""}</c:v></c:pt>`;
            });
            strXml += "    </c:numCache>";
            strXml += "  </c:numRef>";
            strXml += "</c:yVal>";
          }
          strXml += '<c:smooth val="' + (opts.lineSmooth ? "1" : "0") + '"/>';
          strXml += "</c:ser>";
        });
        {
          strXml += "  <c:dLbls>";
          strXml += `    <c:numFmt formatCode="${encodeXmlEntities(opts.dataLabelFormatCode) || "General"}" sourceLinked="0"/>`;
          strXml += "    <c:txPr>";
          strXml += "      <a:bodyPr/>";
          strXml += "      <a:lstStyle/>";
          strXml += "      <a:p><a:pPr>";
          strXml += `        <a:defRPr b="${opts.dataLabelFontBold ? "1" : "0"}" i="${opts.dataLabelFontItalic ? "1" : "0"}" strike="noStrike" sz="${Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100)}" u="none">`;
          strXml += "          <a:solidFill>" + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
          strXml += '          <a:latin typeface="' + (opts.dataLabelFontFace || "Arial") + '"/>';
          strXml += "        </a:defRPr>";
          strXml += "      </a:pPr></a:p>";
          strXml += "    </c:txPr>";
          if (opts.dataLabelPosition) strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
          strXml += '    <c:showLegendKey val="0"/>';
          strXml += '    <c:showVal val="' + (opts.showValue ? "1" : "0") + '"/>';
          strXml += '    <c:showCatName val="0"/>';
          strXml += '    <c:showSerName val="' + (opts.showSerName ? "1" : "0") + '"/>';
          strXml += '    <c:showPercent val="0"/>';
          strXml += '    <c:showBubbleSize val="0"/>';
          strXml += "  </c:dLbls>";
        }
        strXml += `<c:axId val="${catAxisId}"/><c:axId val="${valAxisId}"/>`;
        strXml += "</c:" + chartType + "Chart>";
        break;
      case "bubble" /* BUBBLE */:
      case "bubble3D" /* BUBBLE3D */:
        strXml += "<c:bubbleChart>";
        strXml += '<c:varyColors val="0"/>';
        colorIndex = -1;
        data.filter((_obj, idx) => idx > 0).forEach((obj, idx) => {
          colorIndex++;
          strXml += "<c:ser>";
          strXml += `  <c:idx val="${idx}"/>`;
          strXml += `  <c:order val="${idx}"/>`;
          strXml += "  <c:tx>";
          strXml += "    <c:strRef>";
          strXml += "      <c:f>Sheet1!$" + getExcelColName(idxColLtr + 1) + "$1</c:f>";
          strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + "</c:v></c:pt></c:strCache>";
          strXml += "    </c:strRef>";
          strXml += "  </c:tx>";
          {
            strXml += "<c:spPr>";
            const tmpSerColor = opts.chartColors[colorIndex % opts.chartColors.length];
            if (tmpSerColor === "transparent") {
              strXml += "<a:noFill/>";
            } else if (opts.chartColorsOpacity) {
              strXml += `<a:solidFill>${createColorElement(tmpSerColor, '<a:alpha val="' + Math.round(opts.chartColorsOpacity * 1e3).toString() + '"/>')}</a:solidFill>`;
            } else {
              strXml += "<a:solidFill>" + createColorElement(tmpSerColor) + "</a:solidFill>";
            }
            if (opts.lineSize === 0) {
              strXml += "<a:ln><a:noFill/></a:ln>";
            } else if (opts.dataBorder) {
              strXml += `<a:ln w="${valToPts(opts.dataBorder.pt)}" cap="flat"><a:solidFill>${createColorElement(opts.dataBorder.color)}</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>`;
            } else {
              strXml += `<a:ln w="${valToPts(opts.lineSize)}" cap="flat"><a:solidFill>${createColorElement(tmpSerColor)}</a:solidFill>`;
              strXml += `<a:prstDash val="${opts.lineDash || "solid"}"/><a:round/></a:ln>`;
            }
            strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
            strXml += "</c:spPr>";
          }
          {
            strXml += "<c:xVal>";
            strXml += "  <c:numRef>";
            strXml += `    <c:f>Sheet1!$A$2:$A$${data[0].values.length + 1}</c:f>`;
            strXml += "    <c:numCache>";
            strXml += "      <c:formatCode>General</c:formatCode>";
            strXml += `      <c:ptCount val="${data[0].values.length}"/>`;
            data[0].values.forEach((value, idx2) => {
              strXml += `<c:pt idx="${idx2}"><c:v>${value || value === 0 ? value : ""}</c:v></c:pt>`;
            });
            strXml += "    </c:numCache>";
            strXml += "  </c:numRef>";
            strXml += "</c:xVal>";
            strXml += "<c:yVal>";
            strXml += "  <c:numRef>";
            strXml += `<c:f>Sheet1!$${getExcelColName(idxColLtr + 1)}$2:$${getExcelColName(idxColLtr + 1)}$${data[0].values.length + 1}</c:f>`;
            idxColLtr++;
            strXml += "    <c:numCache>";
            strXml += "      <c:formatCode>General</c:formatCode>";
            strXml += `      <c:ptCount val="${data[0].values.length}"/>`;
            data[0].values.forEach((_value, idx2) => {
              strXml += `<c:pt idx="${idx2}"><c:v>${obj.values[idx2] || obj.values[idx2] === 0 ? obj.values[idx2] : ""}</c:v></c:pt>`;
            });
            strXml += "    </c:numCache>";
            strXml += "  </c:numRef>";
            strXml += "</c:yVal>";
          }
          strXml += "  <c:bubbleSize>";
          strXml += "    <c:numRef>";
          strXml += `<c:f>Sheet1!$${getExcelColName(idxColLtr + 1)}$2:$${getExcelColName(idxColLtr + 1)}$${obj.sizes.length + 1}</c:f>`;
          idxColLtr++;
          strXml += "      <c:numCache>";
          strXml += "        <c:formatCode>General</c:formatCode>";
          strXml += `           <c:ptCount val="${obj.sizes.length}"/>`;
          obj.sizes.forEach((value, idx2) => {
            strXml += `<c:pt idx="${idx2}"><c:v>${value || ""}</c:v></c:pt>`;
          });
          strXml += "      </c:numCache>";
          strXml += "    </c:numRef>";
          strXml += "  </c:bubbleSize>";
          strXml += '  <c:bubble3D val="' + (chartType === "bubble3D" /* BUBBLE3D */ ? "1" : "0") + '"/>';
          strXml += "</c:ser>";
        });
        {
          strXml += "<c:dLbls>";
          strXml += `<c:numFmt formatCode="${encodeXmlEntities(opts.dataLabelFormatCode) || "General"}" sourceLinked="0"/>`;
          strXml += "<c:txPr><a:bodyPr/><a:lstStyle/><a:p><a:pPr>";
          strXml += `<a:defRPr b="${opts.dataLabelFontBold ? 1 : 0}" i="${opts.dataLabelFontItalic ? 1 : 0}" strike="noStrike" sz="${Math.round(
            Math.round(opts.dataLabelFontSize || DEF_FONT_SIZE) * 100
          )}" u="none">`;
          strXml += `<a:solidFill>${createColorElement(opts.dataLabelColor || DEF_FONT_COLOR)}</a:solidFill>`;
          strXml += `<a:latin typeface="${opts.dataLabelFontFace || "Arial"}"/>`;
          strXml += "</a:defRPr></a:pPr></a:p></c:txPr>";
          if (opts.dataLabelPosition) strXml += `<c:dLblPos val="${opts.dataLabelPosition}"/>`;
          strXml += '<c:showLegendKey val="0"/>';
          strXml += `<c:showVal val="${opts.showValue ? "1" : "0"}"/>`;
          strXml += `<c:showCatName val="0"/><c:showSerName val="${opts.showSerName ? "1" : "0"}"/><c:showPercent val="0"/><c:showBubbleSize val="0"/>`;
          strXml += "<c:extLst>";
          strXml += '  <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart">';
          strXml += '    <c15:showLeaderLines val="' + (opts.showLeaderLines ? "1" : "0") + '"/>';
          strXml += "  </c:ext>";
          strXml += "</c:extLst>";
          strXml += "</c:dLbls>";
        }
        strXml += `<c:axId val="${catAxisId}"/><c:axId val="${valAxisId}"/>`;
        strXml += "</c:bubbleChart>";
        break;
      case "doughnut" /* DOUGHNUT */:
      case "pie" /* PIE */:
        optsChartData = data[0];
        strXml += "<c:" + chartType + "Chart>";
        strXml += '  <c:varyColors val="1"/>';
        strXml += "<c:ser>";
        strXml += '  <c:idx val="0"/>';
        strXml += '  <c:order val="0"/>';
        strXml += "  <c:tx>";
        strXml += "    <c:strRef>";
        strXml += "      <c:f>Sheet1!$B$1</c:f>";
        strXml += "      <c:strCache>";
        strXml += '        <c:ptCount val="1"/>';
        strXml += '        <c:pt idx="0"><c:v>' + encodeXmlEntities(optsChartData.name) + "</c:v></c:pt>";
        strXml += "      </c:strCache>";
        strXml += "    </c:strRef>";
        strXml += "  </c:tx>";
        strXml += "  <c:spPr>";
        strXml += '    <a:solidFill><a:schemeClr val="accent1"/></a:solidFill>';
        strXml += '    <a:ln w="9525" cap="flat"><a:solidFill><a:srgbClr val="F9F9F9"/></a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>';
        if (opts.dataNoEffects) {
          strXml += "<a:effectLst/>";
        } else {
          strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
        }
        strXml += "  </c:spPr>";
        optsChartData.labels[0].forEach((_label, idx) => {
          strXml += "<c:dPt>";
          strXml += ` <c:idx val="${idx}"/>`;
          strXml += ' <c:bubble3D val="0"/>';
          strXml += " <c:spPr>";
          strXml += `<a:solidFill>${createColorElement(
            opts.chartColors[idx + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : idx]
          )}</a:solidFill>`;
          if (opts.dataBorder) {
            strXml += `<a:ln w="${valToPts(opts.dataBorder.pt)}" cap="flat"><a:solidFill>${createColorElement(
              opts.dataBorder.color
            )}</a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>`;
          }
          strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
          strXml += "  </c:spPr>";
          strXml += "</c:dPt>";
        });
        strXml += "<c:dLbls>";
        optsChartData.labels[0].forEach((_label, idx) => {
          strXml += "<c:dLbl>";
          strXml += ` <c:idx val="${idx}"/>`;
          strXml += `  <c:numFmt formatCode="${encodeXmlEntities(opts.dataLabelFormatCode) || "General"}" sourceLinked="0"/>`;
          strXml += "  <c:spPr/><c:txPr>";
          strXml += "   <a:bodyPr/><a:lstStyle/>";
          strXml += "   <a:p><a:pPr>";
          strXml += `   <a:defRPr sz="${Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100)}" b="${opts.dataLabelFontBold ? 1 : 0}" i="${opts.dataLabelFontItalic ? 1 : 0}" u="none" strike="noStrike">`;
          strXml += "    <a:solidFill>" + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
          strXml += `    <a:latin typeface="${opts.dataLabelFontFace || "Arial"}"/>`;
          strXml += "   </a:defRPr>";
          strXml += "      </a:pPr></a:p>";
          strXml += "    </c:txPr>";
          if (chartType === "pie" /* PIE */ && opts.dataLabelPosition) strXml += `<c:dLblPos val="${opts.dataLabelPosition}"/>`;
          strXml += '    <c:showLegendKey val="0"/>';
          strXml += '    <c:showVal val="' + (opts.showValue ? "1" : "0") + '"/>';
          strXml += '    <c:showCatName val="' + (opts.showLabel ? "1" : "0") + '"/>';
          strXml += '    <c:showSerName val="' + (opts.showSerName ? "1" : "0") + '"/>';
          strXml += '    <c:showPercent val="' + (opts.showPercent ? "1" : "0") + '"/>';
          strXml += '    <c:showBubbleSize val="0"/>';
          strXml += "  </c:dLbl>";
        });
        strXml += ` <c:numFmt formatCode="${encodeXmlEntities(opts.dataLabelFormatCode) || "General"}" sourceLinked="0"/>`;
        strXml += "    <c:txPr>";
        strXml += "      <a:bodyPr/>";
        strXml += "      <a:lstStyle/>";
        strXml += "      <a:p>";
        strXml += "        <a:pPr>";
        strXml += `          <a:defRPr sz="1800" b="${opts.dataLabelFontBold ? "1" : "0"}" i="${opts.dataLabelFontItalic ? "1" : "0"}" u="none" strike="noStrike">`;
        strXml += '            <a:solidFill><a:srgbClr val="000000"/></a:solidFill><a:latin typeface="Arial"/>';
        strXml += "          </a:defRPr>";
        strXml += "        </a:pPr>";
        strXml += "      </a:p>";
        strXml += "    </c:txPr>";
        strXml += chartType === "pie" /* PIE */ ? '<c:dLblPos val="ctr"/>' : "";
        strXml += '    <c:showLegendKey val="0"/>';
        strXml += '    <c:showVal val="0"/>';
        strXml += '    <c:showCatName val="1"/>';
        strXml += '    <c:showSerName val="0"/>';
        strXml += '    <c:showPercent val="1"/>';
        strXml += '    <c:showBubbleSize val="0"/>';
        strXml += ` <c:showLeaderLines val="${opts.showLeaderLines ? "1" : "0"}"/>`;
        strXml += "</c:dLbls>";
        strXml += "<c:cat>";
        strXml += "  <c:strRef>";
        strXml += `    <c:f>Sheet1!$A$2:$A$${optsChartData.labels[0].length + 1}</c:f>`;
        strXml += "    <c:strCache>";
        strXml += `         <c:ptCount val="${optsChartData.labels[0].length}"/>`;
        optsChartData.labels[0].forEach((label, idx) => {
          strXml += `<c:pt idx="${idx}"><c:v>${encodeXmlEntities(label)}</c:v></c:pt>`;
        });
        strXml += "    </c:strCache>";
        strXml += "  </c:strRef>";
        strXml += "</c:cat>";
        strXml += "  <c:val>";
        strXml += "    <c:numRef>";
        strXml += `      <c:f>Sheet1!$B$2:$B$${optsChartData.labels[0].length + 1}</c:f>`;
        strXml += "      <c:numCache>";
        strXml += `           <c:ptCount val="${optsChartData.labels[0].length}"/>`;
        optsChartData.values.forEach((value, idx) => {
          strXml += `<c:pt idx="${idx}"><c:v>${value || value === 0 ? value : ""}</c:v></c:pt>`;
        });
        strXml += "      </c:numCache>";
        strXml += "    </c:numRef>";
        strXml += "  </c:val>";
        strXml += "  </c:ser>";
        strXml += `  <c:firstSliceAng val="${opts.firstSliceAng ? Math.round(opts.firstSliceAng) : 0}"/>`;
        if (chartType === "doughnut" /* DOUGHNUT */) strXml += `<c:holeSize val="${typeof opts.holeSize === "number" ? opts.holeSize : "50"}"/>`;
        strXml += "</c:" + chartType + "Chart>";
        break;
      default:
        strXml += "";
        break;
    }
    return strXml;
  }
  function makeCatAxis(opts, axisId, valAxisId) {
    let strXml = "";
    if (opts._type === "scatter" /* SCATTER */ || opts._type === "bubble" /* BUBBLE */ || opts._type === "bubble3D" /* BUBBLE3D */) {
      strXml += "<c:valAx>";
    } else {
      strXml += "<c:" + (opts.catLabelFormatCode ? "dateAx" : "catAx") + ">";
    }
    strXml += '  <c:axId val="' + axisId + '"/>';
    strXml += "  <c:scaling>";
    strXml += '<c:orientation val="' + (opts.catAxisOrientation || (opts.barDir === "col" ? "minMax" : "minMax")) + '"/>';
    if (opts.catAxisMaxVal || opts.catAxisMaxVal === 0) strXml += `<c:max val="${opts.catAxisMaxVal}"/>`;
    if (opts.catAxisMinVal || opts.catAxisMinVal === 0) strXml += `<c:min val="${opts.catAxisMinVal}"/>`;
    strXml += "</c:scaling>";
    strXml += '  <c:delete val="' + (opts.catAxisHidden ? "1" : "0") + '"/>';
    strXml += '  <c:axPos val="' + (opts.barDir === "col" ? "b" : "l") + '"/>';
    strXml += opts.catGridLine.style !== "none" ? createGridLineElement(opts.catGridLine) : "";
    if (opts.showCatAxisTitle) {
      strXml += genXmlTitle({
        color: opts.catAxisTitleColor,
        fontFace: opts.catAxisTitleFontFace,
        fontSize: opts.catAxisTitleFontSize,
        titleRotate: opts.catAxisTitleRotate,
        title: opts.catAxisTitle || "Axis Title"
      });
    }
    if (opts._type === "scatter" /* SCATTER */ || opts._type === "bubble" /* BUBBLE */ || opts._type === "bubble3D" /* BUBBLE3D */) {
      strXml += '  <c:numFmt formatCode="' + (opts.valAxisLabelFormatCode ? encodeXmlEntities(opts.valAxisLabelFormatCode) : "General") + '" sourceLinked="1"/>';
    } else {
      strXml += '  <c:numFmt formatCode="' + (encodeXmlEntities(opts.catLabelFormatCode) || "General") + '" sourceLinked="1"/>';
    }
    if (opts._type === "scatter" /* SCATTER */) {
      strXml += '  <c:majorTickMark val="none"/>';
      strXml += '  <c:minorTickMark val="none"/>';
      strXml += '  <c:tickLblPos val="nextTo"/>';
    } else {
      strXml += '  <c:majorTickMark val="' + (opts.catAxisMajorTickMark || "out") + '"/>';
      strXml += '  <c:minorTickMark val="' + (opts.catAxisMinorTickMark || "none") + '"/>';
      strXml += '  <c:tickLblPos val="' + (opts.catAxisLabelPos || (opts.barDir === "col" ? "low" : "nextTo")) + '"/>';
    }
    strXml += "  <c:spPr>";
    strXml += `    <a:ln w="${opts.catAxisLineSize ? valToPts(opts.catAxisLineSize) : ONEPT}" cap="flat">`;
    strXml += !opts.catAxisLineShow ? "<a:noFill/>" : "<a:solidFill>" + createColorElement(opts.catAxisLineColor || DEF_CHART_GRIDLINE.color) + "</a:solidFill>";
    strXml += '      <a:prstDash val="' + (opts.catAxisLineStyle || "solid") + '"/>';
    strXml += "      <a:round/>";
    strXml += "    </a:ln>";
    strXml += "  </c:spPr>";
    strXml += "  <c:txPr>";
    if (opts.catAxisLabelRotate) {
      strXml += `<a:bodyPr rot="${convertRotationDegrees(opts.catAxisLabelRotate)}"/>`;
    } else {
      strXml += "<a:bodyPr/>";
    }
    strXml += "    <a:lstStyle/>";
    strXml += "    <a:p>";
    strXml += "    <a:pPr>";
    strXml += `      <a:defRPr sz="${Math.round((opts.catAxisLabelFontSize || DEF_FONT_SIZE) * 100)}" b="${opts.catAxisLabelFontBold ? 1 : 0}" i="${opts.catAxisLabelFontItalic ? 1 : 0}" u="none" strike="noStrike">`;
    strXml += "      <a:solidFill>" + createColorElement(opts.catAxisLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
    strXml += '      <a:latin typeface="' + (opts.catAxisLabelFontFace || "Arial") + '"/>';
    strXml += "   </a:defRPr>";
    strXml += "  </a:pPr>";
    strXml += '  <a:endParaRPr lang="' + (opts.lang || "en-US") + '"/>';
    strXml += "  </a:p>";
    strXml += " </c:txPr>";
    strXml += ' <c:crossAx val="' + valAxisId + '"/>';
    strXml += ` <c:${typeof opts.valAxisCrossesAt === "number" ? "crossesAt" : "crosses"} val="${opts.valAxisCrossesAt || "autoZero"}"/>`;
    strXml += ' <c:auto val="1"/>';
    strXml += ' <c:lblAlgn val="ctr"/>';
    strXml += ` <c:noMultiLvlLbl val="${opts.catAxisMultiLevelLabels ? 0 : 1}"/>`;
    if (opts.catAxisLabelFrequency) strXml += ' <c:tickLblSkip val="' + opts.catAxisLabelFrequency + '"/>';
    if (opts.catLabelFormatCode || opts._type === "scatter" /* SCATTER */ || opts._type === "bubble" /* BUBBLE */ || opts._type === "bubble3D" /* BUBBLE3D */) {
      if (opts.catLabelFormatCode) {
        ["catAxisBaseTimeUnit", "catAxisMajorTimeUnit", "catAxisMinorTimeUnit"].forEach((opt) => {
          if (opts[opt] && (typeof opts[opt] !== "string" || !["days", "months", "years"].includes(opts[opt].toLowerCase()))) {
            console.warn(`"${opt}" must be one of: 'days','months','years' !`);
            opts[opt] = null;
          }
        });
        if (opts.catAxisBaseTimeUnit) strXml += '<c:baseTimeUnit val="' + opts.catAxisBaseTimeUnit.toLowerCase() + '"/>';
        if (opts.catAxisMajorTimeUnit) strXml += '<c:majorTimeUnit val="' + opts.catAxisMajorTimeUnit.toLowerCase() + '"/>';
        if (opts.catAxisMinorTimeUnit) strXml += '<c:minorTimeUnit val="' + opts.catAxisMinorTimeUnit.toLowerCase() + '"/>';
      }
      if (opts.catAxisMajorUnit) strXml += `<c:majorUnit val="${opts.catAxisMajorUnit}"/>`;
      if (opts.catAxisMinorUnit) strXml += `<c:minorUnit val="${opts.catAxisMinorUnit}"/>`;
    }
    if (opts._type === "scatter" /* SCATTER */ || opts._type === "bubble" /* BUBBLE */ || opts._type === "bubble3D" /* BUBBLE3D */) {
      strXml += "</c:valAx>";
    } else {
      strXml += "</c:" + (opts.catLabelFormatCode ? "dateAx" : "catAx") + ">";
    }
    return strXml;
  }
  function makeValAxis(opts, valAxisId) {
    let axisPos = valAxisId === AXIS_ID_VALUE_PRIMARY ? opts.barDir === "col" ? "l" : "b" : opts.barDir !== "col" ? "r" : "t";
    if (valAxisId === AXIS_ID_VALUE_SECONDARY) axisPos = "r";
    const crossAxId = valAxisId === AXIS_ID_VALUE_PRIMARY ? AXIS_ID_CATEGORY_PRIMARY : AXIS_ID_CATEGORY_SECONDARY;
    let strXml = "";
    strXml += "<c:valAx>";
    strXml += '  <c:axId val="' + valAxisId + '"/>';
    strXml += "  <c:scaling>";
    if (opts.valAxisLogScaleBase) strXml += `<c:logBase val="${opts.valAxisLogScaleBase}"/>`;
    strXml += '<c:orientation val="' + (opts.valAxisOrientation || (opts.barDir === "col" ? "minMax" : "minMax")) + '"/>';
    if (opts.valAxisMaxVal || opts.valAxisMaxVal === 0) strXml += `<c:max val="${opts.valAxisMaxVal}"/>`;
    if (opts.valAxisMinVal || opts.valAxisMinVal === 0) strXml += `<c:min val="${opts.valAxisMinVal}"/>`;
    strXml += "  </c:scaling>";
    strXml += `  <c:delete val="${opts.valAxisHidden ? 1 : 0}"/>`;
    strXml += '  <c:axPos val="' + axisPos + '"/>';
    if (opts.valGridLine.style !== "none") strXml += createGridLineElement(opts.valGridLine);
    if (opts.showValAxisTitle) {
      strXml += genXmlTitle({
        color: opts.valAxisTitleColor,
        fontFace: opts.valAxisTitleFontFace,
        fontSize: opts.valAxisTitleFontSize,
        titleRotate: opts.valAxisTitleRotate,
        title: opts.valAxisTitle || "Axis Title"
      });
    }
    strXml += `<c:numFmt formatCode="${opts.valAxisLabelFormatCode ? encodeXmlEntities(opts.valAxisLabelFormatCode) : "General"}" sourceLinked="0"/>`;
    if (opts._type === "scatter" /* SCATTER */) {
      strXml += '  <c:majorTickMark val="none"/>';
      strXml += '  <c:minorTickMark val="none"/>';
      strXml += '  <c:tickLblPos val="nextTo"/>';
    } else {
      strXml += ' <c:majorTickMark val="' + (opts.valAxisMajorTickMark || "out") + '"/>';
      strXml += ' <c:minorTickMark val="' + (opts.valAxisMinorTickMark || "none") + '"/>';
      strXml += ' <c:tickLblPos val="' + (opts.valAxisLabelPos || (opts.barDir === "col" ? "nextTo" : "low")) + '"/>';
    }
    strXml += " <c:spPr>";
    strXml += `   <a:ln w="${opts.valAxisLineSize ? valToPts(opts.valAxisLineSize) : ONEPT}" cap="flat">`;
    strXml += !opts.valAxisLineShow ? "<a:noFill/>" : "<a:solidFill>" + createColorElement(opts.valAxisLineColor || DEF_CHART_GRIDLINE.color) + "</a:solidFill>";
    strXml += '     <a:prstDash val="' + (opts.valAxisLineStyle || "solid") + '"/>';
    strXml += "     <a:round/>";
    strXml += "   </a:ln>";
    strXml += " </c:spPr>";
    strXml += " <c:txPr>";
    strXml += `  <a:bodyPr${opts.valAxisLabelRotate ? ' rot="' + convertRotationDegrees(opts.valAxisLabelRotate).toString() + '"' : ""}/>`;
    strXml += "  <a:lstStyle/>";
    strXml += "  <a:p>";
    strXml += "    <a:pPr>";
    strXml += `      <a:defRPr sz="${Math.round((opts.valAxisLabelFontSize || DEF_FONT_SIZE) * 100)}" b="${opts.valAxisLabelFontBold ? 1 : 0}" i="${opts.valAxisLabelFontItalic ? 1 : 0}" u="none" strike="noStrike">`;
    strXml += "        <a:solidFill>" + createColorElement(opts.valAxisLabelColor || DEF_FONT_COLOR) + "</a:solidFill>";
    strXml += '        <a:latin typeface="' + (opts.valAxisLabelFontFace || "Arial") + '"/>';
    strXml += "      </a:defRPr>";
    strXml += "    </a:pPr>";
    strXml += '  <a:endParaRPr lang="' + (opts.lang || "en-US") + '"/>';
    strXml += "  </a:p>";
    strXml += " </c:txPr>";
    strXml += ' <c:crossAx val="' + crossAxId + '"/>';
    if (typeof opts.catAxisCrossesAt === "number") {
      strXml += ` <c:crossesAt val="${opts.catAxisCrossesAt}"/>`;
    } else if (typeof opts.catAxisCrossesAt === "string") {
      strXml += ' <c:crosses val="' + opts.catAxisCrossesAt + '"/>';
    } else {
      const isRight = axisPos === "r" || axisPos === "t";
      const crosses = isRight ? "max" : "autoZero";
      strXml += ' <c:crosses val="' + crosses + '"/>';
    }
    strXml += ' <c:crossBetween val="' + (opts._type === "scatter" /* SCATTER */ || !!(Array.isArray(opts._type) && opts._type.filter((type) => type.type === "area" /* AREA */).length > 0) ? "midCat" : "between") + '"/>';
    if (opts.valAxisMajorUnit) strXml += ` <c:majorUnit val="${opts.valAxisMajorUnit}"/>`;
    if (opts.valAxisDisplayUnit) {
      strXml += `<c:dispUnits><c:builtInUnit val="${opts.valAxisDisplayUnit}"/>${opts.valAxisDisplayUnitLabel ? "<c:dispUnitsLbl/>" : ""}</c:dispUnits>`;
    }
    strXml += "</c:valAx>";
    return strXml;
  }
  function makeSerAxis(opts, axisId, valAxisId) {
    let strXml = "";
    strXml += "<c:serAx>";
    strXml += '  <c:axId val="' + axisId + '"/>';
    strXml += '  <c:scaling><c:orientation val="' + (opts.serAxisOrientation || (opts.barDir === "col" ? "minMax" : "minMax")) + '"/></c:scaling>';
    strXml += '  <c:delete val="' + (opts.serAxisHidden ? "1" : "0") + '"/>';
    strXml += '  <c:axPos val="' + (opts.barDir === "col" ? "b" : "l") + '"/>';
    strXml += opts.serGridLine.style !== "none" ? createGridLineElement(opts.serGridLine) : "";
    if (opts.showSerAxisTitle) {
      strXml += genXmlTitle({
        color: opts.serAxisTitleColor,
        fontFace: opts.serAxisTitleFontFace,
        fontSize: opts.serAxisTitleFontSize,
        titleRotate: opts.serAxisTitleRotate,
        title: opts.serAxisTitle || "Axis Title"
      });
    }
    strXml += `  <c:numFmt formatCode="${encodeXmlEntities(opts.serLabelFormatCode) || "General"}" sourceLinked="0"/>`;
    strXml += '  <c:majorTickMark val="out"/>';
    strXml += '  <c:minorTickMark val="none"/>';
    strXml += `  <c:tickLblPos val="${opts.serAxisLabelPos || opts.barDir === "col" ? "low" : "nextTo"}"/>`;
    strXml += "  <c:spPr>";
    strXml += '    <a:ln w="12700" cap="flat">';
    strXml += !opts.serAxisLineShow ? "<a:noFill/>" : `<a:solidFill>${createColorElement(opts.serAxisLineColor || DEF_CHART_GRIDLINE.color)}</a:solidFill>`;
    strXml += '      <a:prstDash val="solid"/>';
    strXml += "      <a:round/>";
    strXml += "    </a:ln>";
    strXml += "  </c:spPr>";
    strXml += "  <c:txPr>";
    strXml += "    <a:bodyPr/>";
    strXml += "    <a:lstStyle/>";
    strXml += "    <a:p>";
    strXml += "    <a:pPr>";
    strXml += `    <a:defRPr sz="${Math.round((opts.serAxisLabelFontSize || DEF_FONT_SIZE) * 100)}" b="${opts.serAxisLabelFontBold ? "1" : "0"}" i="${opts.serAxisLabelFontItalic ? "1" : "0"}" u="none" strike="noStrike">`;
    strXml += `      <a:solidFill>${createColorElement(opts.serAxisLabelColor || DEF_FONT_COLOR)}</a:solidFill>`;
    strXml += `      <a:latin typeface="${opts.serAxisLabelFontFace || "Arial"}"/>`;
    strXml += "   </a:defRPr>";
    strXml += "  </a:pPr>";
    strXml += '  <a:endParaRPr lang="' + (opts.lang || "en-US") + '"/>';
    strXml += "  </a:p>";
    strXml += " </c:txPr>";
    strXml += ' <c:crossAx val="' + valAxisId + '"/>';
    strXml += ' <c:crosses val="autoZero"/>';
    if (opts.serAxisLabelFrequency) strXml += ' <c:tickLblSkip val="' + opts.serAxisLabelFrequency + '"/>';
    if (opts.serLabelFormatCode) {
      ["serAxisBaseTimeUnit", "serAxisMajorTimeUnit", "serAxisMinorTimeUnit"].forEach((opt) => {
        if (opts[opt] && (typeof opts[opt] !== "string" || !["days", "months", "years"].includes(opt.toLowerCase()))) {
          console.warn(`"${opt}" must be one of: 'days','months','years' !`);
          opts[opt] = null;
        }
      });
      if (opts.serAxisBaseTimeUnit) strXml += ` <c:baseTimeUnit  val="${opts.serAxisBaseTimeUnit.toLowerCase()}"/>`;
      if (opts.serAxisMajorTimeUnit) strXml += ` <c:majorTimeUnit val="${opts.serAxisMajorTimeUnit.toLowerCase()}"/>`;
      if (opts.serAxisMinorTimeUnit) strXml += ` <c:minorTimeUnit val="${opts.serAxisMinorTimeUnit.toLowerCase()}"/>`;
      if (opts.serAxisMajorUnit) strXml += ` <c:majorUnit val="${opts.serAxisMajorUnit}"/>`;
      if (opts.serAxisMinorUnit) strXml += ` <c:minorUnit val="${opts.serAxisMinorUnit}"/>`;
    }
    strXml += "</c:serAx>";
    return strXml;
  }
  function genXmlTitle(opts, chartX, chartY) {
    const align = opts.titleAlign === "left" || opts.titleAlign === "right" ? `<a:pPr algn="${opts.titleAlign.substring(0, 1)}">` : "<a:pPr>";
    const rotate = opts.titleRotate ? `<a:bodyPr rot="${convertRotationDegrees(opts.titleRotate)}"/>` : "<a:bodyPr/>";
    const sizeAttr = opts.fontSize ? `sz="${Math.round(opts.fontSize * 100)}"` : "";
    const titleBold = opts.titleBold ? 1 : 0;
    let layout = "<c:layout/>";
    if (opts.titlePos && typeof opts.titlePos.x === "number" && typeof opts.titlePos.y === "number") {
      const totalX = opts.titlePos.x + chartX;
      const totalY = opts.titlePos.y + chartY;
      let valX = totalX === 0 ? 0 : totalX * (totalX / 5) / 10;
      if (valX >= 1) valX = valX / 10;
      if (valX >= 0.1) valX = valX / 10;
      let valY = totalY === 0 ? 0 : totalY * (totalY / 5) / 10;
      if (valY >= 1) valY = valY / 10;
      if (valY >= 0.1) valY = valY / 10;
      layout = `<c:layout><c:manualLayout><c:xMode val="edge"/><c:yMode val="edge"/><c:x val="${valX}"/><c:y val="${valY}"/></c:manualLayout></c:layout>`;
    }
    return `<c:title>
      <c:tx>
        <c:rich>
          ${rotate}
          <a:lstStyle/>
          <a:p>
            ${align}
            <a:defRPr ${sizeAttr} b="${titleBold}" i="0" u="none" strike="noStrike">
              <a:solidFill>${createColorElement(opts.color || DEF_FONT_COLOR)}</a:solidFill>
              <a:latin typeface="${opts.fontFace || "Arial"}"/>
            </a:defRPr>
          </a:pPr>
          <a:r>
            <a:rPr ${sizeAttr} b="${titleBold}" i="0" u="none" strike="noStrike">
              <a:solidFill>${createColorElement(opts.color || DEF_FONT_COLOR)}</a:solidFill>
              <a:latin typeface="${opts.fontFace || "Arial"}"/>
            </a:rPr>
            <a:t>${encodeXmlEntities(opts.title) || ""}</a:t>
          </a:r>
        </a:p>
        </c:rich>
      </c:tx>
      ${layout}
      <c:overlay val="0"/>
    </c:title>`;
  }
  function getExcelColName(colIndex) {
    let colStr = "";
    const colIdx = colIndex - 1;
    if (colIdx <= 25) {
      colStr = LETTERS[colIdx];
    } else {
      colStr = `${LETTERS[Math.floor(colIdx / LETTERS.length - 1)]}${LETTERS[colIdx % LETTERS.length]}`;
    }
    return colStr;
  }
  function createShadowElement(options, defaults) {
    if (!options) {
      return "<a:effectLst/>";
    } else if (typeof options !== "object") {
      console.warn("`shadow` options must be an object. Ex: `{shadow: {type:'none'}}`");
      return "<a:effectLst/>";
    }
    let strXml = "<a:effectLst>";
    const opts = __spreadValues(__spreadValues({}, defaults), options);
    const type = opts.type || "outer";
    const blur = valToPts(opts.blur);
    const offset = valToPts(opts.offset);
    const angle = Math.round(opts.angle * 6e4);
    const color = opts.color;
    const opacity = Math.round(opts.opacity * 1e5);
    const rotShape = opts.rotateWithShape ? 1 : 0;
    strXml += `<a:${type}Shdw sx="100000" sy="100000" kx="0" ky="0"  algn="bl" blurRad="${blur}" rotWithShape="${rotShape}" dist="${offset}" dir="${angle}">`;
    strXml += `<a:srgbClr val="${color}">`;
    strXml += `<a:alpha val="${opacity}"/></a:srgbClr>`;
    strXml += `</a:${type}Shdw>`;
    strXml += "</a:effectLst>";
    return strXml;
  }
  function createGridLineElement(glOpts) {
    let strXml = "<c:majorGridlines>";
    strXml += " <c:spPr>";
    strXml += `  <a:ln w="${valToPts(glOpts.size || DEF_CHART_GRIDLINE.size)}" cap="${createLineCap(glOpts.cap || DEF_CHART_GRIDLINE.cap)}">`;
    strXml += '  <a:solidFill><a:srgbClr val="' + (glOpts.color || DEF_CHART_GRIDLINE.color) + '"/></a:solidFill>';
    strXml += '   <a:prstDash val="' + (glOpts.style || DEF_CHART_GRIDLINE.style) + '"/><a:round/>';
    strXml += "  </a:ln>";
    strXml += " </c:spPr>";
    strXml += "</c:majorGridlines>";
    return strXml;
  }
  function createLineCap(lineCap) {
    if (!lineCap || lineCap === "flat") {
      return "flat";
    } else if (lineCap === "square") {
      return "sq";
    } else if (lineCap === "round") {
      return "rnd";
    } else {
      const neverLineCap = lineCap;
      throw new Error(`Invalid chart line cap: ${neverLineCap}`);
    }
  }

  // src/gen-media.ts
  function encodeSlideMediaRels(layout) {
    var _a, _b;
    const isNode = typeof process !== "undefined" && !!((_a = process.versions) == null ? void 0 : _a.node) && ((_b = process.release) == null ? void 0 : _b.name) === "node";
    let fs;
    let https;
    const loadNodeDeps = isNode ? () => __async(null, null, function* () {
      ;
      ({ default: fs } = yield import("fs"));
      ({ default: https } = yield import("https"));
    }) : () => __async(null, null, function* () {
    });
    if (isNode) loadNodeDeps();
    const imageProms = [];
    const candidateRels = layout._relsMedia.filter(
      (rel) => rel.type !== "online" && !rel.data && (!rel.path || rel.path && !rel.path.includes("preencoded"))
    );
    const unqPaths = [];
    candidateRels.forEach((rel) => {
      var _a2;
      const relPath = (_a2 = rel.path) != null ? _a2 : "";
      if (!unqPaths.includes(relPath)) {
        rel.isDuplicate = false;
        unqPaths.push(relPath);
      } else {
        rel.isDuplicate = true;
      }
    });
    candidateRels.filter((rel) => !rel.isDuplicate).forEach((rel) => {
      imageProms.push(
        (() => __async(null, null, function* () {
          var _a2;
          if (!https) yield loadNodeDeps();
          const relPath = (_a2 = rel.path) != null ? _a2 : "";
          if (isNode && fs && relPath.indexOf("http") !== 0) {
            try {
              const bitmap = fs.readFileSync(relPath);
              rel.data = Buffer.from(bitmap).toString("base64");
              candidateRels.filter((dupe) => dupe.isDuplicate && dupe.path === relPath).forEach((dupe) => dupe.data = rel.data);
              return "done";
            } catch (ex) {
              rel.data = IMG_BROKEN;
              candidateRels.filter((dupe) => dupe.isDuplicate && dupe.path === relPath).forEach((dupe) => dupe.data = rel.data);
              throw new Error(`ERROR: Unable to read media: "${relPath}"
${String(ex)}`);
            }
          }
          if (isNode && https && relPath.startsWith("http")) {
            return yield new Promise((resolve, reject) => {
              https.get(relPath, (res) => {
                let raw = "";
                res.setEncoding("binary");
                res.on("data", (chunk) => raw += chunk);
                res.on("end", () => {
                  rel.data = Buffer.from(raw, "binary").toString("base64");
                  candidateRels.filter((dupe) => dupe.isDuplicate && dupe.path === relPath).forEach((dupe) => dupe.data = rel.data);
                  resolve("done");
                });
                res.on("error", () => {
                  rel.data = IMG_BROKEN;
                  candidateRels.filter((dupe) => dupe.isDuplicate && dupe.path === relPath).forEach((dupe) => dupe.data = rel.data);
                  reject(new Error(`ERROR! Unable to load image (https.get): ${relPath}`));
                });
              });
            });
          }
          return yield new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.onload = () => {
              const reader = new FileReader();
              reader.onloadend = () => {
                rel.data = reader.result;
                candidateRels.filter((dupe) => dupe.isDuplicate && dupe.path === relPath).forEach((dupe) => dupe.data = rel.data);
                if (!rel.isSvgPng) {
                  resolve("done");
                } else {
                  createSvgPngPreview(rel).then(() => resolve("done")).catch(reject);
                }
              };
              reader.readAsDataURL(xhr.response);
            };
            xhr.onerror = () => {
              rel.data = IMG_BROKEN;
              candidateRels.filter((dupe) => dupe.isDuplicate && dupe.path === relPath).forEach((dupe) => dupe.data = rel.data);
              reject(new Error(`ERROR! Unable to load image (xhr.onerror): ${relPath}`));
            };
            xhr.open("GET", relPath);
            xhr.responseType = "blob";
            xhr.send();
          });
        }))()
      );
    });
    layout._relsMedia.filter((rel) => rel.isSvgPng && rel.data).forEach((rel) => {
      (() => __async(null, null, function* () {
        if (isNode && !fs) yield loadNodeDeps();
        if (isNode && fs) {
          rel.data = IMG_BROKEN;
          imageProms.push(Promise.resolve("done"));
        } else {
          imageProms.push(createSvgPngPreview(rel));
        }
      }))();
    });
    return imageProms;
  }
  function createSvgPngPreview(rel) {
    return __async(this, null, function* () {
      return yield new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => {
          if (image.width + image.height === 0) {
            if (image.onerror) image.onerror("h/w=0");
            return;
          }
          const canvas = document.createElement("CANVAS");
          const ctx = canvas.getContext("2d");
          canvas.width = image.width;
          canvas.height = image.height;
          ctx == null ? void 0 : ctx.drawImage(image, 0, 0);
          try {
            rel.data = canvas.toDataURL(rel.type);
            resolve("done");
          } catch (ex) {
            if (image.onerror) image.onerror(String(ex));
          }
        };
        image.onerror = () => {
          rel.data = IMG_BROKEN;
          reject(new Error(`ERROR! Unable to load image (image.onerror): ${rel.path}`));
        };
        image.src = typeof rel.data === "string" ? rel.data : IMG_BROKEN;
      });
    });
  }

  // src/gen-xml.ts
  var import_xmlbuilder22 = __toESM(require_lib7(), 1);

  // src/xml/namespaces.ts
  var NS_A = "http://schemas.openxmlformats.org/drawingml/2006/main";
  var NS_P = "http://schemas.openxmlformats.org/presentationml/2006/main";
  var NS_R = "http://schemas.openxmlformats.org/officeDocument/2006/relationships";
  var NS_P14 = "http://schemas.microsoft.com/office/powerpoint/2010/main";
  var NS_CP = "http://schemas.openxmlformats.org/package/2006/metadata/core-properties";
  var NS_DC = "http://purl.org/dc/elements/1.1/";
  var NS_DCTERMS = "http://purl.org/dc/terms/";
  var NS_XSI = "http://www.w3.org/2001/XMLSchema-instance";
  var NS_RELATIONSHIPS = "http://schemas.openxmlformats.org/package/2006/relationships";
  var NS_CONTENT_TYPES = "http://schemas.openxmlformats.org/package/2006/content-types";
  var NS_EXTENDED_PROPERTIES = "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties";
  var NS_VT = "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes";
  var NS_P15 = "http://schemas.microsoft.com/office/powerpoint/2012/main";
  var REL_TYPE_EXTENDED_PROPERTIES = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties";
  var REL_TYPE_CORE_PROPERTIES = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties";
  var REL_TYPE_OFFICE_DOCUMENT = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument";
  var REL_TYPE_SLIDE_MASTER = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster";
  var REL_TYPE_SLIDE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide";
  var REL_TYPE_NOTES_MASTER = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesMaster";
  var REL_TYPE_NOTES_SLIDE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide";
  var REL_TYPE_PRES_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/presProps";
  var REL_TYPE_VIEW_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/viewProps";
  var REL_TYPE_THEME = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme";
  var REL_TYPE_TABLE_STYLES = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles";
  var REL_TYPE_HYPERLINK = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink";
  var REL_TYPE_IMAGE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image";
  var REL_TYPE_AUDIO = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/audio";
  var REL_TYPE_VIDEO = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/video";
  var REL_TYPE_CHART = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart";
  var REL_TYPE_MEDIA = "http://schemas.microsoft.com/office/2007/relationships/media";

  // src/gen-xml-text.ts
  function genXmlParagraphProperties(textObj, isDefault) {
    var _a, _b;
    let strXmlBullet = "";
    let strXmlLnSpc = "";
    let strXmlParaSpc = "";
    let strXmlTabStops = "";
    const tag = isDefault ? "a:lvl1pPr" : "a:pPr";
    let bulletMarL = valToPts(DEF_BULLET_MARGIN);
    let paragraphPropXml = `<${tag}${textObj.options.rtlMode ? ' rtl="1" ' : ""}`;
    {
      if (textObj.options.align) {
        switch (textObj.options.align) {
          case "left":
            paragraphPropXml += ' algn="l"';
            break;
          case "right":
            paragraphPropXml += ' algn="r"';
            break;
          case "center":
            paragraphPropXml += ' algn="ctr"';
            break;
          case "justify":
            paragraphPropXml += ' algn="just"';
            break;
          default:
            paragraphPropXml += "";
            break;
        }
      }
      if (textObj.options.lineSpacing) {
        strXmlLnSpc = `<a:lnSpc><a:spcPts val="${Math.round(textObj.options.lineSpacing * 100)}"/></a:lnSpc>`;
      } else if (textObj.options.lineSpacingMultiple) {
        strXmlLnSpc = `<a:lnSpc><a:spcPct val="${Math.round(textObj.options.lineSpacingMultiple * 1e5)}"/></a:lnSpc>`;
      }
      if (textObj.options.indentLevel && !isNaN(Number(textObj.options.indentLevel)) && textObj.options.indentLevel > 0) {
        paragraphPropXml += ` lvl="${textObj.options.indentLevel}"`;
      }
      if (textObj.options.paraSpaceBefore && !isNaN(Number(textObj.options.paraSpaceBefore)) && textObj.options.paraSpaceBefore > 0) {
        strXmlParaSpc += `<a:spcBef><a:spcPts val="${Math.round(textObj.options.paraSpaceBefore * 100)}"/></a:spcBef>`;
      }
      if (textObj.options.paraSpaceAfter && !isNaN(Number(textObj.options.paraSpaceAfter)) && textObj.options.paraSpaceAfter > 0) {
        strXmlParaSpc += `<a:spcAft><a:spcPts val="${Math.round(textObj.options.paraSpaceAfter * 100)}"/></a:spcAft>`;
      }
      if (typeof textObj.options.bullet === "object") {
        if ((_b = (_a = textObj == null ? void 0 : textObj.options) == null ? void 0 : _a.bullet) == null ? void 0 : _b.indent) bulletMarL = valToPts(textObj.options.bullet.indent);
        if (textObj.options.bullet.type) {
          if (textObj.options.bullet.type.toString().toLowerCase() === "number") {
            paragraphPropXml += ` marL="${textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL}" indent="-${bulletMarL}"`;
            strXmlBullet = `<a:buSzPct val="100000"/><a:buFont typeface="+mj-lt"/><a:buAutoNum type="${textObj.options.bullet.numberType || "arabicPeriod"}" startAt="${textObj.options.bullet.numberStartAt || "1"}"/>`;
          }
        } else if (textObj.options.bullet.characterCode) {
          let bulletCode = `&#x${textObj.options.bullet.characterCode};`;
          if (!/^[0-9A-Fa-f]{4}$/.test(textObj.options.bullet.characterCode)) {
            console.warn("Warning: `bullet.characterCode should be a 4-digit unicode charatcer (ex: 22AB)`!");
            bulletCode = "&#x2022;" /* DEFAULT */;
          }
          paragraphPropXml += ` marL="${textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL}" indent="-${bulletMarL}"`;
          strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="' + bulletCode + '"/>';
        } else {
          paragraphPropXml += ` marL="${textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL}" indent="-${bulletMarL}"`;
          strXmlBullet = `<a:buSzPct val="100000"/><a:buChar char="${"&#x2022;" /* DEFAULT */}"/>`;
        }
      } else if (textObj.options.bullet) {
        paragraphPropXml += ` marL="${textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL}" indent="-${bulletMarL}"`;
        strXmlBullet = `<a:buSzPct val="100000"/><a:buChar char="${"&#x2022;" /* DEFAULT */}"/>`;
      } else if (!textObj.options.bullet) {
        paragraphPropXml += ' indent="0" marL="0"';
        strXmlBullet = "<a:buNone/>";
      }
      if (textObj.options.tabStops && Array.isArray(textObj.options.tabStops)) {
        const tabStopsXml = textObj.options.tabStops.map((stop) => `<a:tab pos="${inch2Emu(stop.position || 1)}" algn="${stop.alignment || "l"}"/>`).join("");
        strXmlTabStops = `<a:tabLst>${tabStopsXml}</a:tabLst>`;
      }
      paragraphPropXml += ">" + strXmlLnSpc + strXmlParaSpc + strXmlBullet + strXmlTabStops;
      if (isDefault) paragraphPropXml += genXmlTextRunProperties(textObj.options, true);
      paragraphPropXml += "</" + tag + ">";
    }
    return paragraphPropXml;
  }
  function genXmlTextRunProperties(opts, isDefault) {
    var _a;
    let runProps = "";
    const runPropsTag = isDefault ? "a:defRPr" : "a:rPr";
    runProps += "<" + runPropsTag + ' lang="' + (opts.lang ? opts.lang : "en-US") + '"' + (opts.lang ? ' altLang="en-US"' : "");
    runProps += opts.fontSize ? ` sz="${Math.round(opts.fontSize * 100)}"` : "";
    runProps += (opts == null ? void 0 : opts.bold) ? ` b="${opts.bold ? "1" : "0"}"` : "";
    runProps += (opts == null ? void 0 : opts.italic) ? ` i="${opts.italic ? "1" : "0"}"` : "";
    runProps += (opts == null ? void 0 : opts.strike) ? ` strike="${typeof opts.strike === "string" ? opts.strike : "sngStrike"}"` : "";
    if (typeof opts.underline === "object" && ((_a = opts.underline) == null ? void 0 : _a.style)) {
      runProps += ` u="${opts.underline.style}"`;
    } else if (typeof opts.underline === "string") {
      runProps += ` u="${String(opts.underline)}"`;
    } else if (opts.hyperlink) {
      runProps += ' u="sng"';
    }
    if (opts.baseline) {
      runProps += ` baseline="${Math.round(opts.baseline * 50)}"`;
    } else if (opts.subscript) {
      runProps += ' baseline="-40000"';
    } else if (opts.superscript) {
      runProps += ' baseline="30000"';
    }
    runProps += opts.charSpacing ? ` spc="${Math.round(opts.charSpacing * 100)}" kern="0"` : "";
    runProps += ' dirty="0">';
    if (opts.color || opts.fontFace || opts.outline || typeof opts.underline === "object" && opts.underline.color) {
      if (opts.outline && typeof opts.outline === "object") {
        runProps += `<a:ln w="${valToPts(opts.outline.size || 0.75)}">${genXmlColorSelection(opts.outline.color || "FFFFFF")}</a:ln>`;
      }
      if (opts.color) runProps += genXmlColorSelection({ color: opts.color, transparency: opts.transparency });
      if (opts.highlight) runProps += `<a:highlight>${createColorElement(opts.highlight)}</a:highlight>`;
      if (typeof opts.underline === "object" && opts.underline.color) runProps += `<a:uFill>${genXmlColorSelection(opts.underline.color)}</a:uFill>`;
      if (opts.glow) runProps += `<a:effectLst>${createGlowElement(opts.glow, DEF_TEXT_GLOW)}</a:effectLst>`;
      if (opts.fontFace) {
        runProps += `<a:latin typeface="${opts.fontFace}" pitchFamily="34" charset="0"/><a:ea typeface="${opts.fontFace}" pitchFamily="34" charset="-122"/><a:cs typeface="${opts.fontFace}" pitchFamily="34" charset="-120"/>`;
      }
    }
    if (opts.hyperlink) {
      if (typeof opts.hyperlink !== "object") throw new Error("ERROR: text `hyperlink` option should be an object. Ex: `hyperlink:{url:'https://github.com'}` ");
      else if (!opts.hyperlink.url && !opts.hyperlink.slide) throw new Error("ERROR: 'hyperlink requires either `url` or `slide`'");
      else if (opts.hyperlink.url) {
        runProps += `<a:hlinkClick r:id="rId${opts.hyperlink._rId}" invalidUrl="" action="" tgtFrame="" tooltip="${opts.hyperlink.tooltip ? encodeXmlEntities(opts.hyperlink.tooltip) : ""}" history="1" highlightClick="0" endSnd="0"${opts.color ? ">" : "/>"}`;
      } else if (opts.hyperlink.slide) {
        runProps += `<a:hlinkClick r:id="rId${opts.hyperlink._rId}" action="ppaction://hlinksldjump" tooltip="${opts.hyperlink.tooltip ? encodeXmlEntities(opts.hyperlink.tooltip) : ""}"${opts.color ? ">" : "/>"}`;
      }
      if (opts.color) {
        runProps += " <a:extLst>";
        runProps += '  <a:ext uri="{A12FA001-AC4F-418D-AE19-62706E023703}">';
        runProps += '   <ahyp:hlinkClr xmlns:ahyp="http://schemas.microsoft.com/office/drawing/2018/hyperlinkcolor" val="tx"/>';
        runProps += "  </a:ext>";
        runProps += " </a:extLst>";
        runProps += "</a:hlinkClick>";
      }
    }
    runProps += `</${runPropsTag}>`;
    return runProps;
  }
  function genXmlTextRun(textObj) {
    return textObj.text ? `<a:r>${genXmlTextRunProperties(textObj.options, false)}<a:t>${encodeXmlEntities(textObj.text)}</a:t></a:r>` : "";
  }
  function genXmlBodyProperties(slideObject) {
    let bodyProperties = "<a:bodyPr";
    if (slideObject && slideObject._type === "text" /* text */ && slideObject.options._bodyProp) {
      bodyProperties += slideObject.options._bodyProp.wrap ? ' wrap="square"' : ' wrap="none"';
      if (slideObject.options._bodyProp.lIns || slideObject.options._bodyProp.lIns === 0) bodyProperties += ` lIns="${slideObject.options._bodyProp.lIns}"`;
      if (slideObject.options._bodyProp.tIns || slideObject.options._bodyProp.tIns === 0) bodyProperties += ` tIns="${slideObject.options._bodyProp.tIns}"`;
      if (slideObject.options._bodyProp.rIns || slideObject.options._bodyProp.rIns === 0) bodyProperties += ` rIns="${slideObject.options._bodyProp.rIns}"`;
      if (slideObject.options._bodyProp.bIns || slideObject.options._bodyProp.bIns === 0) bodyProperties += ` bIns="${slideObject.options._bodyProp.bIns}"`;
      bodyProperties += ' rtlCol="0"';
      if (slideObject.options._bodyProp.anchor) bodyProperties += ' anchor="' + slideObject.options._bodyProp.anchor + '"';
      if (slideObject.options._bodyProp.vert) bodyProperties += ' vert="' + slideObject.options._bodyProp.vert + '"';
      bodyProperties += ">";
      if (slideObject.options.fit) {
        if (slideObject.options.fit === "none") bodyProperties += "";
        else if (slideObject.options.fit === "shrink") bodyProperties += "<a:normAutofit/>";
        else if (slideObject.options.fit === "resize") bodyProperties += "<a:spAutoFit/>";
      }
      bodyProperties += "</a:bodyPr>";
    } else {
      bodyProperties += ' wrap="square" rtlCol="0">';
      bodyProperties += "</a:bodyPr>";
    }
    return slideObject._type === "tablecell" /* tablecell */ ? "<a:bodyPr/>" : bodyProperties;
  }
  function genXmlTextBody(slideObj) {
    const opts = slideObj.options || {};
    let tmpTextObjects = [];
    const arrTextObjects = [];
    if (opts && slideObj._type !== "tablecell" /* tablecell */ && (typeof slideObj.text === "undefined" || slideObj.text === null)) return "";
    let strSlideXml = slideObj._type === "tablecell" /* tablecell */ ? "<a:txBody>" : "<p:txBody>";
    {
      strSlideXml += genXmlBodyProperties(slideObj);
      if (opts.h === 0 && opts.line && opts.align) strSlideXml += '<a:lstStyle><a:lvl1pPr algn="l"/></a:lstStyle>';
      else if (slideObj._type === "placeholder") strSlideXml += `<a:lstStyle>${genXmlParagraphProperties(slideObj, true)}</a:lstStyle>`;
      else strSlideXml += "<a:lstStyle/>";
    }
    if (typeof slideObj.text === "string" || typeof slideObj.text === "number") {
      tmpTextObjects.push({ text: slideObj.text.toString(), options: opts || {} });
    } else if (slideObj.text && !Array.isArray(slideObj.text) && typeof slideObj.text === "object" && Object.keys(slideObj.text).includes("text")) {
      tmpTextObjects.push({ text: slideObj.text || "", options: slideObj.options || {} });
    } else if (Array.isArray(slideObj.text)) {
      tmpTextObjects = slideObj.text.map((item) => ({ text: item.text, options: item.options }));
    }
    tmpTextObjects.forEach((itext, idx) => {
      if (!itext.text) itext.text = "";
      itext.options = itext.options || opts || {};
      if (idx === 0 && itext.options && !itext.options.bullet && opts.bullet) itext.options.bullet = opts.bullet;
      if (typeof itext.text === "string" || typeof itext.text === "number") {
        itext.text = itext.text.toString().replace(/\r*\n/g, CRLF);
      }
      if (itext.text.includes(CRLF) && itext.text.match(/\n$/g) === null) {
        itext.text.split(CRLF).forEach((line) => {
          itext.options.breakLine = true;
          arrTextObjects.push({ text: line, options: itext.options });
        });
      } else {
        arrTextObjects.push(itext);
      }
    });
    const arrLines = [];
    let arrTexts = [];
    arrTextObjects.forEach((textObj, idx) => {
      if (arrTexts.length > 0 && (textObj.options.align || opts.align)) {
        if (textObj.options.align !== arrTextObjects[idx - 1].options.align) {
          arrLines.push(arrTexts);
          arrTexts = [];
        }
      } else if (arrTexts.length > 0 && textObj.options.bullet && arrTexts.length > 0) {
        arrLines.push(arrTexts);
        arrTexts = [];
        textObj.options.breakLine = false;
      }
      arrTexts.push(textObj);
      if (arrTexts.length > 0 && textObj.options.breakLine) {
        if (idx + 1 < arrTextObjects.length) {
          arrLines.push(arrTexts);
          arrTexts = [];
        }
      }
      if (idx + 1 === arrTextObjects.length) arrLines.push(arrTexts);
    });
    arrLines.forEach((line) => {
      var _a;
      let reqsClosingFontSize = false;
      strSlideXml += "<a:p>";
      let paragraphPropXml = `<a:pPr ${((_a = line[0].options) == null ? void 0 : _a.rtlMode) ? ' rtl="1" ' : ""}`;
      line.forEach((textObj, idx) => {
        textObj.options._lineIdx = idx;
        if (idx > 0 && textObj.options.softBreakBefore) {
          strSlideXml += "<a:br/>";
        }
        textObj.options.align = textObj.options.align || opts.align;
        textObj.options.lineSpacing = textObj.options.lineSpacing || opts.lineSpacing;
        textObj.options.lineSpacingMultiple = textObj.options.lineSpacingMultiple || opts.lineSpacingMultiple;
        textObj.options.indentLevel = textObj.options.indentLevel || opts.indentLevel;
        textObj.options.paraSpaceBefore = textObj.options.paraSpaceBefore || opts.paraSpaceBefore;
        textObj.options.paraSpaceAfter = textObj.options.paraSpaceAfter || opts.paraSpaceAfter;
        paragraphPropXml = genXmlParagraphProperties(textObj, false);
        strSlideXml += paragraphPropXml.replace("<a:pPr></a:pPr>", "");
        Object.entries(opts).filter(([key]) => !(textObj.options.hyperlink && key === "color")).forEach(([key, val]) => {
          if (key !== "bullet" && !textObj.options[key]) textObj.options[key] = val;
        });
        strSlideXml += genXmlTextRun(textObj);
        if (!textObj.text && opts.fontSize || textObj.options.fontSize) {
          reqsClosingFontSize = true;
          opts.fontSize = opts.fontSize || textObj.options.fontSize;
        }
      });
      if (slideObj._type === "tablecell" /* tablecell */ && (opts.fontSize || opts.fontFace)) {
        if (opts.fontFace) {
          strSlideXml += `<a:endParaRPr lang="${opts.lang || "en-US"}"` + (opts.fontSize ? ` sz="${Math.round(opts.fontSize * 100)}"` : "") + ' dirty="0">';
          strSlideXml += `<a:latin typeface="${opts.fontFace}" charset="0"/>`;
          strSlideXml += `<a:ea typeface="${opts.fontFace}" charset="0"/>`;
          strSlideXml += `<a:cs typeface="${opts.fontFace}" charset="0"/>`;
          strSlideXml += "</a:endParaRPr>";
        } else {
          strSlideXml += `<a:endParaRPr lang="${opts.lang || "en-US"}"` + (opts.fontSize ? ` sz="${Math.round(opts.fontSize * 100)}"` : "") + ' dirty="0"/>';
        }
      } else if (reqsClosingFontSize) {
        strSlideXml += `<a:endParaRPr lang="${opts.lang || "en-US"}"` + (opts.fontSize ? ` sz="${Math.round(opts.fontSize * 100)}"` : "") + ' dirty="0"/>';
      } else {
        strSlideXml += `<a:endParaRPr lang="${opts.lang || "en-US"}" dirty="0"/>`;
      }
      strSlideXml += "</a:p>";
    });
    if (strSlideXml.indexOf("<a:p>") === -1) {
      strSlideXml += "<a:p><a:endParaRPr/></a:p>";
    }
    strSlideXml += slideObj._type === "tablecell" /* tablecell */ ? "</a:txBody>" : "</p:txBody>";
    return strSlideXml;
  }
  function genXmlPlaceholder(placeholderObj) {
    var _a, _b;
    if (!placeholderObj) return "";
    const placeholderIdx = ((_a = placeholderObj.options) == null ? void 0 : _a._placeholderIdx) ? placeholderObj.options._placeholderIdx : "";
    const placeholderTyp = ((_b = placeholderObj.options) == null ? void 0 : _b._placeholderType) ? placeholderObj.options._placeholderType : "";
    const placeholderType = placeholderTyp && PLACEHOLDER_TYPES[placeholderTyp] ? PLACEHOLDER_TYPES[placeholderTyp].toString() : "";
    return `<p:ph
		${placeholderIdx ? ' idx="' + placeholderIdx.toString() + '"' : ""}
		${placeholderType && PLACEHOLDER_TYPES[placeholderType] ? ` type="${placeholderType}"` : ""}
		${placeholderObj.text && placeholderObj.text.length > 0 ? ' hasCustomPrompt="1"' : ""}
		/>`;
  }

  // src/gen-xml-slide-objects.ts
  var import_xmlbuilder2 = __toESM(require_lib7(), 1);
  function computeShadowXmlValues(shadow) {
    if (!shadow || shadow.type === "none") {
      return void 0;
    }
    return {
      type: shadow.type || "outer",
      blur: valToPts(shadow.blur || 8),
      offset: valToPts(shadow.offset || 4),
      angle: Math.round((shadow.angle || 270) * 6e4),
      opacity: Math.round((shadow.opacity || 0.75) * 1e5),
      color: shadow.color || DEF_TEXT_SHADOW.color
    };
  }
  function genShadowEffectXml(shadow) {
    const computed = computeShadowXmlValues(shadow);
    if (!computed) return "";
    const shadowElementName = `a:${computed.type}Shdw`;
    const shadowAttrs = {
      blurRad: String(computed.blur),
      dist: String(computed.offset),
      dir: String(computed.angle)
    };
    if (computed.type === "outer") {
      Object.assign(shadowAttrs, {
        sx: "100000",
        sy: "100000",
        kx: "0",
        ky: "0",
        algn: "bl",
        rotWithShape: "0"
      });
    }
    const frag = (0, import_xmlbuilder2.fragment)().ele("a:effectLst").ele(shadowElementName, shadowAttrs).ele("a:srgbClr", { val: computed.color }).ele("a:alpha", { val: String(computed.opacity) }).up().up().up().up();
    return frag.toString({ prettyPrint: false });
  }
  var ImageSizingXml = {
    cover: function(imgSize, boxDim) {
      const imgRatio = imgSize.h / imgSize.w;
      const boxRatio = boxDim.h / boxDim.w;
      const isBoxBased = boxRatio > imgRatio;
      const width = isBoxBased ? boxDim.h / imgRatio : boxDim.w;
      const height = isBoxBased ? boxDim.h : boxDim.w * imgRatio;
      const hzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.w / width));
      const vzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.h / height));
      return (0, import_xmlbuilder2.fragment)().ele("a:srcRect", { l: String(hzPerc), r: String(hzPerc), t: String(vzPerc), b: String(vzPerc) }).up().ele("a:stretch").up().toString({ prettyPrint: false });
    },
    contain: function(imgSize, boxDim) {
      const imgRatio = imgSize.h / imgSize.w;
      const boxRatio = boxDim.h / boxDim.w;
      const widthBased = boxRatio > imgRatio;
      const width = widthBased ? boxDim.w : boxDim.h / imgRatio;
      const height = widthBased ? boxDim.w * imgRatio : boxDim.h;
      const hzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.w / width));
      const vzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.h / height));
      return (0, import_xmlbuilder2.fragment)().ele("a:srcRect", { l: String(hzPerc), r: String(hzPerc), t: String(vzPerc), b: String(vzPerc) }).up().ele("a:stretch").up().toString({ prettyPrint: false });
    },
    crop: function(imgSize, boxDim) {
      const l = boxDim.x;
      const r = imgSize.w - (boxDim.x + boxDim.w);
      const t = boxDim.y;
      const b = imgSize.h - (boxDim.y + boxDim.h);
      const lPerc = Math.round(1e5 * (l / imgSize.w));
      const rPerc = Math.round(1e5 * (r / imgSize.w));
      const tPerc = Math.round(1e5 * (t / imgSize.h));
      const bPerc = Math.round(1e5 * (b / imgSize.h));
      return (0, import_xmlbuilder2.fragment)().ele("a:srcRect", { l: String(lPerc), r: String(rPerc), t: String(tPerc), b: String(bPerc) }).up().ele("a:stretch").up().toString({ prettyPrint: false });
    }
  };
  function slideObjectToXml(slide) {
    var _a, _b;
    let strSlideXml = slide._name ? '<p:cSld name="' + slide._name + '">' : "<p:cSld>";
    let intTableNum = 1;
    if (slide._bkgdImgRid) {
      strSlideXml += `<p:bg><p:bgPr><a:blipFill dpi="0" rotWithShape="1"><a:blip r:embed="rId${slide._bkgdImgRid}"><a:lum/></a:blip><a:srcRect/><a:stretch><a:fillRect/></a:stretch></a:blipFill><a:effectLst/></p:bgPr></p:bg>`;
    } else if (((_a = slide.background) == null ? void 0 : _a.color) || ((_b = slide.background) == null ? void 0 : _b.type) === "gradient") {
      strSlideXml += `<p:bg><p:bgPr>${genXmlColorSelection(slide.background)}</p:bgPr></p:bg>`;
    } else if (!slide.bkgd && slide._name && slide._name === DEF_PRES_LAYOUT_NAME) {
      strSlideXml += '<p:bg><p:bgRef idx="1001"><a:schemeClr val="bg1"/></p:bgRef></p:bg>';
    }
    strSlideXml += "<p:spTree>";
    strSlideXml += '<p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr>';
    strSlideXml += '<p:grpSpPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/>';
    strSlideXml += '<a:chOff x="0" y="0"/><a:chExt cx="0" cy="0"/></a:xfrm></p:grpSpPr>';
    slide._slideObjects.forEach((slideItemObj, idx) => {
      var _a2, _b2, _c, _d, _e, _f, _g, _h;
      let x = 0;
      let y = 0;
      let cx = getSmartParseNumber("75%", "X", slide._presLayout);
      let cy = 0;
      let placeholderObj;
      let locationAttr = "";
      let arrTabRows = null;
      let objTabOpts = null;
      let intColCnt = 0;
      let intColW = 0;
      let cellOpts = null;
      let strXml = null;
      const sizing = (_a2 = slideItemObj.options) == null ? void 0 : _a2.sizing;
      const rounding = (_b2 = slideItemObj.options) == null ? void 0 : _b2.rounding;
      if (slide._slideLayout !== void 0 && slide._slideLayout._slideObjects !== void 0 && slideItemObj.options && slideItemObj.options.placeholder) {
        placeholderObj = slide._slideLayout._slideObjects.filter(
          (object) => object.options.placeholder === slideItemObj.options.placeholder
        )[0];
      }
      slideItemObj.options = slideItemObj.options || {};
      if (typeof slideItemObj.options.x !== "undefined") x = getSmartParseNumber(slideItemObj.options.x, "X", slide._presLayout);
      if (typeof slideItemObj.options.y !== "undefined") y = getSmartParseNumber(slideItemObj.options.y, "Y", slide._presLayout);
      if (typeof slideItemObj.options.w !== "undefined") cx = getSmartParseNumber(slideItemObj.options.w, "X", slide._presLayout);
      if (typeof slideItemObj.options.h !== "undefined") cy = getSmartParseNumber(slideItemObj.options.h, "Y", slide._presLayout);
      let imgWidth = cx;
      let imgHeight = cy;
      if (placeholderObj) {
        if (placeholderObj.options.x || placeholderObj.options.x === 0) x = getSmartParseNumber(placeholderObj.options.x, "X", slide._presLayout);
        if (placeholderObj.options.y || placeholderObj.options.y === 0) y = getSmartParseNumber(placeholderObj.options.y, "Y", slide._presLayout);
        if (placeholderObj.options.w || placeholderObj.options.w === 0) cx = getSmartParseNumber(placeholderObj.options.w, "X", slide._presLayout);
        if (placeholderObj.options.h || placeholderObj.options.h === 0) cy = getSmartParseNumber(placeholderObj.options.h, "Y", slide._presLayout);
      }
      if (slideItemObj.options.flipH) locationAttr += ' flipH="1"';
      if (slideItemObj.options.flipV) locationAttr += ' flipV="1"';
      if (slideItemObj.options.rotate) locationAttr += ` rot="${convertRotationDegrees(slideItemObj.options.rotate)}"`;
      switch (slideItemObj._type) {
        case "table" /* table */:
          arrTabRows = slideItemObj.arrTabRows;
          objTabOpts = slideItemObj.options;
          intColCnt = 0;
          intColW = 0;
          arrTabRows[0].forEach((cell) => {
            cellOpts = cell.options || null;
            intColCnt += (cellOpts == null ? void 0 : cellOpts.colspan) ? Number(cellOpts.colspan) : 1;
          });
          strXml = `<p:graphicFrame><p:nvGraphicFramePr><p:cNvPr id="${intTableNum * slide._slideNum + 1}" name="${slideItemObj.options.objectName}"/>`;
          strXml += '<p:cNvGraphicFramePr><a:graphicFrameLocks noGrp="1"/></p:cNvGraphicFramePr>  <p:nvPr><p:extLst><p:ext uri="{D42A27DB-BD31-4B8C-83A1-F6EECF244321}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="1579011935"/></p:ext></p:extLst></p:nvPr></p:nvGraphicFramePr>';
          strXml += `<p:xfrm><a:off x="${x || (x === 0 ? 0 : EMU)}" y="${y || (y === 0 ? 0 : EMU)}"/><a:ext cx="${cx || (cx === 0 ? 0 : EMU)}" cy="${cy || EMU}"/></p:xfrm>`;
          strXml += '<a:graphic><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/table"><a:tbl><a:tblPr/>';
          if (Array.isArray(objTabOpts.colW)) {
            strXml += "<a:tblGrid>";
            for (let col = 0; col < intColCnt; col++) {
              let w = inch2Emu(objTabOpts.colW[col]);
              if (w == null || isNaN(w)) {
                w = (typeof slideItemObj.options.w === "number" ? slideItemObj.options.w : 1) / intColCnt;
              }
              strXml += `<a:gridCol w="${Math.round(w)}"/>`;
            }
            strXml += "</a:tblGrid>";
          } else {
            intColW = objTabOpts.colW ? objTabOpts.colW : EMU;
            if (slideItemObj.options.w && !objTabOpts.colW) intColW = Math.round((typeof slideItemObj.options.w === "number" ? slideItemObj.options.w : 1) / intColCnt);
            strXml += "<a:tblGrid>";
            for (let colw = 0; colw < intColCnt; colw++) {
              strXml += `<a:gridCol w="${intColW}"/>`;
            }
            strXml += "</a:tblGrid>";
          }
          arrTabRows.forEach((cells) => {
            var _a3, _b3;
            for (let cIdx = 0; cIdx < cells.length; ) {
              const cell = cells[cIdx];
              const colspan = (_a3 = cell.options) == null ? void 0 : _a3.colspan;
              const rowspan = (_b3 = cell.options) == null ? void 0 : _b3.rowspan;
              if (colspan && colspan > 1) {
                const vMergeCells = new Array(colspan - 1).fill(void 0).map(() => {
                  return { _type: "tablecell" /* tablecell */, options: { rowspan }, _hmerge: true };
                });
                cells.splice(cIdx + 1, 0, ...vMergeCells);
                cIdx += colspan;
              } else {
                cIdx += 1;
              }
            }
          });
          arrTabRows.forEach((cells, rIdx) => {
            const nextRow = arrTabRows[rIdx + 1];
            if (!nextRow) return;
            cells.forEach((cell, cIdx) => {
              var _a3, _b3;
              const rowspan = cell._rowContinue || ((_a3 = cell.options) == null ? void 0 : _a3.rowspan);
              const colspan = (_b3 = cell.options) == null ? void 0 : _b3.colspan;
              const _hmerge = cell._hmerge;
              if (rowspan && rowspan > 1) {
                const hMergeCell = { _type: "tablecell" /* tablecell */, options: { colspan }, _rowContinue: rowspan - 1, _vmerge: true, _hmerge };
                nextRow.splice(cIdx, 0, hMergeCell);
              }
            });
          });
          arrTabRows.forEach((cells, rIdx) => {
            let intRowH = 0;
            if (Array.isArray(objTabOpts.rowH) && objTabOpts.rowH[rIdx]) intRowH = inch2Emu(Number(objTabOpts.rowH[rIdx]));
            else if (objTabOpts.rowH && !isNaN(Number(objTabOpts.rowH))) intRowH = inch2Emu(Number(objTabOpts.rowH));
            else if (slideItemObj.options.cy || slideItemObj.options.h) {
              intRowH = Math.round(
                (slideItemObj.options.h ? inch2Emu(slideItemObj.options.h) : typeof slideItemObj.options.cy === "number" ? slideItemObj.options.cy : 1) / arrTabRows.length
              );
            }
            strXml += `<a:tr h="${intRowH}">`;
            cells.forEach((cellObj) => {
              var _a3, _b3, _c2, _d2, _e2;
              const cell = cellObj;
              const cellSpanAttrs = {
                rowSpan: ((_a3 = cell.options) == null ? void 0 : _a3.rowspan) > 1 ? cell.options.rowspan : void 0,
                gridSpan: ((_b3 = cell.options) == null ? void 0 : _b3.colspan) > 1 ? cell.options.colspan : void 0,
                vMerge: cell._vmerge ? 1 : void 0,
                hMerge: cell._hmerge ? 1 : void 0
              };
              let cellSpanAttrStr = Object.keys(cellSpanAttrs).map((k) => [k, cellSpanAttrs[k]]).filter(([, v]) => !!v).map(([k, v]) => `${String(k)}="${String(v)}"`).join(" ");
              if (cellSpanAttrStr) cellSpanAttrStr = " " + cellSpanAttrStr;
              if (cell._hmerge || cell._vmerge) {
                strXml += `<a:tc${cellSpanAttrStr}><a:tcPr/></a:tc>`;
                return;
              }
              const cellOpts2 = cell.options || {};
              cell.options = cellOpts2;
              ["align", "bold", "border", "color", "fill", "fontFace", "fontSize", "margin", "textDirection", "underline", "valign"].forEach((name) => {
                if (objTabOpts[name] && !cellOpts2[name] && cellOpts2[name] !== 0) cellOpts2[name] = objTabOpts[name];
              });
              const cellValign = cellOpts2.valign ? ` anchor="${cellOpts2.valign.replace(/^c$/i, "ctr").replace(/^m$/i, "ctr").replace("center", "ctr").replace("middle", "ctr").replace("top", "t").replace("btm", "b").replace("bottom", "b")}"` : "";
              const cellTextDir = cellOpts2.textDirection && cellOpts2.textDirection !== "horz" ? ` vert="${cellOpts2.textDirection}"` : "";
              let fillColor = ((_d2 = (_c2 = cell._optImp) == null ? void 0 : _c2.fill) == null ? void 0 : _d2.color) ? cell._optImp.fill.color : ((_e2 = cell._optImp) == null ? void 0 : _e2.fill) && typeof cell._optImp.fill === "string" ? cell._optImp.fill : "";
              fillColor = fillColor || cellOpts2.fill ? cellOpts2.fill : "";
              const cellFill = fillColor ? genXmlColorSelection(fillColor) : "";
              let cellMargin = cellOpts2.margin === 0 || cellOpts2.margin ? cellOpts2.margin : DEF_CELL_MARGIN_IN;
              if (!Array.isArray(cellMargin) && typeof cellMargin === "number") cellMargin = [cellMargin, cellMargin, cellMargin, cellMargin];
              let cellMarginXml = "";
              if (cellMargin[0] >= 1) {
                cellMarginXml = ` marL="${valToPts(cellMargin[3])}" marR="${valToPts(cellMargin[1])}" marT="${valToPts(cellMargin[0])}" marB="${valToPts(
                  cellMargin[2]
                )}"`;
              } else {
                cellMarginXml = ` marL="${inch2Emu(cellMargin[3])}" marR="${inch2Emu(cellMargin[1])}" marT="${inch2Emu(cellMargin[0])}" marB="${inch2Emu(
                  cellMargin[2]
                )}"`;
              }
              strXml += `<a:tc${cellSpanAttrStr}>${genXmlTextBody(cell)}<a:tcPr${cellMarginXml}${cellValign}${cellTextDir}>`;
              if (cellOpts2.border && Array.isArray(cellOpts2.border)) {
                [
                  { idx: 3, name: "lnL" },
                  { idx: 1, name: "lnR" },
                  { idx: 0, name: "lnT" },
                  { idx: 2, name: "lnB" }
                ].forEach((obj) => {
                  if (cellOpts2.border[obj.idx].type !== "none") {
                    strXml += `<a:${obj.name} w="${valToPts(cellOpts2.border[obj.idx].pt)}" cap="flat" cmpd="sng" algn="ctr">`;
                    strXml += `<a:solidFill>${createColorElement(cellOpts2.border[obj.idx].color)}</a:solidFill>`;
                    strXml += `<a:prstDash val="${cellOpts2.border[obj.idx].type === "dash" ? "sysDash" : "solid"}"/><a:round/><a:headEnd type="none" w="med" len="med"/><a:tailEnd type="none" w="med" len="med"/>`;
                    strXml += `</a:${obj.name}>`;
                  } else {
                    strXml += `<a:${obj.name} w="0" cap="flat" cmpd="sng" algn="ctr"><a:noFill/></a:${obj.name}>`;
                  }
                });
              }
              strXml += cellFill;
              strXml += "  </a:tcPr>";
              strXml += " </a:tc>";
            });
            strXml += "</a:tr>";
          });
          strXml += "      </a:tbl>";
          strXml += "    </a:graphicData>";
          strXml += "  </a:graphic>";
          strXml += "</p:graphicFrame>";
          strSlideXml += strXml;
          intTableNum++;
          break;
        case "text" /* text */:
        case "placeholder" /* placeholder */:
          if (!slideItemObj.options.line && cy === 0) cy = EMU * 0.3;
          if (!slideItemObj.options._bodyProp) slideItemObj.options._bodyProp = {};
          if (slideItemObj.options.margin && Array.isArray(slideItemObj.options.margin)) {
            slideItemObj.options._bodyProp.lIns = valToPts(slideItemObj.options.margin[0] || 0);
            slideItemObj.options._bodyProp.rIns = valToPts(slideItemObj.options.margin[1] || 0);
            slideItemObj.options._bodyProp.bIns = valToPts(slideItemObj.options.margin[2] || 0);
            slideItemObj.options._bodyProp.tIns = valToPts(slideItemObj.options.margin[3] || 0);
          } else if (typeof slideItemObj.options.margin === "number") {
            slideItemObj.options._bodyProp.lIns = valToPts(slideItemObj.options.margin);
            slideItemObj.options._bodyProp.rIns = valToPts(slideItemObj.options.margin);
            slideItemObj.options._bodyProp.bIns = valToPts(slideItemObj.options.margin);
            slideItemObj.options._bodyProp.tIns = valToPts(slideItemObj.options.margin);
          }
          strSlideXml += "<p:sp>";
          strSlideXml += `<p:nvSpPr><p:cNvPr id="${idx + 2}" name="${slideItemObj.options.objectName}">`;
          if ((_c = slideItemObj.options.hyperlink) == null ? void 0 : _c.url) {
            strSlideXml += `<a:hlinkClick r:id="rId${slideItemObj.options.hyperlink._rId}" tooltip="${slideItemObj.options.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.options.hyperlink.tooltip) : ""}"/>`;
          }
          if ((_d = slideItemObj.options.hyperlink) == null ? void 0 : _d.slide) {
            strSlideXml += `<a:hlinkClick r:id="rId${slideItemObj.options.hyperlink._rId}" tooltip="${slideItemObj.options.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.options.hyperlink.tooltip) : ""}" action="ppaction://hlinksldjump"/>`;
          }
          strSlideXml += "</p:cNvPr>";
          strSlideXml += "<p:cNvSpPr" + (((_e = slideItemObj.options) == null ? void 0 : _e.isTextBox) ? ' txBox="1"/>' : "/>");
          strSlideXml += `<p:nvPr>${slideItemObj._type === "placeholder" ? genXmlPlaceholder(slideItemObj) : genXmlPlaceholder(placeholderObj)}</p:nvPr>`;
          strSlideXml += "</p:nvSpPr><p:spPr>";
          strSlideXml += `<a:xfrm${locationAttr}>`;
          strSlideXml += `<a:off x="${x}" y="${y}"/>`;
          strSlideXml += `<a:ext cx="${cx}" cy="${cy}"/></a:xfrm>`;
          if (slideItemObj.shape === "custGeom") {
            strSlideXml += "<a:custGeom><a:avLst />";
            strSlideXml += "<a:gdLst>";
            strSlideXml += "</a:gdLst>";
            strSlideXml += "<a:ahLst />";
            strSlideXml += "<a:cxnLst>";
            strSlideXml += "</a:cxnLst>";
            strSlideXml += '<a:rect l="l" t="t" r="r" b="b" />';
            strSlideXml += "<a:pathLst>";
            strSlideXml += `<a:path w="${cx}" h="${cy}">`;
            (_f = slideItemObj.options.points) == null ? void 0 : _f.forEach((point, i) => {
              if ("curve" in point) {
                switch (point.curve.type) {
                  case "arc":
                    strSlideXml += `<a:arcTo hR="${getSmartParseNumber(point.curve.hR, "Y", slide._presLayout)}" wR="${getSmartParseNumber(
                      point.curve.wR,
                      "X",
                      slide._presLayout
                    )}" stAng="${convertRotationDegrees(point.curve.stAng)}" swAng="${convertRotationDegrees(point.curve.swAng)}" />`;
                    break;
                  case "cubic":
                    strSlideXml += `<a:cubicBezTo>
									<a:pt x="${getSmartParseNumber(point.curve.x1, "X", slide._presLayout)}" y="${getSmartParseNumber(point.curve.y1, "Y", slide._presLayout)}" />
									<a:pt x="${getSmartParseNumber(point.curve.x2, "X", slide._presLayout)}" y="${getSmartParseNumber(point.curve.y2, "Y", slide._presLayout)}" />
									<a:pt x="${getSmartParseNumber(point.x, "X", slide._presLayout)}" y="${getSmartParseNumber(point.y, "Y", slide._presLayout)}" />
									</a:cubicBezTo>`;
                    break;
                  case "quadratic":
                    strSlideXml += `<a:quadBezTo>
									<a:pt x="${getSmartParseNumber(point.curve.x1, "X", slide._presLayout)}" y="${getSmartParseNumber(point.curve.y1, "Y", slide._presLayout)}" />
									<a:pt x="${getSmartParseNumber(point.x, "X", slide._presLayout)}" y="${getSmartParseNumber(point.y, "Y", slide._presLayout)}" />
									</a:quadBezTo>`;
                    break;
                  default:
                    break;
                }
              } else if ("close" in point) {
                strSlideXml += "<a:close />";
              } else if (point.moveTo || i === 0) {
                strSlideXml += `<a:moveTo><a:pt x="${getSmartParseNumber(point.x, "X", slide._presLayout)}" y="${getSmartParseNumber(
                  point.y,
                  "Y",
                  slide._presLayout
                )}" /></a:moveTo>`;
              } else {
                strSlideXml += `<a:lnTo><a:pt x="${getSmartParseNumber(point.x, "X", slide._presLayout)}" y="${getSmartParseNumber(
                  point.y,
                  "Y",
                  slide._presLayout
                )}" /></a:lnTo>`;
              }
            });
            strSlideXml += "</a:path>";
            strSlideXml += "</a:pathLst>";
            strSlideXml += "</a:custGeom>";
          } else {
            strSlideXml += '<a:prstGeom prst="' + slideItemObj.shape + '"><a:avLst>';
            if (slideItemObj.options.rectRadius) {
              strSlideXml += `<a:gd name="adj" fmla="val ${Math.round(slideItemObj.options.rectRadius * EMU * 1e5 / Math.min(cx, cy))}"/>`;
            } else if (slideItemObj.options.angleRange) {
              for (let i = 0; i < 2; i++) {
                const angle = slideItemObj.options.angleRange[i];
                strSlideXml += `<a:gd name="adj${i + 1}" fmla="val ${convertRotationDegrees(angle)}" />`;
              }
              if (slideItemObj.options.arcThicknessRatio) {
                strSlideXml += `<a:gd name="adj3" fmla="val ${Math.round(slideItemObj.options.arcThicknessRatio * 5e4)}" />`;
              }
            }
            strSlideXml += "</a:avLst></a:prstGeom>";
          }
          strSlideXml += slideItemObj.options.fill ? genXmlColorSelection(slideItemObj.options.fill) : "<a:noFill/>";
          if (slideItemObj.options.line) {
            strSlideXml += slideItemObj.options.line.width ? `<a:ln w="${valToPts(slideItemObj.options.line.width)}">` : "<a:ln>";
            if (slideItemObj.options.line.color) strSlideXml += genXmlColorSelection(slideItemObj.options.line);
            if (slideItemObj.options.line.dashType) strSlideXml += `<a:prstDash val="${slideItemObj.options.line.dashType}"/>`;
            if (slideItemObj.options.line.beginArrowType) strSlideXml += `<a:headEnd type="${slideItemObj.options.line.beginArrowType}"/>`;
            if (slideItemObj.options.line.endArrowType) strSlideXml += `<a:tailEnd type="${slideItemObj.options.line.endArrowType}"/>`;
            strSlideXml += "</a:ln>";
          }
          strSlideXml += genShadowEffectXml(slideItemObj.options.shadow);
          strSlideXml += "</p:spPr>";
          strSlideXml += genXmlTextBody(slideItemObj);
          strSlideXml += "</p:sp>";
          break;
        case "image" /* image */:
          strSlideXml += "<p:pic>";
          strSlideXml += "  <p:nvPicPr>";
          strSlideXml += `<p:cNvPr id="${idx + 2}" name="${slideItemObj.options.objectName}" descr="${encodeXmlEntities(
            slideItemObj.options.altText || slideItemObj.image
          )}">`;
          if ((_g = slideItemObj.hyperlink) == null ? void 0 : _g.url) {
            strSlideXml += `<a:hlinkClick r:id="rId${slideItemObj.hyperlink._rId}" tooltip="${slideItemObj.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.hyperlink.tooltip) : ""}"/>`;
          }
          if ((_h = slideItemObj.hyperlink) == null ? void 0 : _h.slide) {
            strSlideXml += `<a:hlinkClick r:id="rId${slideItemObj.hyperlink._rId}" tooltip="${slideItemObj.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.hyperlink.tooltip) : ""}" action="ppaction://hlinksldjump"/>`;
          }
          strSlideXml += "    </p:cNvPr>";
          strSlideXml += '    <p:cNvPicPr><a:picLocks noChangeAspect="1"/></p:cNvPicPr>';
          strSlideXml += "    <p:nvPr>" + genXmlPlaceholder(placeholderObj) + "</p:nvPr>";
          strSlideXml += "  </p:nvPicPr>";
          strSlideXml += "<p:blipFill>";
          if ((slide._relsMedia || []).filter((rel) => rel.rId === slideItemObj.imageRid)[0] && (slide._relsMedia || []).filter((rel) => rel.rId === slideItemObj.imageRid)[0].extn === "svg") {
            strSlideXml += `<a:blip r:embed="rId${slideItemObj.imageRid - 1}">`;
            strSlideXml += slideItemObj.options.transparency ? ` <a:alphaModFix amt="${Math.round((100 - slideItemObj.options.transparency) * 1e3)}"/>` : "";
            strSlideXml += " <a:extLst>";
            strSlideXml += '  <a:ext uri="{96DAC541-7B7A-43D3-8B79-37D633B846F1}">';
            strSlideXml += `   <asvg:svgBlip xmlns:asvg="http://schemas.microsoft.com/office/drawing/2016/SVG/main" r:embed="rId${slideItemObj.imageRid}"/>`;
            strSlideXml += "  </a:ext>";
            strSlideXml += " </a:extLst>";
            strSlideXml += "</a:blip>";
          } else {
            strSlideXml += `<a:blip r:embed="rId${slideItemObj.imageRid}">`;
            strSlideXml += slideItemObj.options.transparency ? `<a:alphaModFix amt="${Math.round((100 - slideItemObj.options.transparency) * 1e3)}"/>` : "";
            strSlideXml += "</a:blip>";
          }
          if (sizing == null ? void 0 : sizing.type) {
            const boxW = sizing.w ? getSmartParseNumber(sizing.w, "X", slide._presLayout) : cx;
            const boxH = sizing.h ? getSmartParseNumber(sizing.h, "Y", slide._presLayout) : cy;
            const boxX = getSmartParseNumber(sizing.x || 0, "X", slide._presLayout);
            const boxY = getSmartParseNumber(sizing.y || 0, "Y", slide._presLayout);
            strSlideXml += ImageSizingXml[sizing.type]({ w: imgWidth, h: imgHeight }, { w: boxW, h: boxH, x: boxX, y: boxY });
            imgWidth = boxW;
            imgHeight = boxH;
          } else {
            strSlideXml += "  <a:stretch><a:fillRect/></a:stretch>";
          }
          strSlideXml += "</p:blipFill>";
          strSlideXml += "<p:spPr>";
          strSlideXml += " <a:xfrm" + locationAttr + ">";
          strSlideXml += `  <a:off x="${x}" y="${y}"/>`;
          strSlideXml += `  <a:ext cx="${imgWidth}" cy="${imgHeight}"/>`;
          strSlideXml += " </a:xfrm>";
          strSlideXml += ` <a:prstGeom prst="${rounding ? "ellipse" : "rect"}"><a:avLst/></a:prstGeom>`;
          strSlideXml += genShadowEffectXml(slideItemObj.options.shadow);
          strSlideXml += "</p:spPr>";
          strSlideXml += "</p:pic>";
          break;
        case "media" /* media */:
          if (slideItemObj.mtype === "online") {
            strSlideXml += "<p:pic>";
            strSlideXml += " <p:nvPicPr>";
            strSlideXml += `<p:cNvPr id="${slideItemObj.mediaRid + 2}" name="${slideItemObj.options.objectName}"/>`;
            strSlideXml += " <p:cNvPicPr/>";
            strSlideXml += " <p:nvPr>";
            strSlideXml += `  <a:videoFile r:link="rId${slideItemObj.mediaRid}"/>`;
            strSlideXml += " </p:nvPr>";
            strSlideXml += " </p:nvPicPr>";
            strSlideXml += ` <p:blipFill><a:blip r:embed="rId${slideItemObj.mediaRid + 1}"/><a:stretch><a:fillRect/></a:stretch></p:blipFill>`;
            strSlideXml += " <p:spPr>";
            strSlideXml += `  <a:xfrm${locationAttr}><a:off x="${x}" y="${y}"/><a:ext cx="${cx}" cy="${cy}"/></a:xfrm>`;
            strSlideXml += '  <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>';
            strSlideXml += " </p:spPr>";
            strSlideXml += "</p:pic>";
          } else {
            strSlideXml += "<p:pic>";
            strSlideXml += " <p:nvPicPr>";
            strSlideXml += `<p:cNvPr id="${slideItemObj.mediaRid + 2}" name="${slideItemObj.options.objectName}"><a:hlinkClick r:id="" action="ppaction://media"/></p:cNvPr>`;
            strSlideXml += ' <p:cNvPicPr><a:picLocks noChangeAspect="1"/></p:cNvPicPr>';
            strSlideXml += " <p:nvPr>";
            strSlideXml += `  <a:videoFile r:link="rId${slideItemObj.mediaRid}"/>`;
            strSlideXml += "  <p:extLst>";
            strSlideXml += '   <p:ext uri="{DAA4B4D4-6D71-4841-9C94-3DE7FCFB9230}">';
            strSlideXml += `    <p14:media xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" r:embed="rId${slideItemObj.mediaRid + 1}"/>`;
            strSlideXml += "   </p:ext>";
            strSlideXml += "  </p:extLst>";
            strSlideXml += " </p:nvPr>";
            strSlideXml += " </p:nvPicPr>";
            strSlideXml += ` <p:blipFill><a:blip r:embed="rId${slideItemObj.mediaRid + 2}"/><a:stretch><a:fillRect/></a:stretch></p:blipFill>`;
            strSlideXml += " <p:spPr>";
            strSlideXml += `  <a:xfrm${locationAttr}><a:off x="${x}" y="${y}"/><a:ext cx="${cx}" cy="${cy}"/></a:xfrm>`;
            strSlideXml += '  <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>';
            strSlideXml += " </p:spPr>";
            strSlideXml += "</p:pic>";
          }
          break;
        case "chart" /* chart */:
          strSlideXml += "<p:graphicFrame>";
          strSlideXml += " <p:nvGraphicFramePr>";
          strSlideXml += `   <p:cNvPr id="${idx + 2}" name="${slideItemObj.options.objectName}" descr="${encodeXmlEntities(slideItemObj.options.altText || "")}"/>`;
          strSlideXml += "   <p:cNvGraphicFramePr/>";
          strSlideXml += `   <p:nvPr>${genXmlPlaceholder(placeholderObj)}</p:nvPr>`;
          strSlideXml += " </p:nvGraphicFramePr>";
          strSlideXml += ` <p:xfrm><a:off x="${x}" y="${y}"/><a:ext cx="${cx}" cy="${cy}"/></p:xfrm>`;
          strSlideXml += ' <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">';
          strSlideXml += '  <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/chart">';
          strSlideXml += `   <c:chart r:id="rId${slideItemObj.chartRid}" xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart"/>`;
          strSlideXml += "  </a:graphicData>";
          strSlideXml += " </a:graphic>";
          strSlideXml += "</p:graphicFrame>";
          break;
        default:
          strSlideXml += "";
          break;
      }
    });
    if (slide._slideNumberProps) {
      if (!slide._slideNumberProps.align) slide._slideNumberProps.align = "left";
      strSlideXml += "<p:sp>";
      strSlideXml += " <p:nvSpPr>";
      strSlideXml += '  <p:cNvPr id="25" name="Slide Number Placeholder 0"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr>';
      strSlideXml += '  <p:nvPr><p:ph type="sldNum" sz="quarter" idx="4294967295"/></p:nvPr>';
      strSlideXml += " </p:nvSpPr>";
      strSlideXml += " <p:spPr>";
      strSlideXml += `<a:xfrm><a:off x="${getSmartParseNumber(slide._slideNumberProps.x, "X", slide._presLayout)}" y="${getSmartParseNumber(slide._slideNumberProps.y, "Y", slide._presLayout)}"/><a:ext cx="${slide._slideNumberProps.w ? getSmartParseNumber(slide._slideNumberProps.w, "X", slide._presLayout) : "800000"}" cy="${slide._slideNumberProps.h ? getSmartParseNumber(slide._slideNumberProps.h, "Y", slide._presLayout) : "300000"}"/></a:xfrm> <a:prstGeom prst="rect"><a:avLst/></a:prstGeom> <a:extLst><a:ext uri="{C572A759-6A51-4108-AA02-DFA0A04FC94B}"><ma14:wrappingTextBoxFlag val="0" xmlns:ma14="http://schemas.microsoft.com/office/mac/drawingml/2011/main"/></a:ext></a:extLst></p:spPr>`;
      strSlideXml += "<p:txBody>";
      strSlideXml += "<a:bodyPr";
      if (slide._slideNumberProps.margin && Array.isArray(slide._slideNumberProps.margin)) {
        strSlideXml += ` lIns="${valToPts(slide._slideNumberProps.margin[3] || 0)}"`;
        strSlideXml += ` tIns="${valToPts(slide._slideNumberProps.margin[0] || 0)}"`;
        strSlideXml += ` rIns="${valToPts(slide._slideNumberProps.margin[1] || 0)}"`;
        strSlideXml += ` bIns="${valToPts(slide._slideNumberProps.margin[2] || 0)}"`;
      } else if (typeof slide._slideNumberProps.margin === "number") {
        strSlideXml += ` lIns="${valToPts(slide._slideNumberProps.margin || 0)}"`;
        strSlideXml += ` tIns="${valToPts(slide._slideNumberProps.margin || 0)}"`;
        strSlideXml += ` rIns="${valToPts(slide._slideNumberProps.margin || 0)}"`;
        strSlideXml += ` bIns="${valToPts(slide._slideNumberProps.margin || 0)}"`;
      }
      if (slide._slideNumberProps.valign) {
        strSlideXml += ` anchor="${slide._slideNumberProps.valign.replace("top", "t").replace("middle", "ctr").replace("bottom", "b")}"`;
      }
      strSlideXml += "/>";
      strSlideXml += "  <a:lstStyle><a:lvl1pPr>";
      if (slide._slideNumberProps.fontFace || slide._slideNumberProps.fontSize || slide._slideNumberProps.color) {
        strSlideXml += `<a:defRPr sz="${Math.round((slide._slideNumberProps.fontSize || 12) * 100)}">`;
        if (slide._slideNumberProps.color) strSlideXml += genXmlColorSelection(slide._slideNumberProps.color);
        if (slide._slideNumberProps.fontFace) {
          strSlideXml += `<a:latin typeface="${slide._slideNumberProps.fontFace}"/><a:ea typeface="${slide._slideNumberProps.fontFace}"/><a:cs typeface="${slide._slideNumberProps.fontFace}"/>`;
        }
        strSlideXml += "</a:defRPr>";
      }
      strSlideXml += "</a:lvl1pPr></a:lstStyle>";
      strSlideXml += "<a:p>";
      if (slide._slideNumberProps.align.startsWith("l")) strSlideXml += '<a:pPr algn="l"/>';
      else if (slide._slideNumberProps.align.startsWith("c")) strSlideXml += '<a:pPr algn="ctr"/>';
      else if (slide._slideNumberProps.align.startsWith("r")) strSlideXml += '<a:pPr algn="r"/>';
      else strSlideXml += '<a:pPr algn="l"/>';
      strSlideXml += `<a:fld id="${SLDNUMFLDID}" type="slidenum"><a:rPr b="${slide._slideNumberProps.bold ? 1 : 0}" lang="en-US"/>`;
      strSlideXml += `<a:t>${slide._slideNum}</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p>`;
      strSlideXml += "</p:txBody></p:sp>";
    }
    strSlideXml += "</p:spTree>";
    strSlideXml += "</p:cSld>";
    return strSlideXml;
  }

  // src/gen-xml.ts
  function slideObjectRelationsToXml(slide, defaultRels) {
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("Relationships", { xmlns: NS_RELATIONSHIPS });
    let lastRid = 0;
    const seenTargets = /* @__PURE__ */ new Set();
    slide._rels.forEach((rel) => {
      lastRid = Math.max(lastRid, rel.rId);
      if (rel.type.toLowerCase().includes("hyperlink")) {
        if (rel.data === "slide") {
          doc.ele("Relationship", {
            Id: `rId${rel.rId}`,
            Type: REL_TYPE_SLIDE,
            Target: `slide${rel.Target}.xml`
          }).up();
        } else {
          doc.ele("Relationship", {
            Id: `rId${rel.rId}`,
            Type: REL_TYPE_HYPERLINK,
            Target: rel.Target,
            TargetMode: "External"
          }).up();
        }
      } else if (rel.type.toLowerCase().includes("notesSlide")) {
        doc.ele("Relationship", {
          Id: `rId${rel.rId}`,
          Target: rel.Target,
          Type: REL_TYPE_NOTES_SLIDE
        }).up();
      }
    });
    (slide._relsChart || []).forEach((rel) => {
      lastRid = Math.max(lastRid, rel.rId);
      doc.ele("Relationship", {
        Id: `rId${rel.rId}`,
        Type: REL_TYPE_CHART,
        Target: rel.Target
      }).up();
    });
    (slide._relsMedia || []).forEach((rel) => {
      lastRid = Math.max(lastRid, rel.rId);
      const relTypeLower = rel.type.toLowerCase();
      const targetAlreadySeen = seenTargets.has(rel.Target);
      seenTargets.add(rel.Target);
      if (relTypeLower.includes("image")) {
        doc.ele("Relationship", {
          Id: `rId${rel.rId}`,
          Type: REL_TYPE_IMAGE,
          Target: rel.Target
        }).up();
      } else if (relTypeLower.includes("audio")) {
        if (targetAlreadySeen) {
          doc.ele("Relationship", {
            Id: `rId${rel.rId}`,
            Type: REL_TYPE_MEDIA,
            Target: rel.Target
          }).up();
        } else {
          doc.ele("Relationship", {
            Id: `rId${rel.rId}`,
            Type: REL_TYPE_AUDIO,
            Target: rel.Target
          }).up();
        }
      } else if (relTypeLower.includes("video")) {
        if (targetAlreadySeen) {
          doc.ele("Relationship", {
            Id: `rId${rel.rId}`,
            Type: REL_TYPE_MEDIA,
            Target: rel.Target
          }).up();
        } else {
          doc.ele("Relationship", {
            Id: `rId${rel.rId}`,
            Type: REL_TYPE_VIDEO,
            Target: rel.Target
          }).up();
        }
      } else if (relTypeLower.includes("online")) {
        if (targetAlreadySeen) {
          doc.ele("Relationship", {
            Id: `rId${rel.rId}`,
            Type: "http://schemas.microsoft.com/office/2007/relationships/image",
            Target: rel.Target
          }).up();
        } else {
          doc.ele("Relationship", {
            Id: `rId${rel.rId}`,
            Target: rel.Target,
            TargetMode: "External",
            Type: REL_TYPE_VIDEO
          }).up();
        }
      }
    });
    defaultRels.forEach((rel, idx) => {
      doc.ele("Relationship", {
        Id: `rId${lastRid + idx + 1}`,
        Type: rel.type,
        Target: rel.target
      }).up();
    });
    return doc.end({ prettyPrint: false });
  }
  function makeXmlContTypes(slides, slideLayouts, masterSlide) {
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("Types", { xmlns: NS_CONTENT_TYPES });
    const addedContentTypes = /* @__PURE__ */ new Set();
    doc.ele("Default", { Extension: "xml", ContentType: "application/xml" }).up();
    doc.ele("Default", { Extension: "rels", ContentType: "application/vnd.openxmlformats-package.relationships+xml" }).up();
    doc.ele("Default", { Extension: "jpeg", ContentType: "image/jpeg" }).up();
    doc.ele("Default", { Extension: "jpg", ContentType: "image/jpg" }).up();
    doc.ele("Default", { Extension: "svg", ContentType: "image/svg+xml" }).up();
    doc.ele("Default", { Extension: "png", ContentType: "image/png" }).up();
    doc.ele("Default", { Extension: "gif", ContentType: "image/gif" }).up();
    doc.ele("Default", { Extension: "m4v", ContentType: "video/mp4" }).up();
    doc.ele("Default", { Extension: "mp4", ContentType: "video/mp4" }).up();
    slides.forEach((slide) => {
      (slide._relsMedia || []).forEach((rel) => {
        if (rel.type !== "image" && rel.type !== "online" && rel.type !== "chart" && rel.extn !== "m4v" && !addedContentTypes.has(rel.type)) {
          doc.ele("Default", { Extension: rel.extn, ContentType: rel.type }).up();
          addedContentTypes.add(rel.type);
        }
      });
    });
    doc.ele("Default", { Extension: "vml", ContentType: "application/vnd.openxmlformats-officedocument.vmlDrawing" }).up();
    doc.ele("Default", { Extension: "xlsx", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" }).up();
    doc.ele("Override", {
      PartName: "/ppt/presentation.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"
    }).up();
    doc.ele("Override", {
      PartName: "/ppt/notesMasters/notesMaster1.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.presentationml.notesMaster+xml"
    }).up();
    slides.forEach((slide, idx) => {
      doc.ele("Override", {
        PartName: `/ppt/slideMasters/slideMaster${idx + 1}.xml`,
        ContentType: "application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml"
      }).up();
      doc.ele("Override", {
        PartName: `/ppt/slides/slide${idx + 1}.xml`,
        ContentType: "application/vnd.openxmlformats-officedocument.presentationml.slide+xml"
      }).up();
      slide._relsChart.forEach((rel) => {
        doc.ele("Override", {
          PartName: rel.Target,
          ContentType: "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
        }).up();
      });
    });
    doc.ele("Override", {
      PartName: "/ppt/presProps.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.presentationml.presProps+xml"
    }).up();
    doc.ele("Override", {
      PartName: "/ppt/viewProps.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.presentationml.viewProps+xml"
    }).up();
    doc.ele("Override", {
      PartName: "/ppt/theme/theme1.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.theme+xml"
    }).up();
    doc.ele("Override", {
      PartName: "/ppt/tableStyles.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml"
    }).up();
    slideLayouts.forEach((layout, idx) => {
      doc.ele("Override", {
        PartName: `/ppt/slideLayouts/slideLayout${idx + 1}.xml`,
        ContentType: "application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml"
      }).up();
      (layout._relsChart || []).forEach((rel) => {
        doc.ele("Override", {
          PartName: rel.Target,
          ContentType: "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
        }).up();
      });
    });
    slides.forEach((_slide, idx) => {
      doc.ele("Override", {
        PartName: `/ppt/notesSlides/notesSlide${idx + 1}.xml`,
        ContentType: "application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml"
      }).up();
    });
    if (masterSlide) {
      masterSlide._relsChart.forEach((rel) => {
        doc.ele("Override", {
          PartName: rel.Target,
          ContentType: "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"
        }).up();
      });
      masterSlide._relsMedia.forEach((rel) => {
        if (rel.type !== "image" && rel.type !== "online" && rel.type !== "chart" && rel.extn !== "m4v" && !addedContentTypes.has(rel.type)) {
          doc.ele("Default", { Extension: rel.extn, ContentType: rel.type }).up();
          addedContentTypes.add(rel.type);
        }
      });
    }
    doc.ele("Override", {
      PartName: "/docProps/core.xml",
      ContentType: "application/vnd.openxmlformats-package.core-properties+xml"
    }).up();
    doc.ele("Override", {
      PartName: "/docProps/app.xml",
      ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml"
    }).up();
    return doc.end({ prettyPrint: false });
  }
  function makeXmlRootRels() {
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("Relationships", { xmlns: NS_RELATIONSHIPS }).ele("Relationship", {
      Id: "rId1",
      Type: REL_TYPE_EXTENDED_PROPERTIES,
      Target: "docProps/app.xml"
    }).up().ele("Relationship", {
      Id: "rId2",
      Type: REL_TYPE_CORE_PROPERTIES,
      Target: "docProps/core.xml"
    }).up().ele("Relationship", {
      Id: "rId3",
      Type: REL_TYPE_OFFICE_DOCUMENT,
      Target: "ppt/presentation.xml"
    }).up().up();
    return doc.end({ prettyPrint: false });
  }
  function makeXmlApp(slides, company) {
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("Properties", { xmlns: NS_EXTENDED_PROPERTIES, "xmlns:vt": NS_VT });
    doc.ele("TotalTime").txt("0").up();
    doc.ele("Words").txt("0").up();
    doc.ele("Application").txt("Microsoft Office PowerPoint").up();
    doc.ele("PresentationFormat").txt("On-screen Show (16:9)").up();
    doc.ele("Paragraphs").txt("0").up();
    doc.ele("Slides").txt(String(slides.length)).up();
    doc.ele("Notes").txt(String(slides.length)).up();
    doc.ele("HiddenSlides").txt("0").up();
    doc.ele("MMClips").txt("0").up();
    doc.ele("ScaleCrop").txt("false").up();
    const headingPairs = doc.ele("HeadingPairs");
    const headingVector = headingPairs.ele("vt:vector", { size: "6", baseType: "variant" });
    headingVector.ele("vt:variant").ele("vt:lpstr").txt("Fonts Used").up().up();
    headingVector.ele("vt:variant").ele("vt:i4").txt("2").up().up();
    headingVector.ele("vt:variant").ele("vt:lpstr").txt("Theme").up().up();
    headingVector.ele("vt:variant").ele("vt:i4").txt("1").up().up();
    headingVector.ele("vt:variant").ele("vt:lpstr").txt("Slide Titles").up().up();
    headingVector.ele("vt:variant").ele("vt:i4").txt(String(slides.length)).up().up();
    headingPairs.up();
    const titlesOfParts = doc.ele("TitlesOfParts");
    const titlesVector = titlesOfParts.ele("vt:vector", { size: String(slides.length + 3), baseType: "lpstr" });
    titlesVector.ele("vt:lpstr").txt("Arial").up();
    titlesVector.ele("vt:lpstr").txt("Calibri").up();
    titlesVector.ele("vt:lpstr").txt("Office Theme").up();
    slides.forEach((_slideObj, idx) => {
      titlesVector.ele("vt:lpstr").txt(`Slide ${idx + 1}`).up();
    });
    titlesOfParts.up();
    doc.ele("Company").txt(company).up();
    doc.ele("LinksUpToDate").txt("false").up();
    doc.ele("SharedDoc").txt("false").up();
    doc.ele("HyperlinksChanged").txt("false").up();
    doc.ele("AppVersion").txt("16.0000").up();
    return doc.end({ prettyPrint: false });
  }
  function makeXmlCore(title, subject, author, revision) {
    const isoTimestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/\.\d\d\dZ/, "Z");
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("cp:coreProperties", {
      "xmlns:cp": NS_CP,
      "xmlns:dc": NS_DC,
      "xmlns:dcterms": NS_DCTERMS,
      "xmlns:dcmitype": "http://purl.org/dc/dcmitype/",
      "xmlns:xsi": NS_XSI
    });
    doc.ele("dc:title").txt(title).up();
    doc.ele("dc:subject").txt(subject).up();
    doc.ele("dc:creator").txt(author).up();
    doc.ele("cp:lastModifiedBy").txt(author).up();
    doc.ele("cp:revision").txt(revision).up();
    doc.ele("dcterms:created", { "xsi:type": "dcterms:W3CDTF" }).txt(isoTimestamp).up();
    doc.ele("dcterms:modified", { "xsi:type": "dcterms:W3CDTF" }).txt(isoTimestamp).up();
    return doc.end({ prettyPrint: false });
  }
  function makeXmlPresentationRels(slides) {
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("Relationships", { xmlns: NS_RELATIONSHIPS });
    let relNum = 1;
    doc.ele("Relationship", {
      Id: `rId${relNum}`,
      Type: REL_TYPE_SLIDE_MASTER,
      Target: "slideMasters/slideMaster1.xml"
    }).up();
    for (let idx = 1; idx <= slides.length; idx++) {
      relNum++;
      doc.ele("Relationship", {
        Id: `rId${relNum}`,
        Type: REL_TYPE_SLIDE,
        Target: `slides/slide${idx}.xml`
      }).up();
    }
    relNum++;
    doc.ele("Relationship", {
      Id: `rId${relNum}`,
      Type: REL_TYPE_NOTES_MASTER,
      Target: "notesMasters/notesMaster1.xml"
    }).up();
    doc.ele("Relationship", {
      Id: `rId${relNum + 1}`,
      Type: REL_TYPE_PRES_PROPS,
      Target: "presProps.xml"
    }).up();
    doc.ele("Relationship", {
      Id: `rId${relNum + 2}`,
      Type: REL_TYPE_VIEW_PROPS,
      Target: "viewProps.xml"
    }).up();
    doc.ele("Relationship", {
      Id: `rId${relNum + 3}`,
      Type: REL_TYPE_THEME,
      Target: "theme/theme1.xml"
    }).up();
    doc.ele("Relationship", {
      Id: `rId${relNum + 4}`,
      Type: REL_TYPE_TABLE_STYLES,
      Target: "tableStyles.xml"
    }).up();
    return doc.end({ prettyPrint: false });
  }
  var MODERN_TRANSITIONS = /* @__PURE__ */ new Set([
    "morph",
    "cube",
    "box",
    "doors",
    "pan",
    "ferris",
    "gallery",
    "conveyor",
    "flip",
    "flythrough",
    "glitter",
    "honeycomb",
    "origami",
    "reveal",
    "ripple",
    "shred",
    "switch",
    "vortex",
    "warp",
    "window"
  ]);
  function makeXmlTransition(transition) {
    if (!transition || transition.type === "none") return "";
    const isMorph = transition.type === "morph";
    const isModern = MODERN_TRANSITIONS.has(transition.type);
    const attrs = [];
    if (transition.speed) {
      attrs.push(`spd="${transition.speed}"`);
    } else if (transition.durationMs) {
      if (isModern) {
        attrs.push(`p14:dur="${transition.durationMs}"`);
      } else {
        if (transition.durationMs <= 500) attrs.push('spd="fast"');
        else if (transition.durationMs <= 1500) attrs.push('spd="med"');
        else attrs.push('spd="slow"');
      }
    }
    if (transition.advanceOnClick === false) {
      attrs.push('advClick="0"');
    }
    if (transition.advanceAfterMs !== void 0) {
      attrs.push(`advTm="${transition.advanceAfterMs}"`);
    }
    const attrStr = attrs.length > 0 ? " " + attrs.join(" ") : "";
    if (isMorph) {
      const morphOption = transition.morphOption || "byObject";
      return `<mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice xmlns:p159="http://schemas.microsoft.com/office/powerpoint/2015/09/main" Requires="p159"><p:transition${attrStr.replace("p14:dur", "p159:dur")} xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" xmlns:p159="http://schemas.microsoft.com/office/powerpoint/2015/09/main"><p159:morph option="${morphOption}"/></p:transition></mc:Choice><mc:Fallback><p:transition${attrStr.replace(/p14:dur="[^"]*"/, "").trim()}><p:fade/></p:transition></mc:Fallback></mc:AlternateContent>`;
    }
    if (isModern) {
      const typeAttrs2 = [];
      if (transition.direction) {
        typeAttrs2.push(`dir="${transition.direction}"`);
      }
      if (transition.type === "wheel") {
        typeAttrs2.push('spokes="4"');
      }
      const typeAttrStr2 = typeAttrs2.length > 0 ? " " + typeAttrs2.join(" ") : "";
      return `<mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"><mc:Choice xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" Requires="p14"><p:transition${attrStr} xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main"><p14:${transition.type}${typeAttrStr2}/></p:transition></mc:Choice><mc:Fallback><p:transition${attrStr.replace(/p14:dur="[^"]*"/, "").trim()}><p:fade/></p:transition></mc:Fallback></mc:AlternateContent>`;
    }
    const typeAttrs = [];
    if (transition.direction) {
      typeAttrs.push(`dir="${transition.direction}"`);
    }
    if (transition.type === "wheel") {
      typeAttrs.push('spokes="4"');
    } else if (["wipe", "push", "cover", "pull"].includes(transition.type) && !transition.direction) {
      typeAttrs.push('dir="l"');
    } else if (["split", "blinds", "comb", "randomBar"].includes(transition.type) && !transition.direction) {
      typeAttrs.push('dir="horz"');
    }
    const typeAttrStr = typeAttrs.length > 0 ? " " + typeAttrs.join(" ") : "";
    return `<p:transition${attrStr}><p:${transition.type}${typeAttrStr}/></p:transition>`;
  }
  function makeXmlTiming(slide) {
    const animations = slide._animations;
    if (!animations || animations.length === 0) return "";
    let nextId = 2;
    let animationXml = "";
    let sequenceXml = "";
    animations.forEach((anim, idx) => {
      const shapeId = anim.shapeIndex + 2;
      const animNodeXml = makeAnimationNode(anim, shapeId, nextId, idx);
      sequenceXml += animNodeXml.xml;
      nextId = animNodeXml.nextId;
    });
    const mainSeqId = nextId++;
    animationXml = `<p:timing>
		<p:tnLst>
			<p:par>
				<p:cTn id="1" dur="indefinite" restart="never" nodeType="tmRoot">
					<p:childTnLst>
						<p:seq concurrent="1" nextAc="seek">
							<p:cTn id="${mainSeqId}" dur="indefinite" nodeType="mainSeq">
								<p:childTnLst>${sequenceXml}</p:childTnLst>
							</p:cTn>
							<p:prevCondLst>
								<p:cond evt="onPrev" delay="0"><p:tgtEl><p:sldTgt/></p:tgtEl></p:cond>
							</p:prevCondLst>
							<p:nextCondLst>
								<p:cond evt="onNext" delay="0"><p:tgtEl><p:sldTgt/></p:tgtEl></p:cond>
							</p:nextCondLst>
						</p:seq>
					</p:childTnLst>
				</p:cTn>
			</p:par>
		</p:tnLst>
	</p:timing>`.replace(/\t/g, "").replace(/\n\s*/g, "");
    return animationXml;
  }
  function makeAnimationNode(anim, shapeId, startId, animIndex) {
    let id = startId;
    const opts = anim.options;
    const durationMs = opts.durationMs || 500;
    const delayMs = opts.delayMs || 0;
    let triggerDelay = "indefinite";
    if (opts.trigger === "withPrevious") {
      triggerDelay = String(delayMs);
    } else if (opts.trigger === "afterPrevious") {
      triggerDelay = String(delayMs);
    }
    let targetXml = `<p:spTgt spid="${shapeId}"`;
    if (opts.paragraphIndex !== void 0) {
      targetXml += `><p:txEl><p:pRg st="${opts.paragraphIndex}" end="${opts.paragraphIndex}"/></p:txEl></p:spTgt>`;
    } else {
      targetXml += "/>";
    }
    const subtypeAttr = anim.presetSubtype ? ` presetSubtype="${anim.presetSubtype}"` : "";
    const outerId = id++;
    const innerId = id++;
    const effectParId = id++;
    const effectCTnId = id++;
    let effectChildrenXml = "";
    if (anim.presetClass === "entr") {
      const setId = id++;
      const setCTnId = id++;
      effectChildrenXml += `<p:set>
			<p:cBhvr>
				<p:cTn id="${setCTnId}" dur="1" fill="hold">
					<p:stCondLst><p:cond delay="0"/></p:stCondLst>
				</p:cTn>
				<p:tgtEl>${targetXml}</p:tgtEl>
				<p:attrNameLst><p:attrName>style.visibility</p:attrName></p:attrNameLst>
			</p:cBhvr>
			<p:to><p:strVal val="visible"/></p:to>
		</p:set>`.replace(/\t/g, "").replace(/\n\s*/g, "");
    }
    const animId = id++;
    effectChildrenXml += `<p:anim calcmode="lin" valueType="num">
		<p:cBhvr additive="base">
			<p:cTn id="${animId}" dur="${durationMs}"/>
			<p:tgtEl>${targetXml}</p:tgtEl>
			<p:attrNameLst><p:attrName>ppt_y</p:attrName></p:attrNameLst>
		</p:cBhvr>
		<p:tavLst>
			<p:tav tm="0"><p:val><p:strVal val="#ppt_y+#ppt_h*0.1"/></p:val></p:tav>
			<p:tav tm="100000"><p:val><p:strVal val="#ppt_y"/></p:val></p:tav>
		</p:tavLst>
	</p:anim>`.replace(/\t/g, "").replace(/\n\s*/g, "");
    const animEffectId = id++;
    const filter = getAnimationFilter(anim);
    if (filter) {
      effectChildrenXml += `<p:animEffect transition="in" filter="${filter}">
			<p:cBhvr>
				<p:cTn id="${animEffectId}" dur="${durationMs}"/>
				<p:tgtEl>${targetXml}</p:tgtEl>
			</p:cBhvr>
		</p:animEffect>`.replace(/\t/g, "").replace(/\n\s*/g, "");
    }
    const xml2 = `<p:par>
		<p:cTn id="${outerId}" fill="hold">
			<p:stCondLst><p:cond delay="${triggerDelay}"/></p:stCondLst>
			<p:childTnLst>
				<p:par>
					<p:cTn id="${innerId}" fill="hold">
						<p:stCondLst><p:cond delay="0"/></p:stCondLst>
						<p:childTnLst>
							<p:par>
								<p:cTn id="${effectParId}" presetID="${anim.presetId}" presetClass="${anim.presetClass}"${subtypeAttr} fill="hold" nodeType="clickEffect">
									<p:stCondLst><p:cond delay="0"/></p:stCondLst>
									<p:childTnLst>${effectChildrenXml}</p:childTnLst>
								</p:cTn>
							</p:par>
						</p:childTnLst>
					</p:cTn>
				</p:par>
			</p:childTnLst>
		</p:cTn>
	</p:par>`.replace(/\t/g, "").replace(/\n\s*/g, "");
    return { xml: xml2, nextId: id };
  }
  function getAnimationFilter(anim) {
    switch (anim.presetId) {
      case 10:
        return "fade";
      case 1:
        return "";
      case 2:
        return "wipe(down)";
      case 3:
        return "blinds(horizontal)";
      case 22:
        return "split(horizontal)";
      case 28:
        return "wipe(left)";
      case 29:
        return "zoom";
      default:
        return "fade";
    }
  }
  function makeXmlSlide(slide) {
    var _a;
    const transitionXml = slide._transition ? makeXmlTransition(slide._transition) : "";
    const timingXml = makeXmlTiming(slide);
    const hasModernTransition = slide._transition && MODERN_TRANSITIONS.has(slide._transition.type);
    let extraNamespaces = "";
    if (hasModernTransition) {
      extraNamespaces = ' xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main"';
      if (((_a = slide._transition) == null ? void 0 : _a.type) === "morph") {
        extraNamespaces += ' xmlns:p159="http://schemas.microsoft.com/office/powerpoint/2015/09/main"';
      }
    }
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${CRLF}<p:sld xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"${extraNamespaces}${(slide == null ? void 0 : slide.hidden) ? ' show="0"' : ""}>${slideObjectToXml(slide)}<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr>${transitionXml}${timingXml}</p:sld>`;
  }
  function getNotesFromSlide(slide) {
    let notesText = "";
    (slide._slideObjects || []).forEach((data) => {
      if (data._type === "notes" /* notes */) notesText += (data == null ? void 0 : data.text) && data.text[0] ? data.text[0].text : "";
    });
    return notesText.replace(/\r*\n/g, CRLF);
  }
  function makeXmlNotesMaster() {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${CRLF}<p:notesMaster xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"><p:cSld><p:bg><p:bgRef idx="1001"><a:schemeClr val="bg1"/></p:bgRef></p:bg><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/><a:chOff x="0" y="0"/><a:chExt cx="0" cy="0"/></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Header Placeholder 1"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="hdr" sz="quarter"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="2971800" cy="458788"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0"/><a:lstStyle><a:lvl1pPr algn="l"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Date Placeholder 2"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="dt" idx="1"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="3884613" y="0"/><a:ext cx="2971800" cy="458788"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0"/><a:lstStyle><a:lvl1pPr algn="r"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:fld id="{5282F153-3F37-0F45-9E97-73ACFA13230C}" type="datetimeFigureOut"><a:rPr lang="en-US"/><a:t>7/23/19</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Slide Image Placeholder 3"/><p:cNvSpPr><a:spLocks noGrp="1" noRot="1" noChangeAspect="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldImg" idx="2"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="685800" y="1143000"/><a:ext cx="5486400" cy="3086100"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom><a:noFill/><a:ln w="12700"><a:solidFill><a:prstClr val="black"/></a:solidFill></a:ln></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="ctr"/><a:lstStyle/><a:p><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="5" name="Notes Placeholder 4"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="body" sz="quarter" idx="3"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="685800" y="4400550"/><a:ext cx="5486400" cy="3600450"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0"/><a:lstStyle/><a:p><a:pPr lvl="0"/><a:r><a:rPr lang="en-US"/><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl="1"/><a:r><a:rPr lang="en-US"/><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl="2"/><a:r><a:rPr lang="en-US"/><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl="3"/><a:r><a:rPr lang="en-US"/><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl="4"/><a:r><a:rPr lang="en-US"/><a:t>Fifth level</a:t></a:r></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="6" name="Footer Placeholder 5"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="ftr" sz="quarter" idx="4"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="0" y="8685213"/><a:ext cx="2971800" cy="458787"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="b"/><a:lstStyle><a:lvl1pPr algn="l"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="7" name="Slide Number Placeholder 6"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="5"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x="3884613" y="8685213"/><a:ext cx="2971800" cy="458787"/></a:xfrm><a:prstGeom prst="rect"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert="horz" lIns="91440" tIns="45720" rIns="91440" bIns="45720" rtlCol="0" anchor="b"/><a:lstStyle><a:lvl1pPr algn="r"><a:defRPr sz="1200"/></a:lvl1pPr></a:lstStyle><a:p><a:fld id="{CE5E9CC1-C706-0F49-92D6-E571CC5EEA8F}" type="slidenum"><a:rPr lang="en-US"/><a:t>\u2039#\u203A</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp></p:spTree><p:extLst><p:ext uri="{BB962C8B-B14F-4D97-AF65-F5344CB8AC3E}"><p14:creationId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="1024086991"/></p:ext></p:extLst></p:cSld><p:clrMap bg1="lt1" tx1="dk1" bg2="lt2" tx2="dk2" accent1="accent1" accent2="accent2" accent3="accent3" accent4="accent4" accent5="accent5" accent6="accent6" hlink="hlink" folHlink="folHlink"/><p:notesStyle><a:lvl1pPr marL="0" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr><a:lvl2pPr marL="457200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr><a:lvl3pPr marL="914400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr><a:lvl4pPr marL="1371600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr><a:lvl5pPr marL="1828800" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr><a:lvl6pPr marL="2286000" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr><a:lvl7pPr marL="2743200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr><a:lvl8pPr marL="3200400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr><a:lvl9pPr marL="3657600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr></p:notesStyle></p:notesMaster>`;
  }
  function makeXmlNotesSlide(slide) {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${CRLF}<p:notes xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"><p:cSld><p:spTree><p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/><a:chOff x="0" y="0"/><a:chExt cx="0" cy="0"/></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id="2" name="Slide Image Placeholder 1"/><p:cNvSpPr><a:spLocks noGrp="1" noRot="1" noChangeAspect="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldImg"/></p:nvPr></p:nvSpPr><p:spPr/></p:sp><p:sp><p:nvSpPr><p:cNvPr id="3" name="Notes Placeholder 2"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="body" idx="1"/></p:nvPr></p:nvSpPr><p:spPr/><p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:r><a:rPr lang="en-US" dirty="0"/><a:t>${encodeXmlEntities(getNotesFromSlide(slide))}</a:t></a:r><a:endParaRPr lang="en-US" dirty="0"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id="4" name="Slide Number Placeholder 3"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr><p:nvPr><p:ph type="sldNum" sz="quarter" idx="10"/></p:nvPr></p:nvSpPr><p:spPr/><p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:fld id="${SLDNUMFLDID}" type="slidenum"><a:rPr lang="en-US"/><a:t>${slide._slideNum}</a:t></a:fld><a:endParaRPr lang="en-US"/></a:p></p:txBody></p:sp></p:spTree><p:extLst><p:ext uri="{BB962C8B-B14F-4D97-AF65-F5344CB8AC3E}"><p14:creationId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="1024086991"/></p:ext></p:extLst></p:cSld><p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:notes>`;
  }
  function makeXmlLayout(layout) {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
		<p:sldLayout xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main" preserve="1">
		${slideObjectToXml(layout)}
		<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:sldLayout>`;
  }
  function makeXmlMaster(slide, layouts) {
    const layoutDefs = layouts.map((_layoutDef, idx) => `<p:sldLayoutId id="${LAYOUT_IDX_SERIES_BASE + idx}" r:id="rId${slide._rels.length + idx + 1}"/>`);
    let strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF;
    strXml += '<p:sldMaster xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main">';
    strXml += slideObjectToXml(slide);
    strXml += '<p:clrMap bg1="lt1" tx1="dk1" bg2="lt2" tx2="dk2" accent1="accent1" accent2="accent2" accent3="accent3" accent4="accent4" accent5="accent5" accent6="accent6" hlink="hlink" folHlink="folHlink"/>';
    strXml += "<p:sldLayoutIdLst>" + layoutDefs.join("") + "</p:sldLayoutIdLst>";
    strXml += '<p:hf sldNum="0" hdr="0" ftr="0" dt="0"/>';
    strXml += '<p:txStyles> <p:titleStyle>  <a:lvl1pPr algn="ctr" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="0"/></a:spcBef><a:buNone/><a:defRPr sz="4400" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mj-lt"/><a:ea typeface="+mj-ea"/><a:cs typeface="+mj-cs"/></a:defRPr></a:lvl1pPr> </p:titleStyle> <p:bodyStyle>  <a:lvl1pPr marL="342900" indent="-342900" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="3200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr>  <a:lvl2pPr marL="742950" indent="-285750" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2013"/><a:defRPr sz="2800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr>  <a:lvl3pPr marL="1143000" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="2400" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr>  <a:lvl4pPr marL="1600200" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2013"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr>  <a:lvl5pPr marL="2057400" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\xBB"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr>  <a:lvl6pPr marL="2514600" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr>  <a:lvl7pPr marL="2971800" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr>  <a:lvl8pPr marL="3429000" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr>  <a:lvl9pPr marL="3886200" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char="\u2022"/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr> </p:bodyStyle> <p:otherStyle>  <a:defPPr><a:defRPr lang="en-US"/></a:defPPr>  <a:lvl1pPr marL="0" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr>  <a:lvl2pPr marL="457200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr>  <a:lvl3pPr marL="914400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr>  <a:lvl4pPr marL="1371600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr>  <a:lvl5pPr marL="1828800" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr>  <a:lvl6pPr marL="2286000" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr>  <a:lvl7pPr marL="2743200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr>  <a:lvl8pPr marL="3200400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr>  <a:lvl9pPr marL="3657600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr> </p:otherStyle></p:txStyles>';
    strXml += "</p:sldMaster>";
    return strXml;
  }
  function makeXmlSlideLayoutRel(layoutNumber, slideLayouts) {
    return slideObjectRelationsToXml(slideLayouts[layoutNumber - 1], [
      {
        target: "../slideMasters/slideMaster1.xml",
        type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster"
      }
    ]);
  }
  function makeXmlSlideRel(slides, slideLayouts, slideNumber) {
    return slideObjectRelationsToXml(slides[slideNumber - 1], [
      {
        target: `../slideLayouts/slideLayout${getLayoutIdxForSlide(slides, slideLayouts, slideNumber)}.xml`,
        type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout"
      },
      {
        target: `../notesSlides/notesSlide${slideNumber}.xml`,
        type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide"
      }
    ]);
  }
  function makeXmlNotesSlideRel(slideNumber) {
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("Relationships", { xmlns: NS_RELATIONSHIPS }).ele("Relationship", {
      Id: "rId1",
      Type: REL_TYPE_NOTES_MASTER,
      Target: "../notesMasters/notesMaster1.xml"
    }).up().ele("Relationship", {
      Id: "rId2",
      Type: REL_TYPE_SLIDE,
      Target: `../slides/slide${slideNumber}.xml`
    }).up().up();
    return doc.end({ prettyPrint: false });
  }
  function makeXmlMasterRel(masterSlide, slideLayouts) {
    const defaultRels = slideLayouts.map((_layoutDef, idx) => ({
      target: `../slideLayouts/slideLayout${idx + 1}.xml`,
      type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout"
    }));
    defaultRels.push({ target: "../theme/theme1.xml", type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" });
    return slideObjectRelationsToXml(masterSlide, defaultRels);
  }
  function makeXmlNotesMasterRel() {
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("Relationships", { xmlns: NS_RELATIONSHIPS }).ele("Relationship", {
      Id: "rId1",
      Type: REL_TYPE_THEME,
      Target: "../theme/theme1.xml"
    }).up().up();
    return doc.end({ prettyPrint: false });
  }
  function getLayoutIdxForSlide(slides, slideLayouts, slideNumber) {
    var _a, _b;
    for (let i = 0; i < slideLayouts.length; i++) {
      if (slideLayouts[i]._name === ((_b = (_a = slides[slideNumber - 1]) == null ? void 0 : _a._slideLayout) == null ? void 0 : _b._name)) {
        return i + 1;
      }
    }
    return 1;
  }
  function makeXmlTheme(pres) {
    var _a, _b, _c, _d;
    const majorFont = ((_a = pres.theme) == null ? void 0 : _a.headFontFace) ? `<a:latin typeface="${(_b = pres.theme) == null ? void 0 : _b.headFontFace}"/>` : '<a:latin typeface="Calibri Light" panose="020F0302020204030204"/>';
    const minorFont = ((_c = pres.theme) == null ? void 0 : _c.bodyFontFace) ? `<a:latin typeface="${(_d = pres.theme) == null ? void 0 : _d.bodyFontFace}"/>` : '<a:latin typeface="Calibri" panose="020F0502020204030204"/>';
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?><a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont>${majorFont}<a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\u6E38\u30B4\u30B7\u30C3\u30AF Light"/><a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/><a:font script="Hans" typeface="\u7B49\u7EBF Light"/><a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Angsana New"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:majorFont><a:minorFont>${minorFont}<a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="\u6E38\u30B4\u30B7\u30C3\u30AF"/><a:font script="Hang" typeface="\uB9D1\uC740 \uACE0\uB515"/><a:font script="Hans" typeface="\u7B49\u7EBF"/><a:font script="Hant" typeface="\u65B0\u7D30\u660E\u9AD4"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Cordia New"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/><a:font script="Armn" typeface="Arial"/><a:font script="Bugi" typeface="Leelawadee UI"/><a:font script="Bopo" typeface="Microsoft JhengHei"/><a:font script="Java" typeface="Javanese Text"/><a:font script="Lisu" typeface="Segoe UI"/><a:font script="Mymr" typeface="Myanmar Text"/><a:font script="Nkoo" typeface="Ebrima"/><a:font script="Olck" typeface="Nirmala UI"/><a:font script="Osma" typeface="Ebrima"/><a:font script="Phag" typeface="Phagspa"/><a:font script="Syrn" typeface="Estrangelo Edessa"/><a:font script="Syrj" typeface="Estrangelo Edessa"/><a:font script="Syre" typeface="Estrangelo Edessa"/><a:font script="Sora" typeface="Nirmala UI"/><a:font script="Tale" typeface="Microsoft Tai Le"/><a:font script="Talu" typeface="Microsoft New Tai Lue"/><a:font script="Tfng" typeface="Ebrima"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>`;
  }
  function makeXmlPresentation(pres) {
    const rootAttrs = {
      "xmlns:a": NS_A,
      "xmlns:r": NS_R,
      "xmlns:p": NS_P,
      saveSubsetFonts: "1",
      autoCompressPictures: "0"
    };
    if (pres.rtlMode) {
      rootAttrs.rtl = "1";
    }
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("p:presentation", rootAttrs);
    doc.ele("p:sldMasterIdLst").ele("p:sldMasterId", { id: "2147483648", "r:id": "rId1" }).up().up();
    const sldIdLst = doc.ele("p:sldIdLst");
    pres.slides.forEach((slide) => {
      sldIdLst.ele("p:sldId", { id: String(slide._slideId), "r:id": `rId${slide._rId}` }).up();
    });
    sldIdLst.up();
    doc.ele("p:notesMasterIdLst").ele("p:notesMasterId", { "r:id": `rId${pres.slides.length + 2}` }).up().up();
    doc.ele("p:sldSz", { cx: String(pres.presLayout.width), cy: String(pres.presLayout.height) }).up();
    doc.ele("p:notesSz", { cx: String(pres.presLayout.height), cy: String(pres.presLayout.width) }).up();
    const defaultTextStyle = doc.ele("p:defaultTextStyle");
    for (let idy = 1; idy < 10; idy++) {
      const lvlPPr = defaultTextStyle.ele(`a:lvl${idy}pPr`, {
        marL: String((idy - 1) * 457200),
        algn: "l",
        defTabSz: "914400",
        rtl: "0",
        eaLnBrk: "1",
        latinLnBrk: "0",
        hangingPunct: "1"
      });
      const defRPr = lvlPPr.ele("a:defRPr", { sz: "1800", kern: "1200" });
      defRPr.ele("a:solidFill").ele("a:schemeClr", { val: "tx1" }).up().up();
      defRPr.ele("a:latin", { typeface: "+mn-lt" }).up();
      defRPr.ele("a:ea", { typeface: "+mn-ea" }).up();
      defRPr.ele("a:cs", { typeface: "+mn-cs" }).up();
      defRPr.up();
      lvlPPr.up();
    }
    defaultTextStyle.up();
    if (pres.sections && pres.sections.length > 0) {
      const extLst = doc.ele("p:extLst");
      const ext1 = extLst.ele("p:ext", { uri: "{521415D9-36F7-43E2-AB2F-B90AF26B5E84}" });
      const sectionLst = ext1.ele("p14:sectionLst", { "xmlns:p14": NS_P14 });
      pres.sections.forEach((sect) => {
        const section = sectionLst.ele("p14:section", {
          name: sect.title,
          id: `{${getUuid("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx")}}`
        });
        const sldIdLstSect = section.ele("p14:sldIdLst");
        sect._slides.forEach((slide) => {
          sldIdLstSect.ele("p14:sldId", { id: String(slide._slideId) }).up();
        });
        sldIdLstSect.up();
        section.up();
      });
      sectionLst.up();
      ext1.up();
      extLst.ele("p:ext", { uri: "{EFAFB233-063F-42B5-8137-9DF3F51BA10A}" }).ele("p15:sldGuideLst", { "xmlns:p15": NS_P15 }).up().up();
      extLst.up();
    }
    return doc.end({ prettyPrint: false });
  }
  function makeXmlPresProps() {
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("p:presentationPr", {
      "xmlns:a": NS_A,
      "xmlns:r": NS_R,
      "xmlns:p": NS_P
    });
    return doc.end({ prettyPrint: false });
  }
  function makeXmlTableStyles() {
    const doc = (0, import_xmlbuilder22.create)({ version: "1.0", encoding: "UTF-8", standalone: "yes" }).ele("a:tblStyleLst", {
      "xmlns:a": NS_A,
      def: "{5C22544A-7EE6-4342-B048-85BDC9FD1C3A}"
    });
    return doc.end({ prettyPrint: false });
  }
  function makeXmlViewProps() {
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${CRLF}<p:viewPr xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"><p:normalViewPr horzBarState="maximized"><p:restoredLeft sz="15611"/><p:restoredTop sz="94610"/></p:normalViewPr><p:slideViewPr><p:cSldViewPr snapToGrid="0" snapToObjects="1"><p:cViewPr varScale="1"><p:scale><a:sx n="136" d="100"/><a:sy n="136" d="100"/></p:scale><p:origin x="216" y="312"/></p:cViewPr><p:guideLst/></p:cSldViewPr></p:slideViewPr><p:notesTextViewPr><p:cViewPr><p:scale><a:sx n="1" d="1"/><a:sy n="1" d="1"/></p:scale><p:origin x="0" y="0"/></p:cViewPr></p:notesTextViewPr><p:gridSpacing cx="76200" cy="76200"/></p:viewPr>`;
  }

  // src/pptxgen.ts
  var VERSION = "4.0.1";
  var PptxGenJS = class {
    constructor() {
      // Property getters/setters
      /**
       * Presentation layout name
       * Standard layouts:
       * - 'LAYOUT_4x3'   (10"    x 7.5")
       * - 'LAYOUT_16x9'  (10"    x 5.625")
       * - 'LAYOUT_16x10' (10"    x 6.25")
       * - 'LAYOUT_WIDE'  (13.33" x 7.5")
       * Custom layouts:
       * Use `pptx.defineLayout()` to create custom layouts (e.g.: 'A4')
       * @type {string}
       * @see https://support.office.com/en-us/article/Change-the-size-of-your-slides-040a811c-be43-40b9-8d04-0de5ed79987e
       */
      this._layout = DEF_PRES_LAYOUT;
      /**
       * PptxGenJS Library Version
       */
      this._version = VERSION;
      // Exposed class props
      this._alignH = AlignH;
      this._alignV = AlignV;
      this._chartType = ChartType;
      this._outputType = OutputType;
      this._schemeColor = SchemeColor;
      this._shapeType = ShapeType;
      /**
       * @depricated use `ChartType`
       */
      this._charts = CHART_TYPE;
      /**
       * @depricated use `SchemeColor`
       */
      this._colors = SCHEME_COLOR_NAMES;
      /**
       * @depricated use `ShapeType`
       */
      this._shapes = SHAPE_TYPE;
      /**
       * Provides an API for `addTableDefinition` to create slides as needed for auto-paging
       * @param {AddSlideProps} options - slide masterName and/or sectionTitle
       * @return {PresSlide} new Slide
       */
      this.addNewSlide = (options) => {
        const sectAlreadyInUse = this.sections.length > 0 && this.sections[this.sections.length - 1]._slides.filter((slide) => slide._slideNum === this.slides[this.slides.length - 1]._slideNum).length > 0;
        const slideOptions = options || {};
        slideOptions.sectionTitle = sectAlreadyInUse ? this.sections[this.sections.length - 1].title : void 0;
        return this.addSlide(slideOptions);
      };
      /**
       * Provides an API for `addTableDefinition` to get slide reference by number
       * @param {number} slideNum - slide number
       * @return {PresSlide} Slide
       * @since 3.0.0
       */
      this.getSlide = (slideNum) => this.slides.filter((slide) => slide._slideNum === slideNum)[0];
      /**
       * Enables the `Slide` class to set PptxGenJS [Presentation] master/layout slidenumbers
       * @param {SlideNumberProps} slideNum - slide number config
       */
      this.setSlideNumber = (slideNum) => {
        this.masterSlide._slideNumberProps = slideNum;
        this.slideLayouts.filter((layout) => layout._name === DEF_PRES_LAYOUT_NAME)[0]._slideNumberProps = slideNum;
      };
      /**
       * Create all chart and media rels for this Presentation
       * @param {PresSlide | SlideLayout} slide - slide with rels
       * @param {JSZip} zip - JSZip instance
       * @param {Promise<string>[]} chartPromises - promise array
       */
      this.createChartMediaRels = (slide, zip, chartPromises) => {
        slide._relsChart.forEach((rel) => chartPromises.push(createExcelWorksheet(rel, zip)));
        slide._relsMedia.forEach((rel) => {
          if (rel.type !== "online" && rel.type !== "hyperlink") {
            let data = rel.data && typeof rel.data === "string" ? rel.data : "";
            if (!data.includes(",") && !data.includes(";")) data = "image/png;base64," + data;
            else if (!data.includes(",")) data = "image/png;base64," + data;
            else if (!data.includes(";")) data = "image/png;" + data;
            const base64Data = data.split(",").pop() || "";
            zip.file(rel.Target.replace("..", "ppt"), base64Data, { base64: true });
          }
        });
      };
      /**
       * Create and export the .pptx file
       * @param {string} exportName - output file type
       * @param {Blob} blobContent - Blob content
       * @return {Promise<string>} Promise with file name
       */
      this.writeFileToBrowser = (exportName, blobContent) => __async(null, null, function* () {
        const eleLink = document.createElement("a");
        eleLink.setAttribute("style", "display:none;");
        eleLink.dataset.interception = "off";
        document.body.appendChild(eleLink);
        if (window.URL.createObjectURL) {
          const url = window.URL.createObjectURL(new Blob([blobContent], { type: "application/vnd.openxmlformats-officedocument.presentationml.presentation" }));
          eleLink.href = url;
          eleLink.download = exportName;
          eleLink.click();
          setTimeout(() => {
            window.URL.revokeObjectURL(url);
            document.body.removeChild(eleLink);
          }, 100);
          return yield Promise.resolve(exportName);
        }
        return exportName;
      });
      /**
       * Create and export the .pptx file
       * @param {WRITE_OUTPUT_TYPE} outputType - output file type
       * @return {Promise<string | ArrayBuffer | Blob | Buffer | Uint8Array>} Promise with data or stream (node) or filename (browser)
       */
      this.exportPresentation = (props) => __async(this, null, function* () {
        const arrChartPromises = [];
        let arrMediaPromises = [];
        const zip = new import_jszip2.default();
        this.slides.forEach((slide) => {
          arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(slide));
        });
        this.slideLayouts.forEach((layout) => {
          arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(layout));
        });
        arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(this.masterSlide));
        return yield Promise.all(arrMediaPromises).then(() => __async(this, null, function* () {
          this.slides.forEach((slide) => {
            if (slide._slideLayout) addPlaceholdersToSlideLayouts(slide);
          });
          zip.folder("_rels");
          zip.folder("docProps");
          zip.folder("ppt").folder("_rels");
          zip.folder("ppt/charts").folder("_rels");
          zip.folder("ppt/embeddings");
          zip.folder("ppt/media");
          zip.folder("ppt/slideLayouts").folder("_rels");
          zip.folder("ppt/slideMasters").folder("_rels");
          zip.folder("ppt/slides").folder("_rels");
          zip.folder("ppt/theme");
          zip.folder("ppt/notesMasters").folder("_rels");
          zip.folder("ppt/notesSlides").folder("_rels");
          zip.file("[Content_Types].xml", makeXmlContTypes(this.slides, this.slideLayouts, this.masterSlide));
          zip.file("_rels/.rels", makeXmlRootRels());
          zip.file("docProps/app.xml", makeXmlApp(this.slides, this.company));
          zip.file("docProps/core.xml", makeXmlCore(this.title, this.subject, this.author, this.revision));
          zip.file("ppt/_rels/presentation.xml.rels", makeXmlPresentationRels(this.slides));
          zip.file("ppt/theme/theme1.xml", makeXmlTheme(this));
          zip.file("ppt/presentation.xml", makeXmlPresentation(this));
          zip.file("ppt/presProps.xml", makeXmlPresProps());
          zip.file("ppt/tableStyles.xml", makeXmlTableStyles());
          zip.file("ppt/viewProps.xml", makeXmlViewProps());
          this.slideLayouts.forEach((layout, idx) => {
            zip.file(`ppt/slideLayouts/slideLayout${idx + 1}.xml`, makeXmlLayout(layout));
            zip.file(`ppt/slideLayouts/_rels/slideLayout${idx + 1}.xml.rels`, makeXmlSlideLayoutRel(idx + 1, this.slideLayouts));
          });
          this.slides.forEach((slide, idx) => {
            zip.file(`ppt/slides/slide${idx + 1}.xml`, makeXmlSlide(slide));
            zip.file(`ppt/slides/_rels/slide${idx + 1}.xml.rels`, makeXmlSlideRel(this.slides, this.slideLayouts, idx + 1));
            zip.file(`ppt/notesSlides/notesSlide${idx + 1}.xml`, makeXmlNotesSlide(slide));
            zip.file(`ppt/notesSlides/_rels/notesSlide${idx + 1}.xml.rels`, makeXmlNotesSlideRel(idx + 1));
          });
          zip.file("ppt/slideMasters/slideMaster1.xml", makeXmlMaster(this.masterSlide, this.slideLayouts));
          zip.file("ppt/slideMasters/_rels/slideMaster1.xml.rels", makeXmlMasterRel(this.masterSlide, this.slideLayouts));
          zip.file("ppt/notesMasters/notesMaster1.xml", makeXmlNotesMaster());
          zip.file("ppt/notesMasters/_rels/notesMaster1.xml.rels", makeXmlNotesMasterRel());
          this.slideLayouts.forEach((layout) => {
            this.createChartMediaRels(layout, zip, arrChartPromises);
          });
          this.slides.forEach((slide) => {
            this.createChartMediaRels(slide, zip, arrChartPromises);
          });
          this.createChartMediaRels(this.masterSlide, zip, arrChartPromises);
          return yield Promise.all(arrChartPromises).then(() => __async(this, null, function* () {
            if (props.outputType === "STREAM") {
              return yield zip.generateAsync({ type: "nodebuffer", compression: props.compression ? "DEFLATE" : "STORE" });
            } else if (props.outputType) {
              return yield zip.generateAsync({ type: props.outputType });
            } else {
              return yield zip.generateAsync({ type: "blob", compression: props.compression ? "DEFLATE" : "STORE" });
            }
          }));
        }));
      });
      const layout4x3 = { name: "screen4x3", width: 9144e3, height: 6858e3 };
      const layout16x9 = { name: "screen16x9", width: 9144e3, height: 5143500 };
      const layout16x10 = { name: "screen16x10", width: 9144e3, height: 5715e3 };
      const layoutWide = { name: "custom", width: 12192e3, height: 6858e3 };
      this.LAYOUTS = {
        LAYOUT_4x3: layout4x3,
        LAYOUT_16x9: layout16x9,
        LAYOUT_16x10: layout16x10,
        LAYOUT_WIDE: layoutWide
      };
      this._author = "PptxGenJS";
      this._company = "PptxGenJS";
      this._revision = "1";
      this._subject = "PptxGenJS Presentation";
      this._title = "PptxGenJS Presentation";
      this._presLayout = {
        name: this.LAYOUTS[DEF_PRES_LAYOUT].name,
        _sizeW: this.LAYOUTS[DEF_PRES_LAYOUT].width,
        _sizeH: this.LAYOUTS[DEF_PRES_LAYOUT].height,
        width: this.LAYOUTS[DEF_PRES_LAYOUT].width,
        height: this.LAYOUTS[DEF_PRES_LAYOUT].height,
        _chartCounter: 0
      };
      this._rtlMode = false;
      this._strictMode = false;
      this._slideLayouts = [
        {
          _margin: DEF_SLIDE_MARGIN_IN,
          _name: DEF_PRES_LAYOUT_NAME,
          _presLayout: this._presLayout,
          _rels: [],
          _relsChart: [],
          _relsMedia: [],
          _slide: void 0,
          _slideNum: 1e3,
          _slideNumberProps: void 0,
          _slideObjects: []
        }
      ];
      this._slides = [];
      this._sections = [];
      this._masterSlide = {
        // Master slide uses no-op implementations for these methods (master slide doesn't support direct content addition)
        addChart: () => ({ _shapeIndex: -1, _slideRef: this._masterSlide }),
        addImage: () => ({ _shapeIndex: -1, _slideRef: this._masterSlide }),
        addMedia: () => this._masterSlide,
        addNotes: () => this._masterSlide,
        addShape: () => ({ _shapeIndex: -1, _slideRef: this._masterSlide }),
        addTable: () => this._masterSlide,
        addText: () => ({ _shapeIndex: -1, _slideRef: this._masterSlide }),
        addAnimation: () => this._masterSlide,
        //
        _name: "Master",
        _presLayout: this._presLayout,
        _rId: 0,
        _rels: [],
        _relsChart: [],
        _relsMedia: [],
        _slideId: 0,
        _slideLayout: void 0,
        _slideNum: 0,
        _slideNumberProps: void 0,
        _slideObjects: [],
        _animations: []
      };
    }
    set layout(value) {
      const newLayout = this.LAYOUTS[value];
      if (newLayout) {
        this._layout = value;
        this._presLayout = newLayout;
      } else {
        throw new Error("UNKNOWN-LAYOUT");
      }
    }
    get layout() {
      return this._layout;
    }
    get version() {
      return this._version;
    }
    set author(value) {
      this._author = value;
    }
    get author() {
      return this._author;
    }
    set company(value) {
      this._company = value;
    }
    get company() {
      return this._company;
    }
    set revision(value) {
      this._revision = value;
    }
    get revision() {
      return this._revision;
    }
    set subject(value) {
      this._subject = value;
    }
    get subject() {
      return this._subject;
    }
    set theme(value) {
      this._theme = value;
    }
    get theme() {
      return this._theme;
    }
    set title(value) {
      this._title = value;
    }
    get title() {
      return this._title;
    }
    set rtlMode(value) {
      this._rtlMode = value;
    }
    get rtlMode() {
      return this._rtlMode;
    }
    set strictMode(value) {
      this._strictMode = value;
    }
    get strictMode() {
      return this._strictMode;
    }
    get masterSlide() {
      return this._masterSlide;
    }
    get slides() {
      return this._slides;
    }
    get sections() {
      return this._sections;
    }
    get slideLayouts() {
      return this._slideLayouts;
    }
    get AlignH() {
      return this._alignH;
    }
    get AlignV() {
      return this._alignV;
    }
    get ChartType() {
      return this._chartType;
    }
    get OutputType() {
      return this._outputType;
    }
    get presLayout() {
      return this._presLayout;
    }
    get SchemeColor() {
      return this._schemeColor;
    }
    get ShapeType() {
      return this._shapeType;
    }
    get charts() {
      return this._charts;
    }
    get colors() {
      return this._colors;
    }
    get shapes() {
      return this._shapes;
    }
    /**
     * Log a warning or throw an error based on strict mode
     * @param {string} message - warning message
     * @throws {Error} when strictMode is enabled
     */
    warnOrThrow(message) {
      if (this._strictMode) {
        throw new Error(`PptxGenJS: ${message}`);
      } else {
        console.warn(`PptxGenJS: ${message}`);
      }
    }
    // EXPORT METHODS
    /**
     * Export the current Presentation to stream
     * @param {WriteBaseProps} props - output properties
     * @returns {Promise<string | ArrayBuffer | Blob | Buffer | Uint8Array>} file stream
     */
    stream(props) {
      return __async(this, null, function* () {
        return yield this.exportPresentation({
          compression: props == null ? void 0 : props.compression,
          outputType: "STREAM"
        });
      });
    }
    /**
     * Export the current Presentation as JSZip content with the selected type
     * @param {WriteProps} props output properties
     * @returns {Promise<string | ArrayBuffer | Blob | Buffer | Uint8Array>} file content in selected type
     */
    write(props) {
      return __async(this, null, function* () {
        var _a;
        return yield this.exportPresentation({
          compression: (_a = props == null ? void 0 : props.compression) != null ? _a : false,
          outputType: props == null ? void 0 : props.outputType
        });
      });
    }
    /**
     * Export the current Presentation.
     * Write the generated presentation to disk (Node) or trigger a download (browser).
     * @param {WriteFileProps} props - output file properties
     * @returns {Promise<string>} the presentation name
     */
    writeFile(props) {
      return __async(this, null, function* () {
        var _a, _b;
        const isNode = typeof process !== "undefined" && !!((_a = process.versions) == null ? void 0 : _a.node) && ((_b = process.release) == null ? void 0 : _b.name) === "node";
        const { fileName: rawName = "Presentation.pptx", compression = false } = props != null ? props : {};
        const fileName = rawName.toLowerCase().endsWith(".pptx") ? rawName : `${rawName}.pptx`;
        const outputType = isNode ? "nodebuffer" : void 0;
        const data = yield this.exportPresentation({ compression, outputType });
        if (isNode) {
          const { promises: fs } = yield import("fs");
          const { writeFile } = fs;
          yield writeFile(fileName, data);
          return fileName;
        }
        yield this.writeFileToBrowser(fileName, data);
        return fileName;
      });
    }
    // PRESENTATION METHODS
    /**
     * Add a new Section to Presentation
     * @param {ISectionProps} section - section properties
     * @example pptx.addSection({ title:'Charts' });
     */
    addSection(section) {
      if (!section) this.warnOrThrow("addSection requires an argument");
      else if (!section.title) this.warnOrThrow("addSection requires a title");
      const newSection = {
        _type: "user",
        _slides: [],
        title: section.title
      };
      if (section.order) this.sections.splice(section.order, 0, newSection);
      else this._sections.push(newSection);
    }
    /**
     * Add a new Slide to Presentation
     * @param {AddSlideProps} options - slide options
     * @returns {PresSlide} the new Slide
     */
    addSlide(options) {
      const masterSlideName = typeof options === "string" ? options : (options == null ? void 0 : options.masterName) ? options.masterName : "";
      let slideLayout = {
        _name: this.LAYOUTS[DEF_PRES_LAYOUT].name,
        _presLayout: this.presLayout,
        _rels: [],
        _relsChart: [],
        _relsMedia: [],
        _slideNum: this.slides.length + 1
      };
      if (masterSlideName) {
        const tmpLayout = this.slideLayouts.filter((layout) => layout._name === masterSlideName)[0];
        if (tmpLayout) slideLayout = tmpLayout;
      }
      const newSlide = new Slide({
        addSlide: this.addNewSlide,
        getSlide: this.getSlide,
        presLayout: this.presLayout,
        setSlideNum: this.setSlideNumber,
        slideId: this.slides.length + 256,
        slideRId: this.slides.length + 2,
        slideNumber: this.slides.length + 1,
        slideLayout
      });
      this._slides.push(newSlide);
      if (options == null ? void 0 : options.sectionTitle) {
        const sect = this.sections.filter((section) => section.title === options.sectionTitle)[0];
        if (!sect) this.warnOrThrow(`addSlide: unable to find section with title: "${options.sectionTitle}"`);
        else sect._slides.push(newSlide);
      } else if (this.sections && this.sections.length > 0 && !(options == null ? void 0 : options.sectionTitle)) {
        const lastSect = this._sections[this.sections.length - 1];
        if (lastSect._type === "default") lastSect._slides.push(newSlide);
        else {
          this._sections.push({
            title: `Default-${this.sections.filter((sect) => sect._type === "default").length + 1}`,
            _type: "default",
            _slides: [newSlide]
          });
        }
      }
      return newSlide;
    }
    /**
     * Create a custom Slide Layout in any size
     * @param {PresLayout} layout - layout properties
     * @example pptx.defineLayout({ name:'A3', width:16.5, height:11.7 });
     */
    defineLayout(layout) {
      if (!layout) this.warnOrThrow("defineLayout requires `{name, width, height}`");
      else if (!layout.name) this.warnOrThrow("defineLayout requires `name`");
      else if (!layout.width) this.warnOrThrow("defineLayout requires `width`");
      else if (!layout.height) this.warnOrThrow("defineLayout requires `height`");
      else if (typeof layout.height !== "number") this.warnOrThrow("defineLayout `height` should be a number (inches)");
      else if (typeof layout.width !== "number") this.warnOrThrow("defineLayout `width` should be a number (inches)");
      this.LAYOUTS[layout.name] = {
        name: layout.name,
        _sizeW: Math.round(Number(layout.width) * EMU),
        _sizeH: Math.round(Number(layout.height) * EMU),
        width: Math.round(Number(layout.width) * EMU),
        height: Math.round(Number(layout.height) * EMU)
      };
    }
    /**
     * Create a new slide master [layout] for the Presentation
     * @param {SlideMasterProps} props - layout properties
     */
    defineSlideMaster(props) {
      const propsClone = structuredClone(props);
      if (!propsClone.title) throw new Error("defineSlideMaster() object argument requires a `title` value. (https://gitbrent.github.io/PptxGenJS/docs/masters.html)");
      const newLayout = {
        _margin: propsClone.margin || DEF_SLIDE_MARGIN_IN,
        _name: propsClone.title,
        _presLayout: this.presLayout,
        _rels: [],
        _relsChart: [],
        _relsMedia: [],
        _slide: void 0,
        _slideNum: 1e3 + this.slideLayouts.length + 1,
        _slideNumberProps: propsClone.slideNumber,
        _slideObjects: [],
        background: propsClone.background
      };
      createSlideMaster(propsClone, newLayout);
      this.slideLayouts.push(newLayout);
      if (propsClone.background) addBackgroundDefinition(propsClone.background, newLayout);
      if (newLayout._slideNumberProps && !this.masterSlide._slideNumberProps) this.masterSlide._slideNumberProps = newLayout._slideNumberProps;
    }
    // HTML-TO-SLIDES METHODS
    /**
     * Reproduces an HTML table as a PowerPoint table - including column widths, style, etc. - creates 1 or more slides as needed
     * @param {string} eleId - table HTML element ID
     * @param {TableToSlidesProps} options - generation options
     */
    tableToSlides(eleId, options = {}) {
      genTableToSlides(
        this,
        eleId,
        options,
        (options == null ? void 0 : options.masterSlideName) ? this.slideLayouts.filter((layout) => layout._name === options.masterSlideName)[0] : void 0
      );
    }
  };
  return __toCommonJS(pptxgen_exports);
})();
if (typeof module !== "undefined") module.exports = PptxGenJS;
//# sourceMappingURL=pptxgen.bundle.js.map